Implementation smell,Namespace,Class,File,Method,Description
Long Method,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The method has 486 lines of code.
Long Method,Scada.Server.Engine,MainLogic,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\MainLogic.cs,ReadInCnls,The method has 115 lines of code.
Long Method,Scada.Server.Engine,MainLogic,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\MainLogic.cs,Execute,The method has 232 lines of code.
Complex Method,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,GetCmdDescr,Cyclomatic complexity of the method is 15
Complex Method,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,Execute,Cyclomatic complexity of the method is 11
Complex Method,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,Cyclomatic complexity of the method is 49
Complex Method,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,GetFullFileName,Cyclomatic complexity of the method is 10
Complex Method,Scada.Server.Engine,MainLogic,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\MainLogic.cs,ReadInCnls,Cyclomatic complexity of the method is 12
Complex Method,Scada.Server.Engine,MainLogic,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\MainLogic.cs,InitCalculator,Cyclomatic complexity of the method is 18
Complex Method,Scada.Server.Engine,MainLogic,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\MainLogic.cs,Execute,Cyclomatic complexity of the method is 20
Complex Method,Scada.Server.Engine,MainLogic,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\MainLogic.cs,WriteReceivedSrez,Cyclomatic complexity of the method is 8
Complex Method,Scada.Server.Engine,MainLogic,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\MainLogic.cs,CalcCnlData,Cyclomatic complexity of the method is 11
Complex Method,Scada.Server.Engine,MainLogic,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\MainLogic.cs,ProcCurData,Cyclomatic complexity of the method is 9
Complex Method,Scada.Server.Engine,MainLogic,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\MainLogic.cs,ProcArcData,Cyclomatic complexity of the method is 9
Long Parameter List,Scada.Server.Engine,MainLogic,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\MainLogic.cs,WriteReceivedSrez,The method has 5 parameters. Parameters: srezTable' srezAdapter' receivedSrez' srezDT' arcSrez
Complex Conditional,Scada.Server.Engine,MainLogic,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\MainLogic.cs,Execute,The conditional expression  "(writeCurSrezDT <= nowDT || writeCurOnMod && curSrezMod) && writeCur"  is complex.
Complex Conditional,Scada.Server.Engine,MainLogic,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\MainLogic.cs,ClearArchive,The conditional expression  "fileName.Length >= 7 &&                             int.TryParse(fileName.Substring(1' 2)' out int year) &&                             int.TryParse(fileName.Substring(3' 2)' out int month) &&                             int.TryParse(fileName.Substring(5' 2)' out int day)"  is complex.
Complex Conditional,Scada.Server.Engine,MainLogic,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\MainLogic.cs,GenEvent,The conditional expression  "inCnl.EvOnChange && dataChanged ||                      // события по неопределённому состоянию и выходу из него                     inCnl.EvOnUndef &&                      (oldStat > BaseValues.CnlStatuses.Undefined && newStat == BaseValues.CnlStatuses.Undefined ||                      oldStat == BaseValues.CnlStatuses.Undefined && newStat > BaseValues.CnlStatuses.Undefined) ||                     // события нормализации                     newStat == BaseValues.CnlStatuses.Normal &&                      oldStat != newStat && oldStat != BaseValues.CnlStatuses.Undefined ||                     // события занижения и завышения                     (newStat == BaseValues.CnlStatuses.LowCrash || newStat == BaseValues.CnlStatuses.Low ||                      newStat == BaseValues.CnlStatuses.High || newStat == BaseValues.CnlStatuses.HighCrash) &&                      oldStat != newStat"  is complex.
Complex Conditional,Scada.Server.Engine,MainLogic,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\MainLogic.cs,SetUnreliable,The conditional expression  "(cnlTypeID == BaseValues.CnlTypes.TS || cnlTypeID == BaseValues.CnlTypes.TI) &&                         curSrez.CnlData[i].Stat > BaseValues.CnlStatuses.Undefined &&                          nowDT - activeDTs[i] > inactUnrelSpan"  is complex.
Complex Conditional,Scada.Server.Engine,MainLogic,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\MainLogic.cs,Start,The conditional expression  "CheckDataDirs() && CheckBaseFiles() && ReadBase() && InitCalculator() && comm.Start()"  is complex.
Complex Conditional,Scada.Server.Engine,MainLogic,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\MainLogic.cs,ProcCurData,The conditional expression  "inCnl.Averaging &&                                                  newCnlData.Stat > BaseValues.CnlStatuses.Undefined &&                                                 newCnlData.Stat != BaseValues.CnlStatuses.FormulaError &&                                                 newCnlData.Stat != BaseValues.CnlStatuses.Unreliable"  is complex.
Empty Catch Block,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,Disconnect,The method has an empty catch block.
Empty Catch Block,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,Disconnect,The method has an empty catch block.
Magic Number,Scada.Server.Engine,Calculator,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Calculator.cs,AddCnlFormulaSource,The following statement contains a magic number: string part1 = parts.Length < 2 ? "" : parts[1].Trim();
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,Execute,The following statement contains a magic number: Thread.Sleep(10);
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ReceiveData,The following statement contains a magic number: int bytesRead = netStream.Read(inBuf' 0' 3);
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ReceiveData,The following statement contains a magic number: byte cmd = inBuf[2];
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ReceiveData,The following statement contains a magic number: int dataLen = cmdLen - 3;
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ReceiveData,The following statement contains a magic number: bytesRead = dataLen > 0 ? ReadNetStream(netStream' inBuf' 3' dataLen) : 0;
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ReceiveData,The following statement contains a magic number: bytesRead == 3
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: int respLen = 5 + respDataLen;
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes((uint)respLen)' 0' outBuf' 0' 4);
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: outBuf[4] = cmd;
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following statement contains a magic number: client.NetStream.Write(outBuf' 0' 7);
Magic Number,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,FillCommandProps,The following statement contains a magic number: cmdTypeID == BaseValues.CmdTypes.Standard && cmd.CmdData != null && cmd.CmdData.Length == 8
Magic Number,Scada.Server.Engine,MainLogic,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\MainLogic.cs,Execute,The following statement contains a magic number: calcMinDT = drmCnls.Count > 0 ? CalcNextTime(nowDT' 60) : DateTime.MaxValue;
Magic Number,Scada.Server.Engine,MainLogic,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\MainLogic.cs,Execute,The following statement contains a magic number: calcHrDT = drhCnls.Count > 0 ? CalcNextTime(nowDT' 3600) : DateTime.MaxValue;
Magic Number,Scada.Server.Engine,MainLogic,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\MainLogic.cs,Execute,The following statement contains a magic number: calcMinDT = CalcNextTime(nowDT' 60);
Magic Number,Scada.Server.Engine,MainLogic,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\MainLogic.cs,Execute,The following statement contains a magic number: calcHrDT = CalcNextTime(nowDT' 3600);
Magic Number,Scada.Server.Engine,MainLogic,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\MainLogic.cs,Execute,The following statement contains a magic number: Thread.Sleep(100);
Magic Number,Scada.Server.Engine,MainLogic,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\MainLogic.cs,ClearArchive,The following statement contains a magic number: fileDate = new DateTime(2000 + year' month' day);
Magic Number,Scada.Server.Engine,MainLogic,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\MainLogic.cs,ClearArchive,The following statement contains a magic number: fileName.Length >= 7 &&                             int.TryParse(fileName.Substring(1' 2)' out int year) &&                             int.TryParse(fileName.Substring(3' 2)' out int month) &&                             int.TryParse(fileName.Substring(5' 2)' out int day)
Magic Number,Scada.Server.Engine,MainLogic,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\MainLogic.cs,ClearArchive,The following statement contains a magic number: fileName.Length >= 7 &&                             int.TryParse(fileName.Substring(1' 2)' out int year) &&                             int.TryParse(fileName.Substring(3' 2)' out int month) &&                             int.TryParse(fileName.Substring(5' 2)' out int day)
Magic Number,Scada.Server.Engine,MainLogic,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\MainLogic.cs,ClearArchive,The following statement contains a magic number: fileName.Length >= 7 &&                             int.TryParse(fileName.Substring(1' 2)' out int year) &&                             int.TryParse(fileName.Substring(3' 2)' out int month) &&                             int.TryParse(fileName.Substring(5' 2)' out int day)
Magic Number,Scada.Server.Engine,MainLogic,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\MainLogic.cs,ClearArchive,The following statement contains a magic number: fileName.Length >= 7 &&                             int.TryParse(fileName.Substring(1' 2)' out int year) &&                             int.TryParse(fileName.Substring(3' 2)' out int month) &&                             int.TryParse(fileName.Substring(5' 2)' out int day)
Magic Number,Scada.Server.Engine,MainLogic,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\MainLogic.cs,ClearArchive,The following statement contains a magic number: fileName.Length >= 7 &&                             int.TryParse(fileName.Substring(1' 2)' out int year) &&                             int.TryParse(fileName.Substring(3' 2)' out int month) &&                             int.TryParse(fileName.Substring(5' 2)' out int day)
Magic Number,Scada.Server.Engine,MainLogic,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\MainLogic.cs,ClearArchive,The following statement contains a magic number: fileName.Length >= 7 &&                             int.TryParse(fileName.Substring(1' 2)' out int year) &&                             int.TryParse(fileName.Substring(3' 2)' out int month) &&                             int.TryParse(fileName.Substring(5' 2)' out int day)
Magic Number,Scada.Server.Engine,MainLogic,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\MainLogic.cs,CalcCnlData,The following statement contains a magic number: bool even = (int)oldCnlData.Val % 2 == 0;
Missing Default,Scada.Server.Engine,Comm,C:\research\architectureSmells\repos\RapidScada_SCADA\ScadaServer\ScadaServer\ScadaServerEngine\Comm.cs,ProcCommCommand,The following switch statement is missing a default case: switch (cmd)             {                 case 0x01: // проверка имени и пароля                     int userNameLen = inBuf[3];                     string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                     string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                     bool pwdIsEmpty = string.IsNullOrEmpty(password);                     int roleID;                     bool checkOk = mainLogic.CheckUser(userName' password' out roleID);                      if (client.Authenticated)                     {                         if (pwdIsEmpty)                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "успешно" : "success") :                                 (Localization.UseRussian ? "ошибка" : "error");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение роли пользователя {0}. Результат: {1}" :                                  "Get user {0} role. Result: {1}"' userName' checkOkStr));                         }                         else                         {                             string checkOkStr = checkOk ?                                 (Localization.UseRussian ? "верно" : "passed") :                                 (Localization.UseRussian ? "неверно" : "failed");                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                  "Check username and password for {0}. Result: {1}"' userName' checkOkStr));                         }                     }                     else                     {                         if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                         {                             client.Authenticated = true;                             client.UserName = userName;                             client.UserRoleID = roleID;                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Пользователь {0} успешно аутентифицирован" :                                  "The user {0} is successfully authenticated"' userName));                         }                         else                         {                             client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Неудачная попытка аутентификации пользователя {0}" :                                  "Unsuccessful attempt to authenticate the user {0}"' userName));                         }                     }                      respDataLen = 1;                     outBuf[3] = (byte)roleID;                     break;                 case 0x02: // запрос состояния сервера (ping)                     respDataLen = 1;                     outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                     break;                 case 0x03: // запись текущего среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                          for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x04: // запись архивного среза                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                         SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                          for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                         {                             srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                             srez.CnlData[i] = new SrezTableLight.CnlData(                                 BitConverter.ToDouble(inBuf' j + 4)'                                 BitConverter.ToUInt16(inBuf' j + 12));                         }                          outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x05: // запись события                     if (client.UserRoleID == BaseValues.Roles.App)                     {                         EventTableLight.Event ev = new EventTableLight.Event();                         ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                         ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                         ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                         ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                         ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                         ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                         ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                         ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                         ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                         ev.Checked = BitConverter.ToBoolean(inBuf' 41);                         ev.UserID = BitConverter.ToUInt16(inBuf' 42);                         int evDescrLen = inBuf[44];                         int evDataLen = inBuf[45 + evDescrLen];                         ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                         ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                          outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x06: // команда ТУ                     bool cmdProcOk = false; // команда обработана успешно                      if (client.UserRoleID == BaseValues.Roles.Admin ||                          client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                     {                         int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                         byte cmdTypeID = inBuf[5];                         int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                         MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                          if (ctrlCnl == null)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                 "Command to nonexistent out channel {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                         }                         else                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                 "Command: out channel = {0}' user ID = {1}"'                                 ctrlCnlNum' cmdUserID));                              // создание команды ТУ                             Command ctrlCmd = new Command(cmdTypeID);                             ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                             Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                             FillCommandProps(ctrlCmd' ctrlCnl);                              // обработка команды ТУ                             bool passToClients;                             mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                              if (passToClients)                             {                                 // передача команды ТУ подключенным клиентам                                 ctrlCmd.PrepareCmdData();                                 foreach (ClientInfo cl in clients)                                     if (cl.UserRoleID == BaseValues.Roles.App)                                         cl.CmdList.Add(ctrlCmd);                             }                             else if (ctrlCmd.CmdNum > 0)                             {                                 appLog.WriteAction(Localization.UseRussian ?                                      "Команда ТУ отменена" :                                      "Command is canceled");                             }                              cmdProcOk = true;                         }                     }                      respDataLen = 1;                     outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                     break;                 case 0x07: // запрос команды ТУ                     if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                     {                         Command ctrlCmd = client.CmdList[0];                         int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                         respDataLen = 7 + cmdDataLen;                         outBuf[3] = (byte)(cmdDataLen % 256);                         outBuf[4] = (byte)(cmdDataLen / 256);                         outBuf[5] = (byte)ctrlCmd.CmdTypeID;                         outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                         outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                         outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                         outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                         if (cmdDataLen > 0)                             Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                          // удаление команды ТУ из списка команд клиента                         client.CmdList.RemoveAt(0);                     }                     else                     {                         respDataLen = 2;                         outBuf[3] = 0;                         outBuf[4] = 0;                     }                     break;                 case 0x08: // открытие и чтение из файла                     int readCnt = 0;                     bool readOk = false;                      if (client.Authenticated)                     {                         client.CloseFile();                          try { client.Dir = (Dirs)inBuf[3]; }                         catch { client.Dir = Dirs.Cur; }                          int fileNameLen = inBuf[4];                         client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                         string fullFileName = GetFullFileName(client.Dir' client.FileName);                         int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Открытие файла {0}" :                                  "Opening file {0}"' fullFileName));                          try                         {                             if (File.Exists(fullFileName))                             {                                 client.FileStream = new FileStream(fullFileName'                                     FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                 readCnt = client.FileStream.Read(outBuf' 6' count);                                 readOk = true;                             }                             else                             {                                 appLog.WriteError(string.Format(Localization.UseRussian ?                                     "Файл {0} не найден." :                                      "File {0} not found."' client.FullFileNameInfo));                             }                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 3 + readCnt;                     outBuf[3] = readOk ? (byte)1 : (byte)0;                     outBuf[4] = (byte)(readCnt % 256);                     outBuf[5] = (byte)(readCnt / 256);                     break;                 case 0x09: // перемещение позиции чтения из файла                     long pos = 0;                     bool seekOk = false;                      if (client.Authenticated && client.FileStream != null)                     {                         SeekOrigin origin;                         try { origin = (SeekOrigin)inBuf[3]; }                         catch { origin = SeekOrigin.Begin; }                         long offset = BitConverter.ToUInt32(inBuf' 4);                          try                         {                             pos = client.FileStream.Seek(offset' origin);                             seekOk = true;                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                 "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                     }                      respDataLen = 5;                     outBuf[3] = seekOk ? (byte)1 : (byte)0;                     Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                     break;                 case 0x0A: // чтение из файла                     readCnt = 0;                      if (client.Authenticated && client.FileStream != null)                     {                         int count = BitConverter.ToUInt16(inBuf' 3);                          try                         {                             readCnt = client.FileStream.Read(outBuf' 5' count);                         }                         catch (Exception ex)                         {                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                 client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                         }                         finally                         {                             if (readCnt < count)                                 client.CloseFile();                         }                     }                      respDataLen = 2 + readCnt;                     outBuf[3] = (byte)(readCnt % 256);                     outBuf[4] = (byte)(readCnt / 256);                     break;                 case 0x0B: // закрытие файла                     if (client.Authenticated && client.FileStream != null)                     {                         client.CloseFile();                         outBuf[3] = 1;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;                 case 0x0C: // запрос времени изменения файлов                     int fileCnt = inBuf[3];                     outBuf[3] = inBuf[3];                      for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                     {                         Dirs dir;                         try { dir = (Dirs)inBuf[j++]; }                         catch { dir = Dirs.Cur; }                          int fileNameLen = inBuf[j++];                         string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                         string fullFileName = GetFullFileName(dir' fileName);                         j += fileNameLen;                          if (settings.DetailedLog)                             appLog.WriteAction(string.Format(Localization.UseRussian ?                                 "Получение времени изменения файла {0}" :                                  "Obtaining the modification time of the file {0}"' fullFileName));                          double fileModTime;                         try                          {                             fileModTime = File.Exists(fullFileName) ?                                 ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                          }                         catch                         {                             fileModTime = 0;                         }                          Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                     }                      respDataLen = 1 + 8 * fileCnt;                     break;                 case 0x0D: // запрос данных из таблицы среза                     byte srezTypeNum = inBuf[3];                     SnapshotTypes srezType;                     DateTime srezDate;                      if (srezTypeNum == 0x01)                     {                         srezType = SnapshotTypes.Cur;                         srezDate = DateTime.MinValue;                     }                     else                     {                         srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                         srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                     }                      int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                     int[] cnlNums = new int[cnlNumCnt];                      for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                         cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                      if (settings.DetailedLog)                     {                         string srezTypeStr;                         if (srezType == SnapshotTypes.Cur)                             srezTypeStr = Localization.UseRussian ? "текущие" : "current";                         else if (srezType == SnapshotTypes.Min)                             srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                         else                             srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                          appLog.WriteAction(string.Format(Localization.UseRussian ?                              "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                              "Data request. Type: {0}. Date: {1}. Channels: {2}"'                             srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                     }                      SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                     int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                     outBuf[5] = (byte)(srezCnt % 256);                     outBuf[6] = (byte)(srezCnt / 256);                     extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                      for (int i = 0' j = 0; i < srezCnt; i++)                     {                         SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                         Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                         j += 8;                          for (int k = 0; k < cnlNumCnt; k++)                         {                             SrezTable.CnlData cnlData = srez.CnlData[k];                             Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                             j += 8;                             extraData[j++] = (byte)(cnlData.Stat % 256);                             extraData[j++] = (byte)(cnlData.Stat / 256);                         }                     }                      respDataLen = 2 + extraData.Length;                     break;                 case 0x0E: // квитирование события                     if (client.Authenticated)                     {                         int evUserID = BitConverter.ToUInt16(inBuf' 3);                         DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                         int evNum = BitConverter.ToUInt16(inBuf' 8);                         outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                     }                     else                     {                         outBuf[3] = 0;                     }                      respDataLen = 1;                     break;             }
