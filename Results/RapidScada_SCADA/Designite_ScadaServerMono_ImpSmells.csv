Implementation smell,Namespace,Class,File,Method,Description
Long Method,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The method has 436 lines of code.
Long Method,Scada.Server.Svc,MainLogic,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\MainLogic.cs,Execute,The method has 190 lines of code.
Complex Method,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,CheckUser,Cyclomatic complexity of the method is 10
Complex Method,Scada.Server.Svc,MainLogic,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\MainLogic.cs,InitCalculator,Cyclomatic complexity of the method is 15
Complex Method,Scada.Server.Svc,MainLogic,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\MainLogic.cs,Execute,Cyclomatic complexity of the method is 13
Complex Method,Scada.Server.Svc,MainLogic,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\MainLogic.cs,CalcCnlData,Cyclomatic complexity of the method is 9
Long Parameter List,Scada.Server.Svc,MainLogic,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\MainLogic.cs,WriteReceivedSrez,The method has 5 parameters. Parameters: srezTable' srezAdapter' receivedSrez' srezDT' arcSrez
Complex Conditional,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,CheckUser,The conditional expression  "user != null && (pwdOk || string.IsNullOrEmpty(password) || password == user.Password)"  is complex.
Complex Conditional,Scada.Server.Svc,MainLogic,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\MainLogic.cs,Execute,The conditional expression  "(writeCurSrezDT <= nowDT || writeCurOnMod && curSrezMod) && writeCur"  is complex.
Complex Conditional,Scada.Server.Svc,MainLogic,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\MainLogic.cs,ClearArchive,The conditional expression  "fileName.Length >= 7 &&                              int.TryParse(fileName.Substring(1' 2)' out year) &&                              int.TryParse(fileName.Substring(3' 2)' out month) &&                              int.TryParse(fileName.Substring(5' 2)' out day)"  is complex.
Complex Conditional,Scada.Server.Svc,MainLogic,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\MainLogic.cs,GenEvent,The conditional expression  "inCnl.EvOnChange && dataChanged ||                       // события по неопределённому состоянию и выходу из него                      inCnl.EvOnUndef &&                       (oldStat > BaseValues.CnlStatuses.Undefined && newStat == BaseValues.CnlStatuses.Undefined ||                       oldStat == BaseValues.CnlStatuses.Undefined && newStat > BaseValues.CnlStatuses.Undefined) ||                      // события нормализации                      newStat == BaseValues.CnlStatuses.Normal &&                       oldStat != newStat && oldStat != BaseValues.CnlStatuses.Undefined ||                      // события занижения и завышения                      (newStat == BaseValues.CnlStatuses.LowCrash || newStat == BaseValues.CnlStatuses.Low ||                       newStat == BaseValues.CnlStatuses.High || newStat == BaseValues.CnlStatuses.HighCrash) &&                       oldStat != newStat"  is complex.
Complex Conditional,Scada.Server.Svc,MainLogic,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\MainLogic.cs,SetUnreliable,The conditional expression  "(cnlTypeID == BaseValues.CnlTypes.TS || cnlTypeID == BaseValues.CnlTypes.TI) &&                          curSrez.CnlData[i].Stat > BaseValues.CnlStatuses.Undefined &&                           nowDT - activeDTs[i] > inactUnrelSpan"  is complex.
Complex Conditional,Scada.Server.Svc,MainLogic,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\MainLogic.cs,Start,The conditional expression  "CheckDataDirs() && CheckBaseFiles() && ReadBase() && InitCalculator() && comm.Start()"  is complex.
Complex Conditional,Scada.Server.Svc,MainLogic,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\MainLogic.cs,ProcCurData,The conditional expression  "inCnl.Averaging &&                                                   newCnlData.Stat > BaseValues.CnlStatuses.Undefined &&                                                  newCnlData.Stat != BaseValues.CnlStatuses.FormulaError &&                                                  newCnlData.Stat != BaseValues.CnlStatuses.Unreliable"  is complex.
Empty Catch Block,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,Disconnect,The method has an empty catch block.
Empty Catch Block,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,Disconnect,The method has an empty catch block.
Empty Catch Block,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,CheckUser,The method has an empty catch block.
Empty Catch Block,Scada.Server.Svc,Manager,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Manager.cs,StartService,The method has an empty catch block.
Magic Number,Scada.Server.Svc,Calculator,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Calculator.cs,AddCnlFormulaSource,The following statement contains a magic number: if (cnlNum > 0)              {                  string[] parts = string.IsNullOrEmpty(source) ? new string[0] : source.Split(';');                  string part0 = parts.Length < 1 ? "" : parts[0].Trim();                  string part1 = parts.Length < 2 ? "" : parts[1].Trim();                    string calcCnlValName = "CalcCnl" + cnlNum + "Val";                  string calcCnlValExpr = part0 == "" ? "CnlVal" : "Convert.ToDouble(" + part0 + ")";                  string calcCnlValSrc = string.Format("public double {0}() {{ return {1}; }}"'                       calcCnlValName' calcCnlValExpr);                  exprList.Add(calcCnlValSrc);                    string calcCnlStatName = "CalcCnl" + cnlNum + "Stat";                  string calcCnlStatExpr = part1 == "" ? "CnlStat" : "Convert.ToInt32(" + part1 + ")";                  string calcCnlStatSrc = string.Format("public int {0}() {{ return {1}; }}"'                       calcCnlStatName' calcCnlStatExpr);                  exprList.Add(calcCnlStatSrc);                    string calcCnlDataSrc = string.Format("public void CalcCnl{0}" +                       "Data(ref SrezTableLight.CnlData cnlData) {{ try {{ BeginCalcCnlData({0}' cnlData); " +                       "cnlData = new SrezTableLight.CnlData({1}()' {2}()); }} finally {{ EndCalcCnlData(); }}}}"'                      cnlNum' calcCnlValName' calcCnlStatName);                  exprList.Add(calcCnlDataSrc);              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,Execute,The following statement contains a magic number: while (!terminated)              {                  Monitor.Enter(clients);                  ClientInfo client = null;                    try                  {                      // открытие запрашиваемых соединений с клиентами                      while (tcpListener.Pending() && !terminated)                      {                          TcpClient tcpClient = tcpListener.AcceptTcpClient();                          tcpClient.NoDelay = true;                          tcpClient.SendTimeout = TcpSendTimeout;                          tcpClient.ReceiveTimeout = TcpReceiveTimeout;                            client = new ClientInfo(tcpClient);                          appLog.WriteAction(string.Format(Localization.UseRussian ? "Соединение с клиентом {0}" :                               "Connect to client {0}"' client.Address)' Log.ActTypes.Action);                          clients.Add(client);                            // подтверждение соединения - отправка версии сервера                          client.NetStream.Write(AppVersionBuf' 0' AppVersionBuf.Length);                      }                        DateTime nowDT = DateTime.Now;                      int clientInd = 0;                        while (clientInd < clients.Count && !terminated)                      {                          client = clients[clientInd];                            // приём и обработка данных от клиента                          if (client.TcpClient.Available > 0)                          {                              client.ActivityDT = nowDT;                              ReceiveData(client);                          }                            if ((nowDT - client.ActivityDT).TotalSeconds > InactiveTime)                          {                              // отключение клиента' если он не активен                              appLog.WriteAction(string.Format(Localization.UseRussian ? "Отключение клиента {0}" :                                  "Disconnect client {0}"' client.Address)' Log.ActTypes.Action);                              Disconnect(client.TcpClient' client.NetStream);                              client.CloseFile();                              clients.RemoveAt(clientInd);                          }                          else                          {                              // удаление устаревших команд ТУ из списка команд клиента                              int cmdInd = 0;                              while (cmdInd < client.CmdList.Count)                              {                                  if ((nowDT - client.CmdList[cmdInd].CreateDT).TotalSeconds > CmdLifeTime)                                      client.CmdList.RemoveAt(cmdInd);                                  else                                      cmdInd++;                              }                                // переход к следующему клиенту                              clientInd++;                          }                      }                        // передача команд ТУ подключенным клиентам                      lock (cmdBuf)                      {                          if (cmdBuf.Count > 0)                          {                              foreach (ClientInfo cl in clients)                                  if (cl.UserRoleID == BaseValues.Roles.App)                                      cl.CmdList.AddRange(cmdBuf);                              cmdBuf.Clear();                          }                      }                  }                  catch (Exception ex)                  {                      string s = client == null ?                           (Localization.UseRussian ?                               "Ошибка при взаимодействии с клиентами" : "Error communicating with clients") :                          string.Format(Localization.UseRussian ?                              "Ошибка при взаимодействии с клиентом {0}" : "Error communicating with the client {0}"'                               client.Address);                      appLog.WriteAction(s + ": " + ex.Message' Log.ActTypes.Exception);                  }                  finally                  {                      Monitor.Exit(clients);                  }                    Thread.Sleep(10);              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ReceiveData,The following statement contains a magic number: try              {                  // приём длины данных и номера команды                  NetworkStream netStream = client.NetStream;                  bool formatError = true;                  int bytesRead = netStream.Read(inBuf' 0' 3);                    if (bytesRead == 3)                  {                      int cmdLen = (int)BitConverter.ToUInt16(inBuf' 0);                      byte cmd = inBuf[2];                        if (cmdLen <= InBufLenght)                      {                          // приём оставшейся части данных                          int dataLen = cmdLen - 3;                          bytesRead = dataLen > 0 ? ReadNetStream(netStream' inBuf' 3' dataLen) : 0;                            if (bytesRead == dataLen)                          {                              formatError = false;                                                            if (settings.DetailedLog ||                                   cmd == 0x06 /*команда ТУ*/ || cmd == 0x0E /*квитирование события*/)                                  appLog.WriteAction(string.Format(Localization.UseRussian ?                                       "Получена команда {0} от клиента {1}" :                                       "Command {0} is received from the client {1}"'                                      CmdDescrs[cmd]' client.Address)' Log.ActTypes.Action);                                // обработка команды                              ProcCommCommand(client' cmd' cmdLen);                          }                      }                  }                    if (formatError)                  {                      appLog.WriteAction(string.Format(Localization.UseRussian ?                           "Некорректный формат полученных данных от клиента {1}" :                           "Incorrect format of the data received from the client {0}"'                           client.Address)' Log.ActTypes.Error);                        // очистка потока: приём имеющихся данных' но не более InBufLenght                      if (netStream.DataAvailable)                          netStream.Read(inBuf' 0' inBuf.Length);                  }              }              catch (Exception ex)              {                  appLog.WriteAction(string.Format(Localization.UseRussian ?                       "Ошибка при приёме и обработке данных от клиента {0}: {1}" :                      "Error receiving and processing data from the client {0}: {1}"'                      client.Address' ex.Message)' Log.ActTypes.Exception);              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ReceiveData,The following statement contains a magic number: try              {                  // приём длины данных и номера команды                  NetworkStream netStream = client.NetStream;                  bool formatError = true;                  int bytesRead = netStream.Read(inBuf' 0' 3);                    if (bytesRead == 3)                  {                      int cmdLen = (int)BitConverter.ToUInt16(inBuf' 0);                      byte cmd = inBuf[2];                        if (cmdLen <= InBufLenght)                      {                          // приём оставшейся части данных                          int dataLen = cmdLen - 3;                          bytesRead = dataLen > 0 ? ReadNetStream(netStream' inBuf' 3' dataLen) : 0;                            if (bytesRead == dataLen)                          {                              formatError = false;                                                            if (settings.DetailedLog ||                                   cmd == 0x06 /*команда ТУ*/ || cmd == 0x0E /*квитирование события*/)                                  appLog.WriteAction(string.Format(Localization.UseRussian ?                                       "Получена команда {0} от клиента {1}" :                                       "Command {0} is received from the client {1}"'                                      CmdDescrs[cmd]' client.Address)' Log.ActTypes.Action);                                // обработка команды                              ProcCommCommand(client' cmd' cmdLen);                          }                      }                  }                    if (formatError)                  {                      appLog.WriteAction(string.Format(Localization.UseRussian ?                           "Некорректный формат полученных данных от клиента {1}" :                           "Incorrect format of the data received from the client {0}"'                           client.Address)' Log.ActTypes.Error);                        // очистка потока: приём имеющихся данных' но не более InBufLenght                      if (netStream.DataAvailable)                          netStream.Read(inBuf' 0' inBuf.Length);                  }              }              catch (Exception ex)              {                  appLog.WriteAction(string.Format(Localization.UseRussian ?                       "Ошибка при приёме и обработке данных от клиента {0}: {1}" :                      "Error receiving and processing data from the client {0}: {1}"'                      client.Address' ex.Message)' Log.ActTypes.Exception);              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ReceiveData,The following statement contains a magic number: try              {                  // приём длины данных и номера команды                  NetworkStream netStream = client.NetStream;                  bool formatError = true;                  int bytesRead = netStream.Read(inBuf' 0' 3);                    if (bytesRead == 3)                  {                      int cmdLen = (int)BitConverter.ToUInt16(inBuf' 0);                      byte cmd = inBuf[2];                        if (cmdLen <= InBufLenght)                      {                          // приём оставшейся части данных                          int dataLen = cmdLen - 3;                          bytesRead = dataLen > 0 ? ReadNetStream(netStream' inBuf' 3' dataLen) : 0;                            if (bytesRead == dataLen)                          {                              formatError = false;                                                            if (settings.DetailedLog ||                                   cmd == 0x06 /*команда ТУ*/ || cmd == 0x0E /*квитирование события*/)                                  appLog.WriteAction(string.Format(Localization.UseRussian ?                                       "Получена команда {0} от клиента {1}" :                                       "Command {0} is received from the client {1}"'                                      CmdDescrs[cmd]' client.Address)' Log.ActTypes.Action);                                // обработка команды                              ProcCommCommand(client' cmd' cmdLen);                          }                      }                  }                    if (formatError)                  {                      appLog.WriteAction(string.Format(Localization.UseRussian ?                           "Некорректный формат полученных данных от клиента {1}" :                           "Incorrect format of the data received from the client {0}"'                           client.Address)' Log.ActTypes.Error);                        // очистка потока: приём имеющихся данных' но не более InBufLenght                      if (netStream.DataAvailable)                          netStream.Read(inBuf' 0' inBuf.Length);                  }              }              catch (Exception ex)              {                  appLog.WriteAction(string.Format(Localization.UseRussian ?                       "Ошибка при приёме и обработке данных от клиента {0}: {1}" :                      "Error receiving and processing data from the client {0}: {1}"'                      client.Address' ex.Message)' Log.ActTypes.Exception);              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ReceiveData,The following statement contains a magic number: try              {                  // приём длины данных и номера команды                  NetworkStream netStream = client.NetStream;                  bool formatError = true;                  int bytesRead = netStream.Read(inBuf' 0' 3);                    if (bytesRead == 3)                  {                      int cmdLen = (int)BitConverter.ToUInt16(inBuf' 0);                      byte cmd = inBuf[2];                        if (cmdLen <= InBufLenght)                      {                          // приём оставшейся части данных                          int dataLen = cmdLen - 3;                          bytesRead = dataLen > 0 ? ReadNetStream(netStream' inBuf' 3' dataLen) : 0;                            if (bytesRead == dataLen)                          {                              formatError = false;                                                            if (settings.DetailedLog ||                                   cmd == 0x06 /*команда ТУ*/ || cmd == 0x0E /*квитирование события*/)                                  appLog.WriteAction(string.Format(Localization.UseRussian ?                                       "Получена команда {0} от клиента {1}" :                                       "Command {0} is received from the client {1}"'                                      CmdDescrs[cmd]' client.Address)' Log.ActTypes.Action);                                // обработка команды                              ProcCommCommand(client' cmd' cmdLen);                          }                      }                  }                    if (formatError)                  {                      appLog.WriteAction(string.Format(Localization.UseRussian ?                           "Некорректный формат полученных данных от клиента {1}" :                           "Incorrect format of the data received from the client {0}"'                           client.Address)' Log.ActTypes.Error);                        // очистка потока: приём имеющихся данных' но не более InBufLenght                      if (netStream.DataAvailable)                          netStream.Read(inBuf' 0' inBuf.Length);                  }              }              catch (Exception ex)              {                  appLog.WriteAction(string.Format(Localization.UseRussian ?                       "Ошибка при приёме и обработке данных от клиента {0}: {1}" :                      "Error receiving and processing data from the client {0}: {1}"'                      client.Address' ex.Message)' Log.ActTypes.Exception);              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ReceiveData,The following statement contains a magic number: try              {                  // приём длины данных и номера команды                  NetworkStream netStream = client.NetStream;                  bool formatError = true;                  int bytesRead = netStream.Read(inBuf' 0' 3);                    if (bytesRead == 3)                  {                      int cmdLen = (int)BitConverter.ToUInt16(inBuf' 0);                      byte cmd = inBuf[2];                        if (cmdLen <= InBufLenght)                      {                          // приём оставшейся части данных                          int dataLen = cmdLen - 3;                          bytesRead = dataLen > 0 ? ReadNetStream(netStream' inBuf' 3' dataLen) : 0;                            if (bytesRead == dataLen)                          {                              formatError = false;                                                            if (settings.DetailedLog ||                                   cmd == 0x06 /*команда ТУ*/ || cmd == 0x0E /*квитирование события*/)                                  appLog.WriteAction(string.Format(Localization.UseRussian ?                                       "Получена команда {0} от клиента {1}" :                                       "Command {0} is received from the client {1}"'                                      CmdDescrs[cmd]' client.Address)' Log.ActTypes.Action);                                // обработка команды                              ProcCommCommand(client' cmd' cmdLen);                          }                      }                  }                    if (formatError)                  {                      appLog.WriteAction(string.Format(Localization.UseRussian ?                           "Некорректный формат полученных данных от клиента {1}" :                           "Incorrect format of the data received from the client {0}"'                           client.Address)' Log.ActTypes.Error);                        // очистка потока: приём имеющихся данных' но не более InBufLenght                      if (netStream.DataAvailable)                          netStream.Read(inBuf' 0' inBuf.Length);                  }              }              catch (Exception ex)              {                  appLog.WriteAction(string.Format(Localization.UseRussian ?                       "Ошибка при приёме и обработке данных от клиента {0}: {1}" :                      "Error receiving and processing data from the client {0}: {1}"'                      client.Address' ex.Message)' Log.ActTypes.Exception);              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: if (sendResp)              {                  if (cmd == 0x0D)                  {                      int respLen = 5 + respDataLen;                      Array.Copy(BitConverter.GetBytes((uint)respLen)' 0' outBuf' 0' 4);                      outBuf[4] = cmd;                      client.NetStream.Write(outBuf' 0' 7);                  }                  else                  {                      int respLen = 3 + respDataLen;                      Array.Copy(BitConverter.GetBytes((ushort)respLen)' 0' outBuf' 0' 2);                      outBuf[2] = cmd;                      client.NetStream.Write(outBuf' 0' respLen);                  }                    if (extraData != null && extraData.Length > 0)                      client.NetStream.Write(extraData' 0' extraData.Length);              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: if (sendResp)              {                  if (cmd == 0x0D)                  {                      int respLen = 5 + respDataLen;                      Array.Copy(BitConverter.GetBytes((uint)respLen)' 0' outBuf' 0' 4);                      outBuf[4] = cmd;                      client.NetStream.Write(outBuf' 0' 7);                  }                  else                  {                      int respLen = 3 + respDataLen;                      Array.Copy(BitConverter.GetBytes((ushort)respLen)' 0' outBuf' 0' 2);                      outBuf[2] = cmd;                      client.NetStream.Write(outBuf' 0' respLen);                  }                    if (extraData != null && extraData.Length > 0)                      client.NetStream.Write(extraData' 0' extraData.Length);              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: if (sendResp)              {                  if (cmd == 0x0D)                  {                      int respLen = 5 + respDataLen;                      Array.Copy(BitConverter.GetBytes((uint)respLen)' 0' outBuf' 0' 4);                      outBuf[4] = cmd;                      client.NetStream.Write(outBuf' 0' 7);                  }                  else                  {                      int respLen = 3 + respDataLen;                      Array.Copy(BitConverter.GetBytes((ushort)respLen)' 0' outBuf' 0' 2);                      outBuf[2] = cmd;                      client.NetStream.Write(outBuf' 0' respLen);                  }                    if (extraData != null && extraData.Length > 0)                      client.NetStream.Write(extraData' 0' extraData.Length);              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: if (sendResp)              {                  if (cmd == 0x0D)                  {                      int respLen = 5 + respDataLen;                      Array.Copy(BitConverter.GetBytes((uint)respLen)' 0' outBuf' 0' 4);                      outBuf[4] = cmd;                      client.NetStream.Write(outBuf' 0' 7);                  }                  else                  {                      int respLen = 3 + respDataLen;                      Array.Copy(BitConverter.GetBytes((ushort)respLen)' 0' outBuf' 0' 2);                      outBuf[2] = cmd;                      client.NetStream.Write(outBuf' 0' respLen);                  }                    if (extraData != null && extraData.Length > 0)                      client.NetStream.Write(extraData' 0' extraData.Length);              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: if (sendResp)              {                  if (cmd == 0x0D)                  {                      int respLen = 5 + respDataLen;                      Array.Copy(BitConverter.GetBytes((uint)respLen)' 0' outBuf' 0' 4);                      outBuf[4] = cmd;                      client.NetStream.Write(outBuf' 0' 7);                  }                  else                  {                      int respLen = 3 + respDataLen;                      Array.Copy(BitConverter.GetBytes((ushort)respLen)' 0' outBuf' 0' 2);                      outBuf[2] = cmd;                      client.NetStream.Write(outBuf' 0' respLen);                  }                    if (extraData != null && extraData.Length > 0)                      client.NetStream.Write(extraData' 0' extraData.Length);              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: if (sendResp)              {                  if (cmd == 0x0D)                  {                      int respLen = 5 + respDataLen;                      Array.Copy(BitConverter.GetBytes((uint)respLen)' 0' outBuf' 0' 4);                      outBuf[4] = cmd;                      client.NetStream.Write(outBuf' 0' 7);                  }                  else                  {                      int respLen = 3 + respDataLen;                      Array.Copy(BitConverter.GetBytes((ushort)respLen)' 0' outBuf' 0' 2);                      outBuf[2] = cmd;                      client.NetStream.Write(outBuf' 0' respLen);                  }                    if (extraData != null && extraData.Length > 0)                      client.NetStream.Write(extraData' 0' extraData.Length);              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following statement contains a magic number: if (sendResp)              {                  if (cmd == 0x0D)                  {                      int respLen = 5 + respDataLen;                      Array.Copy(BitConverter.GetBytes((uint)respLen)' 0' outBuf' 0' 4);                      outBuf[4] = cmd;                      client.NetStream.Write(outBuf' 0' 7);                  }                  else                  {                      int respLen = 3 + respDataLen;                      Array.Copy(BitConverter.GetBytes((ushort)respLen)' 0' outBuf' 0' 2);                      outBuf[2] = cmd;                      client.NetStream.Write(outBuf' 0' respLen);                  }                    if (extraData != null && extraData.Length > 0)                      client.NetStream.Write(extraData' 0' extraData.Length);              }
Magic Number,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,FillCommandProps,The following statement contains a magic number: if (cmdTypeID == BaseValues.CmdTypes.Standard || cmdTypeID == BaseValues.CmdTypes.Binary)              {                  cmd.KPNum = (ushort)ctrlCnl.KPNum;                  cmd.CmdNum = (ushort)ctrlCnl.CmdNum;                    if (cmdTypeID == BaseValues.CmdTypes.Standard && cmd.CmdData != null && cmd.CmdData.Length == 8)                      cmd.CmdVal = BitConverter.ToDouble(cmd.CmdData' 0);              }              else if (cmdTypeID == BaseValues.CmdTypes.Request)              {                  cmd.KPNum = (ushort)ctrlCnl.KPNum;              }
Magic Number,Scada.Server.Svc,MainLogic,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\MainLogic.cs,Execute,The following statement contains a magic number: try              {                  // запись информации о работе приложения                  workState = WorkStateNames.Normal;                  WriteInfo();                    // выполнение действий модулей                  RaiseOnServerStart();                    // инициализация адаптеров таблиц текущего среза и событий                  curSrezAdapter = new SrezAdapter();                  curSrezCopyAdapter = new SrezAdapter();                  eventAdapter = new EventAdapter();                  eventCopyAdapter = new EventAdapter();                  curSrezAdapter.FileName = ServerUtils.BuildCurFileName(Settings.ArcDir);                  curSrezCopyAdapter.FileName = ServerUtils.BuildCurFileName(Settings.ArcCopyDir);                  eventAdapter.Directory = Settings.ArcDir + "Events" + Path.DirectorySeparatorChar;                  eventCopyAdapter.Directory = Settings.ArcCopyDir + "Events" + Path.DirectorySeparatorChar;                    // инициализация кэша таблиц минутных и часовых срезов                  minSrezTableCache = new SortedList<DateTime' SrezTableCache>();                  hrSrezTableCache = new SortedList<DateTime' SrezTableCache>();                    // инициализация описания создаваемых срезов                  int cnlCnt = inCnls.Count;                  srezDescr = new SrezTable.SrezDescr(cnlCnt);                  for (int i = 0; i < cnlCnt; i++)                      srezDescr.CnlNums[i] = inCnls.Values[i].CnlNum;                                  srezDescr.CalcCS();                    // загрузка исходного текущего среза из файла                  SrezTableLight.Srez curSrezSrc = null;                  SrezTableLight tblCurSrezScr = new SrezTableLight();                    try                  {                      if (File.Exists(curSrezAdapter.FileName))                      {                          curSrezAdapter.Fill(tblCurSrezScr);                          if (tblCurSrezScr.SrezList.Count > 0)                              curSrezSrc = tblCurSrezScr.SrezList.Values[0];                      }                        if (curSrezSrc == null)                          AppLog.WriteAction(Localization.UseRussian ? "Текущий срез не загружен" :                              "Current data are not loaded"' Log.ActTypes.Action);                      else                          AppLog.WriteAction(Localization.UseRussian ? "Текущий срез загружен" :                              "Current data are loaded"' Log.ActTypes.Action);                  }                  catch (Exception ex)                  {                      AppLog.WriteAction((Localization.UseRussian ? "Ошибка при загрузке текущего среза: " :                           "Error loading current data: ") + ex.Message' Log.ActTypes.Exception);                  }                    // инициализация текущего среза' предназначенного для формироваться данных сервера                  curSrez = new SrezTable.Srez(DateTime.MinValue' srezDescr' curSrezSrc);                    // инициализация данных для усреднения и времени активности каналов                  minAvgData = new AvgData[cnlCnt];                  hrAvgData = new AvgData[cnlCnt];                  activeDTs = new DateTime[cnlCnt];                  DateTime nowDT = DateTime.Now;                    for (int i = 0; i < cnlCnt; i++)                  {                      minAvgData[i] = new AvgData() { Sum = 0.0' Cnt = 0 };                      hrAvgData[i] = new AvgData() { Sum = 0.0' Cnt = 0 };                      activeDTs[i] = nowDT;                  }                    // цикл работы сервера                  nowDT = DateTime.MaxValue;                  DateTime today;                  DateTime prevDT;                  DateTime writeCurSrezDT = DateTime.MinValue;                  DateTime writeMinSrezDT = DateTime.MinValue;                  DateTime writeHrSrezDT = DateTime.MinValue;                  DateTime calcMinDT = DateTime.MinValue;                  DateTime calcHrDT = DateTime.MinValue;                  DateTime clearCacheDT = nowDT;                    bool calcDR = drCnls.Count > 0;                  bool writeCur = Settings.WriteCur || Settings.WriteCurCopy;                  bool writeCurOnMod = Settings.WriteCurPer <= 0;                  bool writeMin = (Settings.WriteMin || Settings.WriteMinCopy) && Settings.WriteMinPer > 0;                  bool writeHr = (Settings.WriteHr || Settings.WriteHrCopy) && Settings.WriteHrPer > 0;                    curSrezMod = false;                  serverIsReady = true;                    while (!terminated)                  {                      prevDT = nowDT;                      nowDT = DateTime.Now;                      today = nowDT.Date;                        // расчёт времени записи срезов и вычисления значений дорасчётных каналов                      // при переводе времени назад или при первом проходе цикла                      if (prevDT > nowDT)                      {                          writeCurSrezDT = nowDT;                          writeMinSrezDT = CalcNextTime(nowDT' Settings.WriteMinPer);                          writeHrSrezDT = CalcNextTime(nowDT' Settings.WriteHrPer);                          calcMinDT = drmCnls.Count > 0 ? CalcNextTime(nowDT' 60) : DateTime.MaxValue;                          calcHrDT = drhCnls.Count > 0 ? CalcNextTime(nowDT' 3600) : DateTime.MaxValue;                      }                        // удаление устаревших файлов срезов и событий при изменении даты или при первом проходе цикла                      if (prevDT.Date != today)                      {                          ClearArchive(Settings.ArcDir + "Min"' "m*.dat"' today.AddDays(-Settings.StoreMinPer));                          ClearArchive(Settings.ArcDir + "Hour"' "h*.dat"' today.AddDays(-Settings.StoreHrPer));                          ClearArchive(Settings.ArcDir + "Events"' "e*.dat"' today.AddDays(-Settings.StoreEvPer));                          ClearArchive(Settings.ArcCopyDir + "Min"' "m*.dat"' today.AddDays(-Settings.StoreMinPer));                          ClearArchive(Settings.ArcCopyDir + "Hour"' "h*.dat"' today.AddDays(-Settings.StoreHrPer));                          ClearArchive(Settings.ArcCopyDir + "Events"' "e*.dat"' today.AddDays(-Settings.StoreEvPer));                      }                        bool calcMinDR = calcMinDT <= nowDT; // необходимо вычислить минутные каналы                      bool calcHrDR = calcHrDT <= nowDT;   // необходимо вычислить часовые каналы                        lock (curSrez)                      {                          // установка недостоверности неактивных каналов                          SetUnreliable();                            // вычисление дорасчётных каналов                          if (calcDR)                          {                              CalcDRCnls(drCnls' curSrez' true);                          }                            // вычисление минутных каналов                          if (calcMinDR)                          {                              CalcDRCnls(drmCnls' curSrez' true);                              calcMinDT = CalcNextTime(nowDT' 60);                              curSrezMod = true;                          }                            // вычисление часовых каналов                          if (calcHrDR)                          {                              CalcDRCnls(drhCnls' curSrez' true);                              calcHrDT = CalcNextTime(nowDT' 3600);                              curSrezMod = true;                          }                      }                        // выполнение действий модулей без блокировки текущего среза                      if (calcDR)                          RaiseOnCurDataCalculated(drCnlNums' curSrez);                        if (calcMinDR)                          RaiseOnCurDataCalculated(drmCnlNums' curSrez);                        if (calcHrDR)                          RaiseOnCurDataCalculated(drhCnlNums' curSrez);                        // запись срезов                      lock (curSrez)                      {                          // запись текущего среза                          if ((writeCurSrezDT <= nowDT || writeCurOnMod && curSrezMod) && writeCur)                          {                              if (writeCurOnMod)                              {                                  WriteSrez(SnapshotTypes.Cur' nowDT);                                  curSrezMod = false;                                  writeCurSrezDT = DateTime.MaxValue;                              }                              else                              {                                  WriteSrez(SnapshotTypes.Cur' writeCurSrezDT);                                  writeCurSrezDT = CalcNextTime(nowDT' Settings.WriteCurPer);                              }                          }                            // запись минутного среза                          if (writeMinSrezDT <= nowDT && writeMin)                          {                              WriteSrez(SnapshotTypes.Min' writeMinSrezDT);                              writeMinSrezDT = CalcNextTime(nowDT' Settings.WriteMinPer);                          }                            // запись часового среза                          if (writeHrSrezDT <= nowDT && writeHr)                          {                              WriteSrez(SnapshotTypes.Hour' writeHrSrezDT);                              writeHrSrezDT = CalcNextTime(nowDT' Settings.WriteHrPer);                          }                      }                        // очистка устаревших данных кэша                      if (nowDT - clearCacheDT > CacheClearSpan || nowDT < clearCacheDT /*время переведено назад*/)                      {                          clearCacheDT = nowDT;                          ClearSrezTableCache(minSrezTableCache' MinCacheStorePer' MinCacheCapacity);                          ClearSrezTableCache(hrSrezTableCache' HourCacheStorePer' HourCacheCapacity);                      }                        // запись информации о работе приложения                      WriteInfo();                        // задержка для экономиии ресурсов процессора                      Thread.Sleep(100);                  }              }              finally              {                  // выполнение действий модулей                  RaiseOnServerStop();                    // запись информации о работе приложения                  workState = WorkStateNames.Stopped;                  WriteInfo();              }
Magic Number,Scada.Server.Svc,MainLogic,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\MainLogic.cs,Execute,The following statement contains a magic number: try              {                  // запись информации о работе приложения                  workState = WorkStateNames.Normal;                  WriteInfo();                    // выполнение действий модулей                  RaiseOnServerStart();                    // инициализация адаптеров таблиц текущего среза и событий                  curSrezAdapter = new SrezAdapter();                  curSrezCopyAdapter = new SrezAdapter();                  eventAdapter = new EventAdapter();                  eventCopyAdapter = new EventAdapter();                  curSrezAdapter.FileName = ServerUtils.BuildCurFileName(Settings.ArcDir);                  curSrezCopyAdapter.FileName = ServerUtils.BuildCurFileName(Settings.ArcCopyDir);                  eventAdapter.Directory = Settings.ArcDir + "Events" + Path.DirectorySeparatorChar;                  eventCopyAdapter.Directory = Settings.ArcCopyDir + "Events" + Path.DirectorySeparatorChar;                    // инициализация кэша таблиц минутных и часовых срезов                  minSrezTableCache = new SortedList<DateTime' SrezTableCache>();                  hrSrezTableCache = new SortedList<DateTime' SrezTableCache>();                    // инициализация описания создаваемых срезов                  int cnlCnt = inCnls.Count;                  srezDescr = new SrezTable.SrezDescr(cnlCnt);                  for (int i = 0; i < cnlCnt; i++)                      srezDescr.CnlNums[i] = inCnls.Values[i].CnlNum;                                  srezDescr.CalcCS();                    // загрузка исходного текущего среза из файла                  SrezTableLight.Srez curSrezSrc = null;                  SrezTableLight tblCurSrezScr = new SrezTableLight();                    try                  {                      if (File.Exists(curSrezAdapter.FileName))                      {                          curSrezAdapter.Fill(tblCurSrezScr);                          if (tblCurSrezScr.SrezList.Count > 0)                              curSrezSrc = tblCurSrezScr.SrezList.Values[0];                      }                        if (curSrezSrc == null)                          AppLog.WriteAction(Localization.UseRussian ? "Текущий срез не загружен" :                              "Current data are not loaded"' Log.ActTypes.Action);                      else                          AppLog.WriteAction(Localization.UseRussian ? "Текущий срез загружен" :                              "Current data are loaded"' Log.ActTypes.Action);                  }                  catch (Exception ex)                  {                      AppLog.WriteAction((Localization.UseRussian ? "Ошибка при загрузке текущего среза: " :                           "Error loading current data: ") + ex.Message' Log.ActTypes.Exception);                  }                    // инициализация текущего среза' предназначенного для формироваться данных сервера                  curSrez = new SrezTable.Srez(DateTime.MinValue' srezDescr' curSrezSrc);                    // инициализация данных для усреднения и времени активности каналов                  minAvgData = new AvgData[cnlCnt];                  hrAvgData = new AvgData[cnlCnt];                  activeDTs = new DateTime[cnlCnt];                  DateTime nowDT = DateTime.Now;                    for (int i = 0; i < cnlCnt; i++)                  {                      minAvgData[i] = new AvgData() { Sum = 0.0' Cnt = 0 };                      hrAvgData[i] = new AvgData() { Sum = 0.0' Cnt = 0 };                      activeDTs[i] = nowDT;                  }                    // цикл работы сервера                  nowDT = DateTime.MaxValue;                  DateTime today;                  DateTime prevDT;                  DateTime writeCurSrezDT = DateTime.MinValue;                  DateTime writeMinSrezDT = DateTime.MinValue;                  DateTime writeHrSrezDT = DateTime.MinValue;                  DateTime calcMinDT = DateTime.MinValue;                  DateTime calcHrDT = DateTime.MinValue;                  DateTime clearCacheDT = nowDT;                    bool calcDR = drCnls.Count > 0;                  bool writeCur = Settings.WriteCur || Settings.WriteCurCopy;                  bool writeCurOnMod = Settings.WriteCurPer <= 0;                  bool writeMin = (Settings.WriteMin || Settings.WriteMinCopy) && Settings.WriteMinPer > 0;                  bool writeHr = (Settings.WriteHr || Settings.WriteHrCopy) && Settings.WriteHrPer > 0;                    curSrezMod = false;                  serverIsReady = true;                    while (!terminated)                  {                      prevDT = nowDT;                      nowDT = DateTime.Now;                      today = nowDT.Date;                        // расчёт времени записи срезов и вычисления значений дорасчётных каналов                      // при переводе времени назад или при первом проходе цикла                      if (prevDT > nowDT)                      {                          writeCurSrezDT = nowDT;                          writeMinSrezDT = CalcNextTime(nowDT' Settings.WriteMinPer);                          writeHrSrezDT = CalcNextTime(nowDT' Settings.WriteHrPer);                          calcMinDT = drmCnls.Count > 0 ? CalcNextTime(nowDT' 60) : DateTime.MaxValue;                          calcHrDT = drhCnls.Count > 0 ? CalcNextTime(nowDT' 3600) : DateTime.MaxValue;                      }                        // удаление устаревших файлов срезов и событий при изменении даты или при первом проходе цикла                      if (prevDT.Date != today)                      {                          ClearArchive(Settings.ArcDir + "Min"' "m*.dat"' today.AddDays(-Settings.StoreMinPer));                          ClearArchive(Settings.ArcDir + "Hour"' "h*.dat"' today.AddDays(-Settings.StoreHrPer));                          ClearArchive(Settings.ArcDir + "Events"' "e*.dat"' today.AddDays(-Settings.StoreEvPer));                          ClearArchive(Settings.ArcCopyDir + "Min"' "m*.dat"' today.AddDays(-Settings.StoreMinPer));                          ClearArchive(Settings.ArcCopyDir + "Hour"' "h*.dat"' today.AddDays(-Settings.StoreHrPer));                          ClearArchive(Settings.ArcCopyDir + "Events"' "e*.dat"' today.AddDays(-Settings.StoreEvPer));                      }                        bool calcMinDR = calcMinDT <= nowDT; // необходимо вычислить минутные каналы                      bool calcHrDR = calcHrDT <= nowDT;   // необходимо вычислить часовые каналы                        lock (curSrez)                      {                          // установка недостоверности неактивных каналов                          SetUnreliable();                            // вычисление дорасчётных каналов                          if (calcDR)                          {                              CalcDRCnls(drCnls' curSrez' true);                          }                            // вычисление минутных каналов                          if (calcMinDR)                          {                              CalcDRCnls(drmCnls' curSrez' true);                              calcMinDT = CalcNextTime(nowDT' 60);                              curSrezMod = true;                          }                            // вычисление часовых каналов                          if (calcHrDR)                          {                              CalcDRCnls(drhCnls' curSrez' true);                              calcHrDT = CalcNextTime(nowDT' 3600);                              curSrezMod = true;                          }                      }                        // выполнение действий модулей без блокировки текущего среза                      if (calcDR)                          RaiseOnCurDataCalculated(drCnlNums' curSrez);                        if (calcMinDR)                          RaiseOnCurDataCalculated(drmCnlNums' curSrez);                        if (calcHrDR)                          RaiseOnCurDataCalculated(drhCnlNums' curSrez);                        // запись срезов                      lock (curSrez)                      {                          // запись текущего среза                          if ((writeCurSrezDT <= nowDT || writeCurOnMod && curSrezMod) && writeCur)                          {                              if (writeCurOnMod)                              {                                  WriteSrez(SnapshotTypes.Cur' nowDT);                                  curSrezMod = false;                                  writeCurSrezDT = DateTime.MaxValue;                              }                              else                              {                                  WriteSrez(SnapshotTypes.Cur' writeCurSrezDT);                                  writeCurSrezDT = CalcNextTime(nowDT' Settings.WriteCurPer);                              }                          }                            // запись минутного среза                          if (writeMinSrezDT <= nowDT && writeMin)                          {                              WriteSrez(SnapshotTypes.Min' writeMinSrezDT);                              writeMinSrezDT = CalcNextTime(nowDT' Settings.WriteMinPer);                          }                            // запись часового среза                          if (writeHrSrezDT <= nowDT && writeHr)                          {                              WriteSrez(SnapshotTypes.Hour' writeHrSrezDT);                              writeHrSrezDT = CalcNextTime(nowDT' Settings.WriteHrPer);                          }                      }                        // очистка устаревших данных кэша                      if (nowDT - clearCacheDT > CacheClearSpan || nowDT < clearCacheDT /*время переведено назад*/)                      {                          clearCacheDT = nowDT;                          ClearSrezTableCache(minSrezTableCache' MinCacheStorePer' MinCacheCapacity);                          ClearSrezTableCache(hrSrezTableCache' HourCacheStorePer' HourCacheCapacity);                      }                        // запись информации о работе приложения                      WriteInfo();                        // задержка для экономиии ресурсов процессора                      Thread.Sleep(100);                  }              }              finally              {                  // выполнение действий модулей                  RaiseOnServerStop();                    // запись информации о работе приложения                  workState = WorkStateNames.Stopped;                  WriteInfo();              }
Magic Number,Scada.Server.Svc,MainLogic,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\MainLogic.cs,Execute,The following statement contains a magic number: try              {                  // запись информации о работе приложения                  workState = WorkStateNames.Normal;                  WriteInfo();                    // выполнение действий модулей                  RaiseOnServerStart();                    // инициализация адаптеров таблиц текущего среза и событий                  curSrezAdapter = new SrezAdapter();                  curSrezCopyAdapter = new SrezAdapter();                  eventAdapter = new EventAdapter();                  eventCopyAdapter = new EventAdapter();                  curSrezAdapter.FileName = ServerUtils.BuildCurFileName(Settings.ArcDir);                  curSrezCopyAdapter.FileName = ServerUtils.BuildCurFileName(Settings.ArcCopyDir);                  eventAdapter.Directory = Settings.ArcDir + "Events" + Path.DirectorySeparatorChar;                  eventCopyAdapter.Directory = Settings.ArcCopyDir + "Events" + Path.DirectorySeparatorChar;                    // инициализация кэша таблиц минутных и часовых срезов                  minSrezTableCache = new SortedList<DateTime' SrezTableCache>();                  hrSrezTableCache = new SortedList<DateTime' SrezTableCache>();                    // инициализация описания создаваемых срезов                  int cnlCnt = inCnls.Count;                  srezDescr = new SrezTable.SrezDescr(cnlCnt);                  for (int i = 0; i < cnlCnt; i++)                      srezDescr.CnlNums[i] = inCnls.Values[i].CnlNum;                                  srezDescr.CalcCS();                    // загрузка исходного текущего среза из файла                  SrezTableLight.Srez curSrezSrc = null;                  SrezTableLight tblCurSrezScr = new SrezTableLight();                    try                  {                      if (File.Exists(curSrezAdapter.FileName))                      {                          curSrezAdapter.Fill(tblCurSrezScr);                          if (tblCurSrezScr.SrezList.Count > 0)                              curSrezSrc = tblCurSrezScr.SrezList.Values[0];                      }                        if (curSrezSrc == null)                          AppLog.WriteAction(Localization.UseRussian ? "Текущий срез не загружен" :                              "Current data are not loaded"' Log.ActTypes.Action);                      else                          AppLog.WriteAction(Localization.UseRussian ? "Текущий срез загружен" :                              "Current data are loaded"' Log.ActTypes.Action);                  }                  catch (Exception ex)                  {                      AppLog.WriteAction((Localization.UseRussian ? "Ошибка при загрузке текущего среза: " :                           "Error loading current data: ") + ex.Message' Log.ActTypes.Exception);                  }                    // инициализация текущего среза' предназначенного для формироваться данных сервера                  curSrez = new SrezTable.Srez(DateTime.MinValue' srezDescr' curSrezSrc);                    // инициализация данных для усреднения и времени активности каналов                  minAvgData = new AvgData[cnlCnt];                  hrAvgData = new AvgData[cnlCnt];                  activeDTs = new DateTime[cnlCnt];                  DateTime nowDT = DateTime.Now;                    for (int i = 0; i < cnlCnt; i++)                  {                      minAvgData[i] = new AvgData() { Sum = 0.0' Cnt = 0 };                      hrAvgData[i] = new AvgData() { Sum = 0.0' Cnt = 0 };                      activeDTs[i] = nowDT;                  }                    // цикл работы сервера                  nowDT = DateTime.MaxValue;                  DateTime today;                  DateTime prevDT;                  DateTime writeCurSrezDT = DateTime.MinValue;                  DateTime writeMinSrezDT = DateTime.MinValue;                  DateTime writeHrSrezDT = DateTime.MinValue;                  DateTime calcMinDT = DateTime.MinValue;                  DateTime calcHrDT = DateTime.MinValue;                  DateTime clearCacheDT = nowDT;                    bool calcDR = drCnls.Count > 0;                  bool writeCur = Settings.WriteCur || Settings.WriteCurCopy;                  bool writeCurOnMod = Settings.WriteCurPer <= 0;                  bool writeMin = (Settings.WriteMin || Settings.WriteMinCopy) && Settings.WriteMinPer > 0;                  bool writeHr = (Settings.WriteHr || Settings.WriteHrCopy) && Settings.WriteHrPer > 0;                    curSrezMod = false;                  serverIsReady = true;                    while (!terminated)                  {                      prevDT = nowDT;                      nowDT = DateTime.Now;                      today = nowDT.Date;                        // расчёт времени записи срезов и вычисления значений дорасчётных каналов                      // при переводе времени назад или при первом проходе цикла                      if (prevDT > nowDT)                      {                          writeCurSrezDT = nowDT;                          writeMinSrezDT = CalcNextTime(nowDT' Settings.WriteMinPer);                          writeHrSrezDT = CalcNextTime(nowDT' Settings.WriteHrPer);                          calcMinDT = drmCnls.Count > 0 ? CalcNextTime(nowDT' 60) : DateTime.MaxValue;                          calcHrDT = drhCnls.Count > 0 ? CalcNextTime(nowDT' 3600) : DateTime.MaxValue;                      }                        // удаление устаревших файлов срезов и событий при изменении даты или при первом проходе цикла                      if (prevDT.Date != today)                      {                          ClearArchive(Settings.ArcDir + "Min"' "m*.dat"' today.AddDays(-Settings.StoreMinPer));                          ClearArchive(Settings.ArcDir + "Hour"' "h*.dat"' today.AddDays(-Settings.StoreHrPer));                          ClearArchive(Settings.ArcDir + "Events"' "e*.dat"' today.AddDays(-Settings.StoreEvPer));                          ClearArchive(Settings.ArcCopyDir + "Min"' "m*.dat"' today.AddDays(-Settings.StoreMinPer));                          ClearArchive(Settings.ArcCopyDir + "Hour"' "h*.dat"' today.AddDays(-Settings.StoreHrPer));                          ClearArchive(Settings.ArcCopyDir + "Events"' "e*.dat"' today.AddDays(-Settings.StoreEvPer));                      }                        bool calcMinDR = calcMinDT <= nowDT; // необходимо вычислить минутные каналы                      bool calcHrDR = calcHrDT <= nowDT;   // необходимо вычислить часовые каналы                        lock (curSrez)                      {                          // установка недостоверности неактивных каналов                          SetUnreliable();                            // вычисление дорасчётных каналов                          if (calcDR)                          {                              CalcDRCnls(drCnls' curSrez' true);                          }                            // вычисление минутных каналов                          if (calcMinDR)                          {                              CalcDRCnls(drmCnls' curSrez' true);                              calcMinDT = CalcNextTime(nowDT' 60);                              curSrezMod = true;                          }                            // вычисление часовых каналов                          if (calcHrDR)                          {                              CalcDRCnls(drhCnls' curSrez' true);                              calcHrDT = CalcNextTime(nowDT' 3600);                              curSrezMod = true;                          }                      }                        // выполнение действий модулей без блокировки текущего среза                      if (calcDR)                          RaiseOnCurDataCalculated(drCnlNums' curSrez);                        if (calcMinDR)                          RaiseOnCurDataCalculated(drmCnlNums' curSrez);                        if (calcHrDR)                          RaiseOnCurDataCalculated(drhCnlNums' curSrez);                        // запись срезов                      lock (curSrez)                      {                          // запись текущего среза                          if ((writeCurSrezDT <= nowDT || writeCurOnMod && curSrezMod) && writeCur)                          {                              if (writeCurOnMod)                              {                                  WriteSrez(SnapshotTypes.Cur' nowDT);                                  curSrezMod = false;                                  writeCurSrezDT = DateTime.MaxValue;                              }                              else                              {                                  WriteSrez(SnapshotTypes.Cur' writeCurSrezDT);                                  writeCurSrezDT = CalcNextTime(nowDT' Settings.WriteCurPer);                              }                          }                            // запись минутного среза                          if (writeMinSrezDT <= nowDT && writeMin)                          {                              WriteSrez(SnapshotTypes.Min' writeMinSrezDT);                              writeMinSrezDT = CalcNextTime(nowDT' Settings.WriteMinPer);                          }                            // запись часового среза                          if (writeHrSrezDT <= nowDT && writeHr)                          {                              WriteSrez(SnapshotTypes.Hour' writeHrSrezDT);                              writeHrSrezDT = CalcNextTime(nowDT' Settings.WriteHrPer);                          }                      }                        // очистка устаревших данных кэша                      if (nowDT - clearCacheDT > CacheClearSpan || nowDT < clearCacheDT /*время переведено назад*/)                      {                          clearCacheDT = nowDT;                          ClearSrezTableCache(minSrezTableCache' MinCacheStorePer' MinCacheCapacity);                          ClearSrezTableCache(hrSrezTableCache' HourCacheStorePer' HourCacheCapacity);                      }                        // запись информации о работе приложения                      WriteInfo();                        // задержка для экономиии ресурсов процессора                      Thread.Sleep(100);                  }              }              finally              {                  // выполнение действий модулей                  RaiseOnServerStop();                    // запись информации о работе приложения                  workState = WorkStateNames.Stopped;                  WriteInfo();              }
Magic Number,Scada.Server.Svc,MainLogic,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\MainLogic.cs,Execute,The following statement contains a magic number: try              {                  // запись информации о работе приложения                  workState = WorkStateNames.Normal;                  WriteInfo();                    // выполнение действий модулей                  RaiseOnServerStart();                    // инициализация адаптеров таблиц текущего среза и событий                  curSrezAdapter = new SrezAdapter();                  curSrezCopyAdapter = new SrezAdapter();                  eventAdapter = new EventAdapter();                  eventCopyAdapter = new EventAdapter();                  curSrezAdapter.FileName = ServerUtils.BuildCurFileName(Settings.ArcDir);                  curSrezCopyAdapter.FileName = ServerUtils.BuildCurFileName(Settings.ArcCopyDir);                  eventAdapter.Directory = Settings.ArcDir + "Events" + Path.DirectorySeparatorChar;                  eventCopyAdapter.Directory = Settings.ArcCopyDir + "Events" + Path.DirectorySeparatorChar;                    // инициализация кэша таблиц минутных и часовых срезов                  minSrezTableCache = new SortedList<DateTime' SrezTableCache>();                  hrSrezTableCache = new SortedList<DateTime' SrezTableCache>();                    // инициализация описания создаваемых срезов                  int cnlCnt = inCnls.Count;                  srezDescr = new SrezTable.SrezDescr(cnlCnt);                  for (int i = 0; i < cnlCnt; i++)                      srezDescr.CnlNums[i] = inCnls.Values[i].CnlNum;                                  srezDescr.CalcCS();                    // загрузка исходного текущего среза из файла                  SrezTableLight.Srez curSrezSrc = null;                  SrezTableLight tblCurSrezScr = new SrezTableLight();                    try                  {                      if (File.Exists(curSrezAdapter.FileName))                      {                          curSrezAdapter.Fill(tblCurSrezScr);                          if (tblCurSrezScr.SrezList.Count > 0)                              curSrezSrc = tblCurSrezScr.SrezList.Values[0];                      }                        if (curSrezSrc == null)                          AppLog.WriteAction(Localization.UseRussian ? "Текущий срез не загружен" :                              "Current data are not loaded"' Log.ActTypes.Action);                      else                          AppLog.WriteAction(Localization.UseRussian ? "Текущий срез загружен" :                              "Current data are loaded"' Log.ActTypes.Action);                  }                  catch (Exception ex)                  {                      AppLog.WriteAction((Localization.UseRussian ? "Ошибка при загрузке текущего среза: " :                           "Error loading current data: ") + ex.Message' Log.ActTypes.Exception);                  }                    // инициализация текущего среза' предназначенного для формироваться данных сервера                  curSrez = new SrezTable.Srez(DateTime.MinValue' srezDescr' curSrezSrc);                    // инициализация данных для усреднения и времени активности каналов                  minAvgData = new AvgData[cnlCnt];                  hrAvgData = new AvgData[cnlCnt];                  activeDTs = new DateTime[cnlCnt];                  DateTime nowDT = DateTime.Now;                    for (int i = 0; i < cnlCnt; i++)                  {                      minAvgData[i] = new AvgData() { Sum = 0.0' Cnt = 0 };                      hrAvgData[i] = new AvgData() { Sum = 0.0' Cnt = 0 };                      activeDTs[i] = nowDT;                  }                    // цикл работы сервера                  nowDT = DateTime.MaxValue;                  DateTime today;                  DateTime prevDT;                  DateTime writeCurSrezDT = DateTime.MinValue;                  DateTime writeMinSrezDT = DateTime.MinValue;                  DateTime writeHrSrezDT = DateTime.MinValue;                  DateTime calcMinDT = DateTime.MinValue;                  DateTime calcHrDT = DateTime.MinValue;                  DateTime clearCacheDT = nowDT;                    bool calcDR = drCnls.Count > 0;                  bool writeCur = Settings.WriteCur || Settings.WriteCurCopy;                  bool writeCurOnMod = Settings.WriteCurPer <= 0;                  bool writeMin = (Settings.WriteMin || Settings.WriteMinCopy) && Settings.WriteMinPer > 0;                  bool writeHr = (Settings.WriteHr || Settings.WriteHrCopy) && Settings.WriteHrPer > 0;                    curSrezMod = false;                  serverIsReady = true;                    while (!terminated)                  {                      prevDT = nowDT;                      nowDT = DateTime.Now;                      today = nowDT.Date;                        // расчёт времени записи срезов и вычисления значений дорасчётных каналов                      // при переводе времени назад или при первом проходе цикла                      if (prevDT > nowDT)                      {                          writeCurSrezDT = nowDT;                          writeMinSrezDT = CalcNextTime(nowDT' Settings.WriteMinPer);                          writeHrSrezDT = CalcNextTime(nowDT' Settings.WriteHrPer);                          calcMinDT = drmCnls.Count > 0 ? CalcNextTime(nowDT' 60) : DateTime.MaxValue;                          calcHrDT = drhCnls.Count > 0 ? CalcNextTime(nowDT' 3600) : DateTime.MaxValue;                      }                        // удаление устаревших файлов срезов и событий при изменении даты или при первом проходе цикла                      if (prevDT.Date != today)                      {                          ClearArchive(Settings.ArcDir + "Min"' "m*.dat"' today.AddDays(-Settings.StoreMinPer));                          ClearArchive(Settings.ArcDir + "Hour"' "h*.dat"' today.AddDays(-Settings.StoreHrPer));                          ClearArchive(Settings.ArcDir + "Events"' "e*.dat"' today.AddDays(-Settings.StoreEvPer));                          ClearArchive(Settings.ArcCopyDir + "Min"' "m*.dat"' today.AddDays(-Settings.StoreMinPer));                          ClearArchive(Settings.ArcCopyDir + "Hour"' "h*.dat"' today.AddDays(-Settings.StoreHrPer));                          ClearArchive(Settings.ArcCopyDir + "Events"' "e*.dat"' today.AddDays(-Settings.StoreEvPer));                      }                        bool calcMinDR = calcMinDT <= nowDT; // необходимо вычислить минутные каналы                      bool calcHrDR = calcHrDT <= nowDT;   // необходимо вычислить часовые каналы                        lock (curSrez)                      {                          // установка недостоверности неактивных каналов                          SetUnreliable();                            // вычисление дорасчётных каналов                          if (calcDR)                          {                              CalcDRCnls(drCnls' curSrez' true);                          }                            // вычисление минутных каналов                          if (calcMinDR)                          {                              CalcDRCnls(drmCnls' curSrez' true);                              calcMinDT = CalcNextTime(nowDT' 60);                              curSrezMod = true;                          }                            // вычисление часовых каналов                          if (calcHrDR)                          {                              CalcDRCnls(drhCnls' curSrez' true);                              calcHrDT = CalcNextTime(nowDT' 3600);                              curSrezMod = true;                          }                      }                        // выполнение действий модулей без блокировки текущего среза                      if (calcDR)                          RaiseOnCurDataCalculated(drCnlNums' curSrez);                        if (calcMinDR)                          RaiseOnCurDataCalculated(drmCnlNums' curSrez);                        if (calcHrDR)                          RaiseOnCurDataCalculated(drhCnlNums' curSrez);                        // запись срезов                      lock (curSrez)                      {                          // запись текущего среза                          if ((writeCurSrezDT <= nowDT || writeCurOnMod && curSrezMod) && writeCur)                          {                              if (writeCurOnMod)                              {                                  WriteSrez(SnapshotTypes.Cur' nowDT);                                  curSrezMod = false;                                  writeCurSrezDT = DateTime.MaxValue;                              }                              else                              {                                  WriteSrez(SnapshotTypes.Cur' writeCurSrezDT);                                  writeCurSrezDT = CalcNextTime(nowDT' Settings.WriteCurPer);                              }                          }                            // запись минутного среза                          if (writeMinSrezDT <= nowDT && writeMin)                          {                              WriteSrez(SnapshotTypes.Min' writeMinSrezDT);                              writeMinSrezDT = CalcNextTime(nowDT' Settings.WriteMinPer);                          }                            // запись часового среза                          if (writeHrSrezDT <= nowDT && writeHr)                          {                              WriteSrez(SnapshotTypes.Hour' writeHrSrezDT);                              writeHrSrezDT = CalcNextTime(nowDT' Settings.WriteHrPer);                          }                      }                        // очистка устаревших данных кэша                      if (nowDT - clearCacheDT > CacheClearSpan || nowDT < clearCacheDT /*время переведено назад*/)                      {                          clearCacheDT = nowDT;                          ClearSrezTableCache(minSrezTableCache' MinCacheStorePer' MinCacheCapacity);                          ClearSrezTableCache(hrSrezTableCache' HourCacheStorePer' HourCacheCapacity);                      }                        // запись информации о работе приложения                      WriteInfo();                        // задержка для экономиии ресурсов процессора                      Thread.Sleep(100);                  }              }              finally              {                  // выполнение действий модулей                  RaiseOnServerStop();                    // запись информации о работе приложения                  workState = WorkStateNames.Stopped;                  WriteInfo();              }
Magic Number,Scada.Server.Svc,MainLogic,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\MainLogic.cs,Execute,The following statement contains a magic number: try              {                  // запись информации о работе приложения                  workState = WorkStateNames.Normal;                  WriteInfo();                    // выполнение действий модулей                  RaiseOnServerStart();                    // инициализация адаптеров таблиц текущего среза и событий                  curSrezAdapter = new SrezAdapter();                  curSrezCopyAdapter = new SrezAdapter();                  eventAdapter = new EventAdapter();                  eventCopyAdapter = new EventAdapter();                  curSrezAdapter.FileName = ServerUtils.BuildCurFileName(Settings.ArcDir);                  curSrezCopyAdapter.FileName = ServerUtils.BuildCurFileName(Settings.ArcCopyDir);                  eventAdapter.Directory = Settings.ArcDir + "Events" + Path.DirectorySeparatorChar;                  eventCopyAdapter.Directory = Settings.ArcCopyDir + "Events" + Path.DirectorySeparatorChar;                    // инициализация кэша таблиц минутных и часовых срезов                  minSrezTableCache = new SortedList<DateTime' SrezTableCache>();                  hrSrezTableCache = new SortedList<DateTime' SrezTableCache>();                    // инициализация описания создаваемых срезов                  int cnlCnt = inCnls.Count;                  srezDescr = new SrezTable.SrezDescr(cnlCnt);                  for (int i = 0; i < cnlCnt; i++)                      srezDescr.CnlNums[i] = inCnls.Values[i].CnlNum;                                  srezDescr.CalcCS();                    // загрузка исходного текущего среза из файла                  SrezTableLight.Srez curSrezSrc = null;                  SrezTableLight tblCurSrezScr = new SrezTableLight();                    try                  {                      if (File.Exists(curSrezAdapter.FileName))                      {                          curSrezAdapter.Fill(tblCurSrezScr);                          if (tblCurSrezScr.SrezList.Count > 0)                              curSrezSrc = tblCurSrezScr.SrezList.Values[0];                      }                        if (curSrezSrc == null)                          AppLog.WriteAction(Localization.UseRussian ? "Текущий срез не загружен" :                              "Current data are not loaded"' Log.ActTypes.Action);                      else                          AppLog.WriteAction(Localization.UseRussian ? "Текущий срез загружен" :                              "Current data are loaded"' Log.ActTypes.Action);                  }                  catch (Exception ex)                  {                      AppLog.WriteAction((Localization.UseRussian ? "Ошибка при загрузке текущего среза: " :                           "Error loading current data: ") + ex.Message' Log.ActTypes.Exception);                  }                    // инициализация текущего среза' предназначенного для формироваться данных сервера                  curSrez = new SrezTable.Srez(DateTime.MinValue' srezDescr' curSrezSrc);                    // инициализация данных для усреднения и времени активности каналов                  minAvgData = new AvgData[cnlCnt];                  hrAvgData = new AvgData[cnlCnt];                  activeDTs = new DateTime[cnlCnt];                  DateTime nowDT = DateTime.Now;                    for (int i = 0; i < cnlCnt; i++)                  {                      minAvgData[i] = new AvgData() { Sum = 0.0' Cnt = 0 };                      hrAvgData[i] = new AvgData() { Sum = 0.0' Cnt = 0 };                      activeDTs[i] = nowDT;                  }                    // цикл работы сервера                  nowDT = DateTime.MaxValue;                  DateTime today;                  DateTime prevDT;                  DateTime writeCurSrezDT = DateTime.MinValue;                  DateTime writeMinSrezDT = DateTime.MinValue;                  DateTime writeHrSrezDT = DateTime.MinValue;                  DateTime calcMinDT = DateTime.MinValue;                  DateTime calcHrDT = DateTime.MinValue;                  DateTime clearCacheDT = nowDT;                    bool calcDR = drCnls.Count > 0;                  bool writeCur = Settings.WriteCur || Settings.WriteCurCopy;                  bool writeCurOnMod = Settings.WriteCurPer <= 0;                  bool writeMin = (Settings.WriteMin || Settings.WriteMinCopy) && Settings.WriteMinPer > 0;                  bool writeHr = (Settings.WriteHr || Settings.WriteHrCopy) && Settings.WriteHrPer > 0;                    curSrezMod = false;                  serverIsReady = true;                    while (!terminated)                  {                      prevDT = nowDT;                      nowDT = DateTime.Now;                      today = nowDT.Date;                        // расчёт времени записи срезов и вычисления значений дорасчётных каналов                      // при переводе времени назад или при первом проходе цикла                      if (prevDT > nowDT)                      {                          writeCurSrezDT = nowDT;                          writeMinSrezDT = CalcNextTime(nowDT' Settings.WriteMinPer);                          writeHrSrezDT = CalcNextTime(nowDT' Settings.WriteHrPer);                          calcMinDT = drmCnls.Count > 0 ? CalcNextTime(nowDT' 60) : DateTime.MaxValue;                          calcHrDT = drhCnls.Count > 0 ? CalcNextTime(nowDT' 3600) : DateTime.MaxValue;                      }                        // удаление устаревших файлов срезов и событий при изменении даты или при первом проходе цикла                      if (prevDT.Date != today)                      {                          ClearArchive(Settings.ArcDir + "Min"' "m*.dat"' today.AddDays(-Settings.StoreMinPer));                          ClearArchive(Settings.ArcDir + "Hour"' "h*.dat"' today.AddDays(-Settings.StoreHrPer));                          ClearArchive(Settings.ArcDir + "Events"' "e*.dat"' today.AddDays(-Settings.StoreEvPer));                          ClearArchive(Settings.ArcCopyDir + "Min"' "m*.dat"' today.AddDays(-Settings.StoreMinPer));                          ClearArchive(Settings.ArcCopyDir + "Hour"' "h*.dat"' today.AddDays(-Settings.StoreHrPer));                          ClearArchive(Settings.ArcCopyDir + "Events"' "e*.dat"' today.AddDays(-Settings.StoreEvPer));                      }                        bool calcMinDR = calcMinDT <= nowDT; // необходимо вычислить минутные каналы                      bool calcHrDR = calcHrDT <= nowDT;   // необходимо вычислить часовые каналы                        lock (curSrez)                      {                          // установка недостоверности неактивных каналов                          SetUnreliable();                            // вычисление дорасчётных каналов                          if (calcDR)                          {                              CalcDRCnls(drCnls' curSrez' true);                          }                            // вычисление минутных каналов                          if (calcMinDR)                          {                              CalcDRCnls(drmCnls' curSrez' true);                              calcMinDT = CalcNextTime(nowDT' 60);                              curSrezMod = true;                          }                            // вычисление часовых каналов                          if (calcHrDR)                          {                              CalcDRCnls(drhCnls' curSrez' true);                              calcHrDT = CalcNextTime(nowDT' 3600);                              curSrezMod = true;                          }                      }                        // выполнение действий модулей без блокировки текущего среза                      if (calcDR)                          RaiseOnCurDataCalculated(drCnlNums' curSrez);                        if (calcMinDR)                          RaiseOnCurDataCalculated(drmCnlNums' curSrez);                        if (calcHrDR)                          RaiseOnCurDataCalculated(drhCnlNums' curSrez);                        // запись срезов                      lock (curSrez)                      {                          // запись текущего среза                          if ((writeCurSrezDT <= nowDT || writeCurOnMod && curSrezMod) && writeCur)                          {                              if (writeCurOnMod)                              {                                  WriteSrez(SnapshotTypes.Cur' nowDT);                                  curSrezMod = false;                                  writeCurSrezDT = DateTime.MaxValue;                              }                              else                              {                                  WriteSrez(SnapshotTypes.Cur' writeCurSrezDT);                                  writeCurSrezDT = CalcNextTime(nowDT' Settings.WriteCurPer);                              }                          }                            // запись минутного среза                          if (writeMinSrezDT <= nowDT && writeMin)                          {                              WriteSrez(SnapshotTypes.Min' writeMinSrezDT);                              writeMinSrezDT = CalcNextTime(nowDT' Settings.WriteMinPer);                          }                            // запись часового среза                          if (writeHrSrezDT <= nowDT && writeHr)                          {                              WriteSrez(SnapshotTypes.Hour' writeHrSrezDT);                              writeHrSrezDT = CalcNextTime(nowDT' Settings.WriteHrPer);                          }                      }                        // очистка устаревших данных кэша                      if (nowDT - clearCacheDT > CacheClearSpan || nowDT < clearCacheDT /*время переведено назад*/)                      {                          clearCacheDT = nowDT;                          ClearSrezTableCache(minSrezTableCache' MinCacheStorePer' MinCacheCapacity);                          ClearSrezTableCache(hrSrezTableCache' HourCacheStorePer' HourCacheCapacity);                      }                        // запись информации о работе приложения                      WriteInfo();                        // задержка для экономиии ресурсов процессора                      Thread.Sleep(100);                  }              }              finally              {                  // выполнение действий модулей                  RaiseOnServerStop();                    // запись информации о работе приложения                  workState = WorkStateNames.Stopped;                  WriteInfo();              }
Magic Number,Scada.Server.Svc,MainLogic,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\MainLogic.cs,ClearArchive,The following statement contains a magic number: try              {                  DirectoryInfo dirInfo = new DirectoryInfo(dir);                    if (dirInfo.Exists)                  {                      FileInfo[] files = dirInfo.GetFiles(pattern' SearchOption.TopDirectoryOnly);                        foreach (FileInfo fileInfo in files)                      {                          string fileName = fileInfo.Name;                          int year' month' day;                            if (fileName.Length >= 7 &&                              int.TryParse(fileName.Substring(1' 2)' out year) &&                              int.TryParse(fileName.Substring(3' 2)' out month) &&                              int.TryParse(fileName.Substring(5' 2)' out day))                          {                              DateTime fileDate;                              try { fileDate = new DateTime(2000 + year' month' day); }                              catch { fileDate = DateTime.MaxValue; }                                if (fileDate < arcBegDate)                                  fileInfo.Delete();                          }                      }                  }              }              catch (Exception ex)              {                  AppLog.WriteAction(string.Format(Localization.UseRussian ?                       "Ошибка при очистке устаревших архивных данных: {0}'{1}Директория: {2}" :                       "Error clearing outdated archive data: {0}{1}Directory: {2}"'                      ex.Message' Environment.NewLine' dir)' Log.ActTypes.Exception);              }
Magic Number,Scada.Server.Svc,MainLogic,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\MainLogic.cs,ClearArchive,The following statement contains a magic number: try              {                  DirectoryInfo dirInfo = new DirectoryInfo(dir);                    if (dirInfo.Exists)                  {                      FileInfo[] files = dirInfo.GetFiles(pattern' SearchOption.TopDirectoryOnly);                        foreach (FileInfo fileInfo in files)                      {                          string fileName = fileInfo.Name;                          int year' month' day;                            if (fileName.Length >= 7 &&                              int.TryParse(fileName.Substring(1' 2)' out year) &&                              int.TryParse(fileName.Substring(3' 2)' out month) &&                              int.TryParse(fileName.Substring(5' 2)' out day))                          {                              DateTime fileDate;                              try { fileDate = new DateTime(2000 + year' month' day); }                              catch { fileDate = DateTime.MaxValue; }                                if (fileDate < arcBegDate)                                  fileInfo.Delete();                          }                      }                  }              }              catch (Exception ex)              {                  AppLog.WriteAction(string.Format(Localization.UseRussian ?                       "Ошибка при очистке устаревших архивных данных: {0}'{1}Директория: {2}" :                       "Error clearing outdated archive data: {0}{1}Directory: {2}"'                      ex.Message' Environment.NewLine' dir)' Log.ActTypes.Exception);              }
Magic Number,Scada.Server.Svc,MainLogic,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\MainLogic.cs,ClearArchive,The following statement contains a magic number: try              {                  DirectoryInfo dirInfo = new DirectoryInfo(dir);                    if (dirInfo.Exists)                  {                      FileInfo[] files = dirInfo.GetFiles(pattern' SearchOption.TopDirectoryOnly);                        foreach (FileInfo fileInfo in files)                      {                          string fileName = fileInfo.Name;                          int year' month' day;                            if (fileName.Length >= 7 &&                              int.TryParse(fileName.Substring(1' 2)' out year) &&                              int.TryParse(fileName.Substring(3' 2)' out month) &&                              int.TryParse(fileName.Substring(5' 2)' out day))                          {                              DateTime fileDate;                              try { fileDate = new DateTime(2000 + year' month' day); }                              catch { fileDate = DateTime.MaxValue; }                                if (fileDate < arcBegDate)                                  fileInfo.Delete();                          }                      }                  }              }              catch (Exception ex)              {                  AppLog.WriteAction(string.Format(Localization.UseRussian ?                       "Ошибка при очистке устаревших архивных данных: {0}'{1}Директория: {2}" :                       "Error clearing outdated archive data: {0}{1}Directory: {2}"'                      ex.Message' Environment.NewLine' dir)' Log.ActTypes.Exception);              }
Magic Number,Scada.Server.Svc,MainLogic,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\MainLogic.cs,ClearArchive,The following statement contains a magic number: try              {                  DirectoryInfo dirInfo = new DirectoryInfo(dir);                    if (dirInfo.Exists)                  {                      FileInfo[] files = dirInfo.GetFiles(pattern' SearchOption.TopDirectoryOnly);                        foreach (FileInfo fileInfo in files)                      {                          string fileName = fileInfo.Name;                          int year' month' day;                            if (fileName.Length >= 7 &&                              int.TryParse(fileName.Substring(1' 2)' out year) &&                              int.TryParse(fileName.Substring(3' 2)' out month) &&                              int.TryParse(fileName.Substring(5' 2)' out day))                          {                              DateTime fileDate;                              try { fileDate = new DateTime(2000 + year' month' day); }                              catch { fileDate = DateTime.MaxValue; }                                if (fileDate < arcBegDate)                                  fileInfo.Delete();                          }                      }                  }              }              catch (Exception ex)              {                  AppLog.WriteAction(string.Format(Localization.UseRussian ?                       "Ошибка при очистке устаревших архивных данных: {0}'{1}Директория: {2}" :                       "Error clearing outdated archive data: {0}{1}Directory: {2}"'                      ex.Message' Environment.NewLine' dir)' Log.ActTypes.Exception);              }
Magic Number,Scada.Server.Svc,MainLogic,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\MainLogic.cs,ClearArchive,The following statement contains a magic number: try              {                  DirectoryInfo dirInfo = new DirectoryInfo(dir);                    if (dirInfo.Exists)                  {                      FileInfo[] files = dirInfo.GetFiles(pattern' SearchOption.TopDirectoryOnly);                        foreach (FileInfo fileInfo in files)                      {                          string fileName = fileInfo.Name;                          int year' month' day;                            if (fileName.Length >= 7 &&                              int.TryParse(fileName.Substring(1' 2)' out year) &&                              int.TryParse(fileName.Substring(3' 2)' out month) &&                              int.TryParse(fileName.Substring(5' 2)' out day))                          {                              DateTime fileDate;                              try { fileDate = new DateTime(2000 + year' month' day); }                              catch { fileDate = DateTime.MaxValue; }                                if (fileDate < arcBegDate)                                  fileInfo.Delete();                          }                      }                  }              }              catch (Exception ex)              {                  AppLog.WriteAction(string.Format(Localization.UseRussian ?                       "Ошибка при очистке устаревших архивных данных: {0}'{1}Директория: {2}" :                       "Error clearing outdated archive data: {0}{1}Directory: {2}"'                      ex.Message' Environment.NewLine' dir)' Log.ActTypes.Exception);              }
Magic Number,Scada.Server.Svc,MainLogic,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\MainLogic.cs,ClearArchive,The following statement contains a magic number: try              {                  DirectoryInfo dirInfo = new DirectoryInfo(dir);                    if (dirInfo.Exists)                  {                      FileInfo[] files = dirInfo.GetFiles(pattern' SearchOption.TopDirectoryOnly);                        foreach (FileInfo fileInfo in files)                      {                          string fileName = fileInfo.Name;                          int year' month' day;                            if (fileName.Length >= 7 &&                              int.TryParse(fileName.Substring(1' 2)' out year) &&                              int.TryParse(fileName.Substring(3' 2)' out month) &&                              int.TryParse(fileName.Substring(5' 2)' out day))                          {                              DateTime fileDate;                              try { fileDate = new DateTime(2000 + year' month' day); }                              catch { fileDate = DateTime.MaxValue; }                                if (fileDate < arcBegDate)                                  fileInfo.Delete();                          }                      }                  }              }              catch (Exception ex)              {                  AppLog.WriteAction(string.Format(Localization.UseRussian ?                       "Ошибка при очистке устаревших архивных данных: {0}'{1}Директория: {2}" :                       "Error clearing outdated archive data: {0}{1}Directory: {2}"'                      ex.Message' Environment.NewLine' dir)' Log.ActTypes.Exception);              }
Magic Number,Scada.Server.Svc,MainLogic,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\MainLogic.cs,ClearArchive,The following statement contains a magic number: try              {                  DirectoryInfo dirInfo = new DirectoryInfo(dir);                    if (dirInfo.Exists)                  {                      FileInfo[] files = dirInfo.GetFiles(pattern' SearchOption.TopDirectoryOnly);                        foreach (FileInfo fileInfo in files)                      {                          string fileName = fileInfo.Name;                          int year' month' day;                            if (fileName.Length >= 7 &&                              int.TryParse(fileName.Substring(1' 2)' out year) &&                              int.TryParse(fileName.Substring(3' 2)' out month) &&                              int.TryParse(fileName.Substring(5' 2)' out day))                          {                              DateTime fileDate;                              try { fileDate = new DateTime(2000 + year' month' day); }                              catch { fileDate = DateTime.MaxValue; }                                if (fileDate < arcBegDate)                                  fileInfo.Delete();                          }                      }                  }              }              catch (Exception ex)              {                  AppLog.WriteAction(string.Format(Localization.UseRussian ?                       "Ошибка при очистке устаревших архивных данных: {0}'{1}Директория: {2}" :                       "Error clearing outdated archive data: {0}{1}Directory: {2}"'                      ex.Message' Environment.NewLine' dir)' Log.ActTypes.Exception);              }
Magic Number,Scada.Server.Svc,MainLogic,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\MainLogic.cs,CalcCnlData,The following statement contains a magic number: if (inCnl != null)              {                  try                  {                      // вычисление новых данных                      if (inCnl.CalcCnlData != null)                          inCnl.CalcCnlData(ref newCnlData);                        // увеличение счётчика количества переключений                      if (inCnl.CnlTypeID == BaseValues.CnlTypes.SWCNT &&                           newCnlData.Stat > BaseValues.CnlStatuses.Undefined)                      {                          bool even = (int)oldCnlData.Val % 2 == 0; // старое значение чётное                          newCnlData.Val = newCnlData.Val <= 0 && even || newCnlData.Val > 0 && !even ?                               Math.Truncate(oldCnlData.Val) + 1 : Math.Truncate(oldCnlData.Val);                      }                        // корректировка нового статуса' если задана проверка границ значения                      if (newCnlData.Stat == BaseValues.CnlStatuses.Defined &&                          (inCnl.LimLow < inCnl.LimHigh || inCnl.LimLowCrash < inCnl.LimHighCrash))                      {                          newCnlData.Stat = BaseValues.CnlStatuses.Normal;                            if (inCnl.LimLow < inCnl.LimHigh)                          {                              if (newCnlData.Val < inCnl.LimLow)                                  newCnlData.Stat = BaseValues.CnlStatuses.Low;                              else if (newCnlData.Val > inCnl.LimHigh)                                  newCnlData.Stat = BaseValues.CnlStatuses.High;                          }                            if (inCnl.LimLowCrash < inCnl.LimHighCrash)                          {                              if (newCnlData.Val < inCnl.LimLowCrash)                                  newCnlData.Stat = BaseValues.CnlStatuses.LowCrash;                              else if (newCnlData.Val > inCnl.LimHighCrash)                                  newCnlData.Stat = BaseValues.CnlStatuses.HighCrash;                          }                      }                  }                  catch                  {                      newCnlData.Stat = BaseValues.CnlStatuses.FormulaError;                  }              }
Missing Default,Scada.Server.Svc,Comm,C:\repos\RapidScada_SCADA\ScadaServer\ScadaServerSvc\Comm.cs,ProcCommCommand,The following switch statement is missing a default case: switch (cmd)              {                  case 0x01: // проверка имени и пароля                      int userNameLen = inBuf[3];                      string userName = Encoding.Default.GetString(inBuf' 4' userNameLen);                      string password = Encoding.Default.GetString(inBuf' 5 + userNameLen' inBuf[4 + userNameLen]);                      bool pwdIsEmpty = string.IsNullOrEmpty(password);                      int roleID;                      bool checkOk = CheckUser(userName' password' out roleID);                        if (client.Authenticated)                      {                          if (pwdIsEmpty)                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "успешно" : "success") :                                  (Localization.UseRussian ? "ошибка" : "error");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение роли пользователя {0}. Результат: {1}" :                                   "Get user {0} role. Result: {1}"' userName' checkOkStr));                          }                          else                          {                              string checkOkStr = checkOk ?                                  (Localization.UseRussian ? "верно" : "passed") :                                  (Localization.UseRussian ? "неверно" : "failed");                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Проверка имени и пароля пользователя {0}. Результат: {1}" :                                   "Check user {0} name and password. Result: {1}"' userName' checkOkStr));                          }                      }                      else                      {                          if (checkOk && roleID != BaseValues.Roles.Disabled && !pwdIsEmpty)                          {                              client.Authenticated = true;                              client.UserName = userName;                              client.UserRoleID = roleID;                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Пользователь {0} успешно аутентифицирован" :                                   "The user {0} is successfully authenticated"' userName));                          }                          else                          {                              client.ActivityDT = DateTime.MinValue; // для отключения клиента после отправки ответа                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Неудачная попытка аутентификации пользователя {0}" :                                   "Unsuccessful attempt to authenticate the user {0}"' userName));                          }                      }                        respDataLen = 1;                      outBuf[3] = (byte)roleID;                      break;                  case 0x02: // запрос состояния сервера (ping)                      respDataLen = 1;                      outBuf[3] = mainLogic.ServerIsReady ? (byte)1 : (byte)0;                      break;                  case 0x03: // запись текущего среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          int cnlCnt = BitConverter.ToUInt16(inBuf' 3);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(DateTime.MinValue' cnlCnt);                            for (int i = 0' j = 5; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcCurData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x04: // запись архивного среза                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          DateTime dateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          int cnlCnt = BitConverter.ToUInt16(inBuf' 11);                          SrezTableLight.Srez srez = new SrezTableLight.Srez(dateTime' cnlCnt);                            for (int i = 0' j = 13; i < cnlCnt; i++' j += 14)                          {                              srez.CnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                              srez.CnlData[i] = new SrezTableLight.CnlData(                                  BitConverter.ToDouble(inBuf' j + 4)'                                  BitConverter.ToUInt16(inBuf' j + 12));                          }                            outBuf[3] = mainLogic.ProcArcData(srez) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x05: // запись события                      if (client.UserRoleID == BaseValues.Roles.App)                      {                          EventTableLight.Event ev = new EventTableLight.Event();                          ev.DateTime = ScadaUtils.DecodeDateTime(BitConverter.ToDouble(inBuf' 3));                          ev.ObjNum = BitConverter.ToUInt16(inBuf' 11);                          ev.KPNum = BitConverter.ToUInt16(inBuf' 13);                          ev.ParamID = BitConverter.ToUInt16(inBuf' 15);                          ev.CnlNum = (int)BitConverter.ToUInt32(inBuf' 17);                          ev.OldCnlVal = BitConverter.ToDouble(inBuf' 21);                          ev.OldCnlStat = BitConverter.ToUInt16(inBuf' 29);                          ev.NewCnlVal = BitConverter.ToDouble(inBuf' 31);                          ev.NewCnlStat = BitConverter.ToUInt16(inBuf' 39);                          ev.Checked = BitConverter.ToBoolean(inBuf' 41);                          ev.UserID = BitConverter.ToUInt16(inBuf' 42);                          int evDescrLen = inBuf[44];                          int evDataLen = inBuf[45 + evDescrLen];                          ev.Descr = Encoding.Default.GetString(inBuf' 45' evDescrLen);                          ev.Data = Encoding.Default.GetString(inBuf' 46 + evDescrLen' evDataLen);                            outBuf[3] = mainLogic.ProcEvent(ev) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x06: // команда ТУ                      bool cmdProcOk = false; // команда обработана успешно                        if (client.UserRoleID == BaseValues.Roles.Admin ||                           client.UserRoleID == BaseValues.Roles.Dispatcher || client.UserRoleID == BaseValues.Roles.App)                      {                          int cmdUserID = BitConverter.ToUInt16(inBuf' 3);                          byte cmdTypeID = inBuf[5];                          int ctrlCnlNum = BitConverter.ToUInt16(inBuf' 6);                          MainLogic.CtrlCnl ctrlCnl = mainLogic.GetCtrlCnl(ctrlCnlNum);                            if (ctrlCnl == null)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ на несуществующий канал упр. {0}' ид. польз. = {1}" :                                  "Command to nonexistent out channel {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                          }                          else                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Команда ТУ: канал упр. = {0}' ид. польз. = {1}" :                                  "Command: out channel = {0}' user ID = {1}"'                                  ctrlCnlNum' cmdUserID));                                // создание команды ТУ                              Command ctrlCmd = new Command(cmdTypeID);                              ctrlCmd.CmdData = new byte[BitConverter.ToUInt16(inBuf' 8)];                              Array.Copy(inBuf' 10' ctrlCmd.CmdData' 0' ctrlCmd.CmdData.Length);                              FillCommandProps(ctrlCmd' ctrlCnl);                                // обработка команды ТУ                              bool passToClients;                              mainLogic.ProcCommand(ctrlCnl' ctrlCmd' cmdUserID' out passToClients);                                if (passToClients)                              {                                  // передача команды ТУ подключенным клиентам                                  ctrlCmd.PrepareCmdData();                                  foreach (ClientInfo cl in clients)                                      if (cl.UserRoleID == BaseValues.Roles.App)                                          cl.CmdList.Add(ctrlCmd);                              }                              else if (ctrlCmd.CmdNum > 0)                              {                                  appLog.WriteAction(Localization.UseRussian ?                                       "Команда ТУ отменена" :                                       "Command is canceled");                              }                                cmdProcOk = true;                          }                      }                        respDataLen = 1;                      outBuf[3] = cmdProcOk ? (byte)1 : (byte)0;                      break;                  case 0x07: // запрос команды ТУ                      if (client.UserRoleID == BaseValues.Roles.App && client.CmdList.Count > 0)                      {                          Command ctrlCmd = client.CmdList[0];                          int cmdDataLen = ctrlCmd.CmdData == null ? 0 : ctrlCmd.CmdData.Length;                          respDataLen = 7 + cmdDataLen;                          outBuf[3] = (byte)(cmdDataLen % 256);                          outBuf[4] = (byte)(cmdDataLen / 256);                          outBuf[5] = (byte)ctrlCmd.CmdTypeID;                          outBuf[6] = (byte)(ctrlCmd.KPNum % 256);                          outBuf[7] = (byte)(ctrlCmd.KPNum / 256);                          outBuf[8] = (byte)(ctrlCmd.CmdNum % 256);                          outBuf[9] = (byte)(ctrlCmd.CmdNum / 256);                          if (cmdDataLen > 0)                              Array.Copy(ctrlCmd.CmdData' 0' outBuf' 10' cmdDataLen);                            // удаление команды ТУ из списка команд клиента                          client.CmdList.RemoveAt(0);                      }                      else                      {                          respDataLen = 2;                          outBuf[3] = 0;                          outBuf[4] = 0;                      }                      break;                  case 0x08: // открытие и чтение из файла                      int readCnt = 0;                      bool readOk = false;                        if (client.Authenticated)                      {                          client.CloseFile();                            try { client.Dir = (Dirs)inBuf[3]; }                          catch { client.Dir = Dirs.Cur; }                            int fileNameLen = inBuf[4];                          client.FileName = Encoding.Default.GetString(inBuf' 5' fileNameLen);                          string fullFileName = GetFullFileName(client.Dir' client.FileName);                          int count = BitConverter.ToUInt16(inBuf' 5 + fileNameLen);                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Открытие файла {0}" :                                   "Opening file {0}"' fullFileName));                            try                          {                              if (File.Exists(fullFileName))                              {                                  client.FileStream = new FileStream(fullFileName'                                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite);                                  readCnt = client.FileStream.Read(outBuf' 6' count);                                  readOk = true;                              }                              else                              {                                  appLog.WriteError(string.Format(Localization.UseRussian ?                                      "Файл {0} не найден." :                                       "File {0} not found."' client.FullFileNameInfo));                              }                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 3 + readCnt;                      outBuf[3] = readOk ? (byte)1 : (byte)0;                      outBuf[4] = (byte)(readCnt % 256);                      outBuf[5] = (byte)(readCnt / 256);                      break;                  case 0x09: // перемещение позиции чтения из файла                      long pos = 0;                      bool seekOk = false;                        if (client.Authenticated && client.FileStream != null)                      {                          SeekOrigin origin;                          try { origin = (SeekOrigin)inBuf[3]; }                          catch { origin = SeekOrigin.Begin; }                          long offset = BitConverter.ToUInt32(inBuf' 4);                            try                          {                              pos = client.FileStream.Seek(offset' origin);                              seekOk = true;                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                  "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                      }                        respDataLen = 5;                      outBuf[3] = seekOk ? (byte)1 : (byte)0;                      Array.Copy(BitConverter.GetBytes((uint)pos)' 0' outBuf' 4' 4);                      break;                  case 0x0A: // чтение из файла                      readCnt = 0;                        if (client.Authenticated && client.FileStream != null)                      {                          int count = BitConverter.ToUInt16(inBuf' 3);                            try                          {                              readCnt = client.FileStream.Read(outBuf' 5' count);                          }                          catch (Exception ex)                          {                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Ошибка при работе с файлом {0}: {1}" :                                   "Error working with the file {0}: {1}"'                                  client.FullFileNameInfo' ex.Message)' Log.ActTypes.Exception);                          }                          finally                          {                              if (readCnt < count)                                  client.CloseFile();                          }                      }                        respDataLen = 2 + readCnt;                      outBuf[3] = (byte)(readCnt % 256);                      outBuf[4] = (byte)(readCnt / 256);                      break;                  case 0x0B: // закрытие файла                      if (client.Authenticated && client.FileStream != null)                      {                          client.CloseFile();                          outBuf[3] = 1;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;                  case 0x0C: // запрос времени изменения файлов                      int fileCnt = inBuf[3];                      outBuf[3] = inBuf[3];                        for (int i = 0' j = 4' k = 4; i < fileCnt; i++' k += 8)                      {                          Dirs dir;                          try { dir = (Dirs)inBuf[j++]; }                          catch { dir = Dirs.Cur; }                            int fileNameLen = inBuf[j++];                          string fileName = Encoding.Default.GetString(inBuf' j' fileNameLen);                          string fullFileName = GetFullFileName(dir' fileName);                          j += fileNameLen;                            if (settings.DetailedLog)                              appLog.WriteAction(string.Format(Localization.UseRussian ?                                  "Получение времени изменения файла {0}" :                                   "Obtaining the modification time of the file {0}"' fullFileName));                            double fileModTime;                          try                           {                              fileModTime = File.Exists(fullFileName) ?                                  ScadaUtils.EncodeDateTime(File.GetLastWriteTime(fullFileName)) : 0;                           }                          catch                          {                              fileModTime = 0;                          }                            Array.Copy(BitConverter.GetBytes(fileModTime)' 0' outBuf' k' 8);                      }                        respDataLen = 1 + 8 * fileCnt;                      break;                  case 0x0D: // запрос данных из таблицы среза                      byte srezTypeNum = inBuf[3];                      SnapshotTypes srezType;                      DateTime srezDate;                        if (srezTypeNum == 0x01)                      {                          srezType = SnapshotTypes.Cur;                          srezDate = DateTime.MinValue;                      }                      else                      {                          srezType = srezTypeNum == 0x02 ? SnapshotTypes.Hour : SnapshotTypes.Min;                          srezDate = new DateTime(inBuf[4] + 2000' inBuf[5]' inBuf[6]);                      }                        int cnlNumCnt = BitConverter.ToUInt16(inBuf' 7);                      int[] cnlNums = new int[cnlNumCnt];                        for (int i = 0' j = 9; i < cnlNumCnt; i++' j += 4)                          cnlNums[i] = (int)BitConverter.ToUInt32(inBuf' j);                        if (settings.DetailedLog)                      {                          string srezTypeStr;                          if (srezType == SnapshotTypes.Cur)                              srezTypeStr = Localization.UseRussian ? "текущие" : "current";                          else if (srezType == SnapshotTypes.Min)                              srezTypeStr = Localization.UseRussian ? "минутные" : "minute";                          else                              srezTypeStr = Localization.UseRussian ? "часовые" : "hourly";                            appLog.WriteAction(string.Format(Localization.UseRussian ?                               "Запрос данных. Тип: {0}. Дата: {1}. Каналы: {2}" :                               "Data request. Type: {0}. Date: {1}. Channels: {2}"'                              srezTypeStr' srezDate.ToString("d"' Localization.Culture)' string.Join("' "' cnlNums)));                      }                        SrezTableLight srezTable = mainLogic.GetSnapshotTable(srezDate' srezType' cnlNums);                      int srezCnt = srezTable == null ? 0 : srezTable.SrezList.Count;                      outBuf[5] = (byte)(srezCnt % 256);                      outBuf[6] = (byte)(srezCnt / 256);                      extraData = new byte[srezCnt * (10 * cnlNumCnt + 8)];                        for (int i = 0' j = 0; i < srezCnt; i++)                      {                          SrezTableLight.Srez srez = srezTable.SrezList.Values[i];                          Array.Copy(BitConverter.GetBytes(ScadaUtils.EncodeDateTime(srez.DateTime))' 0' extraData' j' 8);                          j += 8;                            for (int k = 0; k < cnlNumCnt; k++)                          {                              SrezTable.CnlData cnlData = srez.CnlData[k];                              Array.Copy(BitConverter.GetBytes(cnlData.Val)' 0' extraData' j' 8);                              j += 8;                              extraData[j++] = (byte)(cnlData.Stat % 256);                              extraData[j++] = (byte)(cnlData.Stat / 256);                          }                      }                        respDataLen = 2 + extraData.Length;                      break;                  case 0x0E: // квитирование события                      if (client.Authenticated)                      {                          int evUserID = BitConverter.ToUInt16(inBuf' 3);                          DateTime evDate = new DateTime(inBuf[5] + 2000' inBuf[6]' inBuf[7]);                          int evNum = BitConverter.ToUInt16(inBuf' 8);                          outBuf[3] = mainLogic.CheckEvent(evDate' evNum' evUserID) ? (byte)1 : (byte)0;                      }                      else                      {                          outBuf[3] = 0;                      }                        respDataLen = 1;                      break;              }
