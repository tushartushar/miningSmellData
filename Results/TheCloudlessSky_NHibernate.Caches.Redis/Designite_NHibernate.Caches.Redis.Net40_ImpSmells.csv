Implementation smell,Namespace,Class,File,Method,Description
Complex Method,NHibernate.Caches.Redis,RedisCacheProvider,D:\research\architectureSmells\repos1\TheCloudlessSky_NHibernate.Caches.Redis\src\NHibernate.Caches.Redis\RedisCacheProvider.cs,BuildCache,Cyclomatic complexity of the method is 8
Long Parameter List,NHibernate.Caches.Redis,LockFailedEventArgs,D:\research\architectureSmells\repos1\TheCloudlessSky_NHibernate.Caches.Redis\src\NHibernate.Caches.Redis\LockFailedEventArgs.cs,LockFailedEventArgs,The method has 5 parameters. Parameters: regionName' key' lockKey' lockTimeout' acquireLockTimeout
Long Parameter List,NHibernate.Caches.Redis,ShouldRetryAcquireLockArgs,D:\research\architectureSmells\repos1\TheCloudlessSky_NHibernate.Caches.Redis\src\NHibernate.Caches.Redis\ShouldRetryAcquireLockArgs.cs,ShouldRetryAcquireLockArgs,The method has 6 parameters. Parameters: regionName' key' lockKey' lockValue' lockTimeout' acquireLockTimeout
Long Statement,NHibernate.Caches.Redis,RedisCache,D:\research\architectureSmells\repos1\TheCloudlessSky_NHibernate.Caches.Redis\src\NHibernate.Caches.Redis\RedisCache.cs,Unlock,The length of the statement  "                    log.WarnFormat("attempted to unlock '{0}' but it could not be released (it maybe timed out or was cleared in Redis)"' lockData); " is 128.
Magic Number,NHibernate.Caches.Redis,ExponentialBackoffWithJitterAcquireLockRetryStrategy,D:\research\architectureSmells\repos1\TheCloudlessSky_NHibernate.Caches.Redis\src\NHibernate.Caches.Redis\ExponentialBackoffWithJitterAcquireLockRetryStrategy.cs,GetShouldRetry,The following statement contains a magic number: return (ShouldRetryAcquireLockArgs args) =>              {                  attempt++;                    var hasNotTimedOut = DateTime.UtcNow - firstAttempt < args.AcquireLockTimeout;                    if (hasNotTimedOut)                  {                      // Use an exponential backoff with jitter (randomness) to                      // prevent multiple concurrent retries and reduce work.                      //                      // This is the "Full Jitter" algorithm from:                      // http://www.awsarchitectureblog.com/2015/03/backoff.html                      // https://github.com/awslabs/aws-arch-backoff-simulator/blob/master/src/backoff_simulator.py                      // However' the algorithm is modified to use a minimum sleep                      // instead of "0" to prevent a wasted sleep.                      var v = (int)Math.Min(sleepMax' Math.Pow(2' attempt) * sleepBase);                      var sleep = random.Next(sleepBase' v);                        if (log.IsDebugEnabled)                      {                          log.DebugFormat("sleep back off for {0}ms"' sleep);                      }                        if (onBackoff != null)                      {                          onBackoff(args' attempt' sleep);                      }                        Thread.Sleep(sleep);                  }                    var shouldRetry = hasNotTimedOut;                  return shouldRetry;              };
