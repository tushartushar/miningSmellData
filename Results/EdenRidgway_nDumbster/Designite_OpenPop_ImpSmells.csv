Implementation smell,Namespace,Class,File,Method,Description
Long Method,OpenPop.Mime.Header,MessageHeader,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Mime\Header\MessageHeader.cs,ParseHeader,The method has 126 lines of code.
Complex Method,OpenPop.Mime.Decode,Rfc2231Decoder,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Mime\Decode\Rfc2231Decoder.cs,DecodePairs,Cyclomatic complexity of the method is 10
Complex Method,OpenPop.Mime.Decode,Rfc2822DateTime,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Mime\Decode\Rfc2822DateTime.cs,MatchEvaluator,Cyclomatic complexity of the method is 38
Complex Method,OpenPop.Mime.Decode,EncodedWord,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Mime\Decode\EncodedWord.cs,Decode,Cyclomatic complexity of the method is 11
Complex Method,OpenPop.Mime.Decode,QuotedPrintable,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Mime\Decode\QuotedPrintable.cs,Rfc2047QuotedPrintableDecode,Cyclomatic complexity of the method is 8
Complex Method,OpenPop.Mime.Header,MessageHeader,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Mime\Header\MessageHeader.cs,ParseHeader,Cyclomatic complexity of the method is 74
Complex Method,OpenPop.Mime.Header,HeaderFieldParser,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Mime\Header\HeaderFieldParser.cs,ParseContentTransferEncoding,Cyclomatic complexity of the method is 8
Complex Method,OpenPop.Mime.Header,HeaderFieldParser,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Mime\Header\HeaderFieldParser.cs,ParseImportance,Cyclomatic complexity of the method is 9
Complex Method,OpenPop.Mime.Header,HeaderFieldParser,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Mime\Header\HeaderFieldParser.cs,ParseContentType,Cyclomatic complexity of the method is 21
Complex Method,OpenPop.Mime.Header,HeaderFieldParser,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Mime\Header\HeaderFieldParser.cs,ParseContentDisposition,Cyclomatic complexity of the method is 28
Complex Method,OpenPop.Mime,Message,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Mime\Message.cs,ToMailMessage,Cyclomatic complexity of the method is 16
Complex Method,OpenPop.Mime,MessagePart,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Mime\MessagePart.cs,DecodeBody,Cyclomatic complexity of the method is 8
Complex Method,OpenPop.Pop3,Pop3Client,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Pop3\Pop3Client.cs,Connect,Cyclomatic complexity of the method is 10
Complex Method,OpenPop.Pop3,Pop3Client,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Pop3\Pop3Client.cs,Authenticate,Cyclomatic complexity of the method is 17
Complex Method,OpenPop.Pop3,Pop3Client,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Pop3\Pop3Client.cs,GetMessageAsBytes,Cyclomatic complexity of the method is 9
Complex Method,OpenPop.Common,StreamUtility,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Common\StreamUtility.cs,ReadLineAsBytes,Cyclomatic complexity of the method is 8
Long Parameter List,OpenPop.Pop3,Pop3Client,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Pop3\Pop3Client.cs,Connect,The method has 6 parameters.
Long Identifier,OpenPop.Mime,MessagePart,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Mime\MessagePart.cs,GetMultiPartParts,The length of the parameter lastMultipartBoundaryEncountered is 32.
Long Statement,OpenPop.Mime.Decode,Rfc2231Decoder,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Mime\Decode\Rfc2231Decoder.cs,Decode,The length of the statement  "			throw new ArgumentException ("When splitting the part \"" + part + "\" by = there was " + keyValue.Length + " parts. Only 1 and 2 are supported"); " is 146.
Long Statement,OpenPop.Mime.Decode,Rfc2231Decoder,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Mime\Decode\Rfc2231Decoder.cs,DecodePairs,The length of the statement  "		if (key.EndsWith ("*0"' StringComparison.OrdinalIgnoreCase) || key.EndsWith ("*0*"' StringComparison.OrdinalIgnoreCase)) { " is 122.
Long Statement,OpenPop.Mime.Decode,Rfc2231Decoder,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Mime\Decode\Rfc2231Decoder.cs,DecodeSingleValue,The length of the statement  "		DefaultLogger.Log.LogDebug ("Rfc2231Decoder: Someone asked me to decode a string which was not encoded - returning raw string. Input: " + toDecode); " is 148.
Long Statement,OpenPop.Mime.Decode,Rfc2822DateTime,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Mime\Decode\Rfc2822DateTime.cs,ValidateDayNameIfAny,The length of the statement  "		if ((dateTime.DayOfWeek == DayOfWeek.Monday && !dayName.Equals ("Mon")) || (dateTime.DayOfWeek == DayOfWeek.Tuesday && !dayName.Equals ("Tue")) || (dateTime.DayOfWeek == DayOfWeek.Wednesday && !dayName.Equals ("Wed")) || (dateTime.DayOfWeek == DayOfWeek.Thursday && !dayName.Equals ("Thu")) || (dateTime.DayOfWeek == DayOfWeek.Friday && !dayName.Equals ("Fri")) || (dateTime.DayOfWeek == DayOfWeek.Saturday && !dayName.Equals ("Sat")) || (dateTime.DayOfWeek == DayOfWeek.Sunday && !dayName.Equals ("Sun"))) { " is 508.
Long Statement,OpenPop.Mime.Header,HeaderFieldParser,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Mime\Header\HeaderFieldParser.cs,ParseImportance,The length of the statement  "		DefaultLogger.Log.LogDebug ("HeaderFieldParser: Unknown importance value: \"" + headerValue + "\". Using default of normal importance."); " is 137.
Long Statement,OpenPop.Mime,MessagePart,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Mime\MessagePart.cs,GetMultiPartParts,The length of the statement  "		int startLocation = FindPositionOfNextMultiPartBoundary (stream' multipPartBoundary' out lastMultipartBoundaryEncountered) + ("--" + multipPartBoundary + "\r\n").Length; " is 169.
Long Statement,OpenPop.Mime,MessagePart,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Mime\MessagePart.cs,GetMultiPartParts,The length of the statement  "			int stopLocation = FindPositionOfNextMultiPartBoundary (stream' multipPartBoundary' out lastMultipartBoundaryEncountered) - "\r\n".Length; " is 138.
Long Statement,OpenPop.Pop3,Disposable,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Pop3\Disposable.cs,AssertDisposed,The length of the statement  "		throw new ObjectDisposedException (typeName' String.Format (System.Globalization.CultureInfo.InvariantCulture' "Cannot access a disposed {0}."' typeName)); " is 155.
Long Statement,OpenPop.Pop3,Pop3Client,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Pop3\Pop3Client.cs,Connect,The length of the statement  "		throw new InvalidUseException ("You cannot ask to connect to a POP3 server' when we are already connected to one. Disconnect first."); " is 134.
Long Statement,OpenPop.Pop3,Pop3Client,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Pop3\Pop3Client.cs,Connect,The length of the statement  "		throw new InvalidUseException ("You cannot ask to connect to a POP3 server' when we are already connected to one. Disconnect first."); " is 134.
Long Statement,OpenPop.Pop3,Pop3Client,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Pop3\Pop3Client.cs,Authenticate,The length of the statement  "		DefaultLogger.Log.LogError ("Problem logging in using method " + authenticationMethod + ". Server response was: " + LastServerResponse); " is 136.
Long Statement,OpenPop.Pop3,Pop3Client,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Pop3\Pop3Client.cs,GetMessageCount,The length of the statement  "		throw new InvalidUseException ("You cannot get the message count without authenticating yourself towards the server first"); " is 124.
Long Statement,OpenPop.Pop3,Pop3Client,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Pop3\Pop3Client.cs,DeleteMessage,The length of the statement  "		throw new InvalidUseException ("You cannot delete any messages without authenticating yourself towards the server first"); " is 122.
Long Statement,OpenPop.Pop3,Pop3Client,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Pop3\Pop3Client.cs,Capabilities,The length of the statement  "	Dictionary<string' List<string>> capabilities = new Dictionary<string' List<string>> (StringComparer.OrdinalIgnoreCase); " is 120.
Long Statement,OpenPop.Pop3,Pop3Client,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Pop3\Pop3Client.cs,ValidateMessageNumber,The length of the statement  "		throw new InvalidUseException ("The messageNumber argument cannot have a value of zero or less. Valid messageNumber is in the range [1' messageCount]"); " is 152.
Complex Conditional,OpenPop.Mime.Decode,Rfc2822DateTime,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Mime\Decode\Rfc2822DateTime.cs,ValidateDayNameIfAny,The conditional expression  "(dateTime.DayOfWeek == DayOfWeek.Monday && !dayName.Equals ("Mon")) || (dateTime.DayOfWeek == DayOfWeek.Tuesday && !dayName.Equals ("Tue")) || (dateTime.DayOfWeek == DayOfWeek.Wednesday && !dayName.Equals ("Wed")) || (dateTime.DayOfWeek == DayOfWeek.Thursday && !dayName.Equals ("Thu")) || (dateTime.DayOfWeek == DayOfWeek.Friday && !dayName.Equals ("Fri")) || (dateTime.DayOfWeek == DayOfWeek.Saturday && !dayName.Equals ("Sat")) || (dateTime.DayOfWeek == DayOfWeek.Sunday && !dayName.Equals ("Sun"))"  is complex.
Magic Number,OpenPop.Mime.Decode,Rfc2231Decoder,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Mime\Decode\Rfc2231Decoder.cs,Decode,The following statement contains a magic number: foreach (string part in splitted) {  	// Empty strings should not be processed  	if (part.Trim ().Length == 0)  		continue;  	string[] keyValue = part.Trim ().Split (new[] {  		'='  	}' 2);  	if (keyValue.Length == 1) {  		collection.Add (new KeyValuePair<string' string> (""' keyValue [0]));  	} else if (keyValue.Length == 2) {  		collection.Add (new KeyValuePair<string' string> (keyValue [0]' keyValue [1]));  	} else {  		throw new ArgumentException ("When splitting the part \"" + part + "\" by = there was " + keyValue.Length + " parts. Only 1 and 2 are supported");  	}  }  
Magic Number,OpenPop.Mime.Decode,Rfc2231Decoder,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Mime\Decode\Rfc2231Decoder.cs,Decode,The following statement contains a magic number: foreach (string part in splitted) {  	// Empty strings should not be processed  	if (part.Trim ().Length == 0)  		continue;  	string[] keyValue = part.Trim ().Split (new[] {  		'='  	}' 2);  	if (keyValue.Length == 1) {  		collection.Add (new KeyValuePair<string' string> (""' keyValue [0]));  	} else if (keyValue.Length == 2) {  		collection.Add (new KeyValuePair<string' string> (keyValue [0]' keyValue [1]));  	} else {  		throw new ArgumentException ("When splitting the part \"" + part + "\" by = there was " + keyValue.Length + " parts. Only 1 and 2 are supported");  	}  }  
Magic Number,OpenPop.Mime.Decode,Rfc2231Decoder,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Mime\Decode\Rfc2231Decoder.cs,Decode,The following statement contains a magic number: if (keyValue.Length == 1) {  	collection.Add (new KeyValuePair<string' string> (""' keyValue [0]));  } else if (keyValue.Length == 2) {  	collection.Add (new KeyValuePair<string' string> (keyValue [0]' keyValue [1]));  } else {  	throw new ArgumentException ("When splitting the part \"" + part + "\" by = there was " + keyValue.Length + " parts. Only 1 and 2 are supported");  }  
Magic Number,OpenPop.Mime.Decode,Rfc2231Decoder,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Mime\Decode\Rfc2231Decoder.cs,Decode,The following statement contains a magic number: if (keyValue.Length == 2) {  	collection.Add (new KeyValuePair<string' string> (keyValue [0]' keyValue [1]));  } else {  	throw new ArgumentException ("When splitting the part \"" + part + "\" by = there was " + keyValue.Length + " parts. Only 1 and 2 are supported");  }  
Magic Number,OpenPop.Mime.Decode,Rfc2822DateTime,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Mime\Decode\Rfc2822DateTime.cs,ValidateDayNameIfAny,The following statement contains a magic number: if (dateInput.Length >= 4 && dateInput [3] == ''') {  	string dayName = dateInput.Substring (0' 3);  	// If a dayName was specified. Check that the dateTime and the dayName  	// agrees on which day it is  	// This is just a failure-check and could be left out  	if ((dateTime.DayOfWeek == DayOfWeek.Monday && !dayName.Equals ("Mon")) || (dateTime.DayOfWeek == DayOfWeek.Tuesday && !dayName.Equals ("Tue")) || (dateTime.DayOfWeek == DayOfWeek.Wednesday && !dayName.Equals ("Wed")) || (dateTime.DayOfWeek == DayOfWeek.Thursday && !dayName.Equals ("Thu")) || (dateTime.DayOfWeek == DayOfWeek.Friday && !dayName.Equals ("Fri")) || (dateTime.DayOfWeek == DayOfWeek.Saturday && !dayName.Equals ("Sat")) || (dateTime.DayOfWeek == DayOfWeek.Sunday && !dayName.Equals ("Sun"))) {  		DefaultLogger.Log.LogDebug ("Day-name does not correspond to the weekday of the date: " + dateInput);  	}  }  
Magic Number,OpenPop.Mime.Decode,Rfc2822DateTime,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Mime\Decode\Rfc2822DateTime.cs,ValidateDayNameIfAny,The following statement contains a magic number: if (dateInput.Length >= 4 && dateInput [3] == ''') {  	string dayName = dateInput.Substring (0' 3);  	// If a dayName was specified. Check that the dateTime and the dayName  	// agrees on which day it is  	// This is just a failure-check and could be left out  	if ((dateTime.DayOfWeek == DayOfWeek.Monday && !dayName.Equals ("Mon")) || (dateTime.DayOfWeek == DayOfWeek.Tuesday && !dayName.Equals ("Tue")) || (dateTime.DayOfWeek == DayOfWeek.Wednesday && !dayName.Equals ("Wed")) || (dateTime.DayOfWeek == DayOfWeek.Thursday && !dayName.Equals ("Thu")) || (dateTime.DayOfWeek == DayOfWeek.Friday && !dayName.Equals ("Fri")) || (dateTime.DayOfWeek == DayOfWeek.Saturday && !dayName.Equals ("Sat")) || (dateTime.DayOfWeek == DayOfWeek.Sunday && !dayName.Equals ("Sun"))) {  		DefaultLogger.Log.LogDebug ("Day-name does not correspond to the weekday of the date: " + dateInput);  	}  }  
Magic Number,OpenPop.Mime.Decode,Rfc2822DateTime,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Mime\Decode\Rfc2822DateTime.cs,ValidateDayNameIfAny,The following statement contains a magic number: if (dateInput.Length >= 4 && dateInput [3] == ''') {  	string dayName = dateInput.Substring (0' 3);  	// If a dayName was specified. Check that the dateTime and the dayName  	// agrees on which day it is  	// This is just a failure-check and could be left out  	if ((dateTime.DayOfWeek == DayOfWeek.Monday && !dayName.Equals ("Mon")) || (dateTime.DayOfWeek == DayOfWeek.Tuesday && !dayName.Equals ("Tue")) || (dateTime.DayOfWeek == DayOfWeek.Wednesday && !dayName.Equals ("Wed")) || (dateTime.DayOfWeek == DayOfWeek.Thursday && !dayName.Equals ("Thu")) || (dateTime.DayOfWeek == DayOfWeek.Friday && !dayName.Equals ("Fri")) || (dateTime.DayOfWeek == DayOfWeek.Saturday && !dayName.Equals ("Sat")) || (dateTime.DayOfWeek == DayOfWeek.Sunday && !dayName.Equals ("Sun"))) {  		DefaultLogger.Log.LogDebug ("Day-name does not correspond to the weekday of the date: " + dateInput);  	}  }  
Magic Number,OpenPop.Mime.Decode,Utility,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Mime\Decode\Utility.cs,RemoveQuotesIfAny,The following statement contains a magic number: if (text [0] == '"' && text [text.Length - 1] == '"') {  	// Remove quotes at both ends  	return text.Substring (1' text.Length - 2);  }  
Magic Number,OpenPop.Mime.Decode,Utility,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Mime\Decode\Utility.cs,RemoveQuotesIfAny,The following statement contains a magic number: return text.Substring (1' text.Length - 2);  
Magic Number,OpenPop.Mime.Decode,QuotedPrintable,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Mime\Decode\QuotedPrintable.cs,Rfc2047QuotedPrintableDecode,The following statement contains a magic number: using (MemoryStream byteArrayBuilder = new MemoryStream ()) {  	// Remove illegal control characters  	toDecode = RemoveIllegalControlCharacters (toDecode);  	// Run through the whole string that needs to be decoded  	for (int i = 0; i < toDecode.Length; i++) {  		char currentChar = toDecode [i];  		if (currentChar == '=') {  			// Check that there is at least two characters behind the equal sign  			if (toDecode.Length - i < 3) {  				// We are at the end of the toDecode string' but something is missing. Handle it the way RFC 2045 states  				WriteAllBytesToStream (byteArrayBuilder' DecodeEqualSignNotLongEnough (toDecode.Substring (i)));  				// Since it was the last part' we should stop parsing anymore  				break;  			}  			// Decode the Quoted-Printable part  			string quotedPrintablePart = toDecode.Substring (i' 3);  			WriteAllBytesToStream (byteArrayBuilder' DecodeEqualSign (quotedPrintablePart));  			// We now consumed two extra characters. Go forward two extra characters  			i += 2;  		} else {  			// This character is not quoted printable hex encoded.  			// Could it be the _ character' which represents space  			// and are we using the encoded word variant of QuotedPrintable  			if (currentChar == '_' && encodedWordVariant) {  				// The RFC specifies that the "_" always represents hexadecimal 20 even if the  				// SPACE character occupies a different code position in the character set in use.  				byteArrayBuilder.WriteByte (0x20);  			} else {  				// This is not encoded at all. This is a literal which should just be included into the output.  				byteArrayBuilder.WriteByte ((byte)currentChar);  			}  		}  	}  	return byteArrayBuilder.ToArray ();  }  
Magic Number,OpenPop.Mime.Decode,QuotedPrintable,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Mime\Decode\QuotedPrintable.cs,Rfc2047QuotedPrintableDecode,The following statement contains a magic number: using (MemoryStream byteArrayBuilder = new MemoryStream ()) {  	// Remove illegal control characters  	toDecode = RemoveIllegalControlCharacters (toDecode);  	// Run through the whole string that needs to be decoded  	for (int i = 0; i < toDecode.Length; i++) {  		char currentChar = toDecode [i];  		if (currentChar == '=') {  			// Check that there is at least two characters behind the equal sign  			if (toDecode.Length - i < 3) {  				// We are at the end of the toDecode string' but something is missing. Handle it the way RFC 2045 states  				WriteAllBytesToStream (byteArrayBuilder' DecodeEqualSignNotLongEnough (toDecode.Substring (i)));  				// Since it was the last part' we should stop parsing anymore  				break;  			}  			// Decode the Quoted-Printable part  			string quotedPrintablePart = toDecode.Substring (i' 3);  			WriteAllBytesToStream (byteArrayBuilder' DecodeEqualSign (quotedPrintablePart));  			// We now consumed two extra characters. Go forward two extra characters  			i += 2;  		} else {  			// This character is not quoted printable hex encoded.  			// Could it be the _ character' which represents space  			// and are we using the encoded word variant of QuotedPrintable  			if (currentChar == '_' && encodedWordVariant) {  				// The RFC specifies that the "_" always represents hexadecimal 20 even if the  				// SPACE character occupies a different code position in the character set in use.  				byteArrayBuilder.WriteByte (0x20);  			} else {  				// This is not encoded at all. This is a literal which should just be included into the output.  				byteArrayBuilder.WriteByte ((byte)currentChar);  			}  		}  	}  	return byteArrayBuilder.ToArray ();  }  
Magic Number,OpenPop.Mime.Decode,QuotedPrintable,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Mime\Decode\QuotedPrintable.cs,Rfc2047QuotedPrintableDecode,The following statement contains a magic number: using (MemoryStream byteArrayBuilder = new MemoryStream ()) {  	// Remove illegal control characters  	toDecode = RemoveIllegalControlCharacters (toDecode);  	// Run through the whole string that needs to be decoded  	for (int i = 0; i < toDecode.Length; i++) {  		char currentChar = toDecode [i];  		if (currentChar == '=') {  			// Check that there is at least two characters behind the equal sign  			if (toDecode.Length - i < 3) {  				// We are at the end of the toDecode string' but something is missing. Handle it the way RFC 2045 states  				WriteAllBytesToStream (byteArrayBuilder' DecodeEqualSignNotLongEnough (toDecode.Substring (i)));  				// Since it was the last part' we should stop parsing anymore  				break;  			}  			// Decode the Quoted-Printable part  			string quotedPrintablePart = toDecode.Substring (i' 3);  			WriteAllBytesToStream (byteArrayBuilder' DecodeEqualSign (quotedPrintablePart));  			// We now consumed two extra characters. Go forward two extra characters  			i += 2;  		} else {  			// This character is not quoted printable hex encoded.  			// Could it be the _ character' which represents space  			// and are we using the encoded word variant of QuotedPrintable  			if (currentChar == '_' && encodedWordVariant) {  				// The RFC specifies that the "_" always represents hexadecimal 20 even if the  				// SPACE character occupies a different code position in the character set in use.  				byteArrayBuilder.WriteByte (0x20);  			} else {  				// This is not encoded at all. This is a literal which should just be included into the output.  				byteArrayBuilder.WriteByte ((byte)currentChar);  			}  		}  	}  	return byteArrayBuilder.ToArray ();  }  
Magic Number,OpenPop.Mime.Decode,QuotedPrintable,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Mime\Decode\QuotedPrintable.cs,Rfc2047QuotedPrintableDecode,The following statement contains a magic number: for (int i = 0; i < toDecode.Length; i++) {  	char currentChar = toDecode [i];  	if (currentChar == '=') {  		// Check that there is at least two characters behind the equal sign  		if (toDecode.Length - i < 3) {  			// We are at the end of the toDecode string' but something is missing. Handle it the way RFC 2045 states  			WriteAllBytesToStream (byteArrayBuilder' DecodeEqualSignNotLongEnough (toDecode.Substring (i)));  			// Since it was the last part' we should stop parsing anymore  			break;  		}  		// Decode the Quoted-Printable part  		string quotedPrintablePart = toDecode.Substring (i' 3);  		WriteAllBytesToStream (byteArrayBuilder' DecodeEqualSign (quotedPrintablePart));  		// We now consumed two extra characters. Go forward two extra characters  		i += 2;  	} else {  		// This character is not quoted printable hex encoded.  		// Could it be the _ character' which represents space  		// and are we using the encoded word variant of QuotedPrintable  		if (currentChar == '_' && encodedWordVariant) {  			// The RFC specifies that the "_" always represents hexadecimal 20 even if the  			// SPACE character occupies a different code position in the character set in use.  			byteArrayBuilder.WriteByte (0x20);  		} else {  			// This is not encoded at all. This is a literal which should just be included into the output.  			byteArrayBuilder.WriteByte ((byte)currentChar);  		}  	}  }  
Magic Number,OpenPop.Mime.Decode,QuotedPrintable,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Mime\Decode\QuotedPrintable.cs,Rfc2047QuotedPrintableDecode,The following statement contains a magic number: for (int i = 0; i < toDecode.Length; i++) {  	char currentChar = toDecode [i];  	if (currentChar == '=') {  		// Check that there is at least two characters behind the equal sign  		if (toDecode.Length - i < 3) {  			// We are at the end of the toDecode string' but something is missing. Handle it the way RFC 2045 states  			WriteAllBytesToStream (byteArrayBuilder' DecodeEqualSignNotLongEnough (toDecode.Substring (i)));  			// Since it was the last part' we should stop parsing anymore  			break;  		}  		// Decode the Quoted-Printable part  		string quotedPrintablePart = toDecode.Substring (i' 3);  		WriteAllBytesToStream (byteArrayBuilder' DecodeEqualSign (quotedPrintablePart));  		// We now consumed two extra characters. Go forward two extra characters  		i += 2;  	} else {  		// This character is not quoted printable hex encoded.  		// Could it be the _ character' which represents space  		// and are we using the encoded word variant of QuotedPrintable  		if (currentChar == '_' && encodedWordVariant) {  			// The RFC specifies that the "_" always represents hexadecimal 20 even if the  			// SPACE character occupies a different code position in the character set in use.  			byteArrayBuilder.WriteByte (0x20);  		} else {  			// This is not encoded at all. This is a literal which should just be included into the output.  			byteArrayBuilder.WriteByte ((byte)currentChar);  		}  	}  }  
Magic Number,OpenPop.Mime.Decode,QuotedPrintable,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Mime\Decode\QuotedPrintable.cs,Rfc2047QuotedPrintableDecode,The following statement contains a magic number: for (int i = 0; i < toDecode.Length; i++) {  	char currentChar = toDecode [i];  	if (currentChar == '=') {  		// Check that there is at least two characters behind the equal sign  		if (toDecode.Length - i < 3) {  			// We are at the end of the toDecode string' but something is missing. Handle it the way RFC 2045 states  			WriteAllBytesToStream (byteArrayBuilder' DecodeEqualSignNotLongEnough (toDecode.Substring (i)));  			// Since it was the last part' we should stop parsing anymore  			break;  		}  		// Decode the Quoted-Printable part  		string quotedPrintablePart = toDecode.Substring (i' 3);  		WriteAllBytesToStream (byteArrayBuilder' DecodeEqualSign (quotedPrintablePart));  		// We now consumed two extra characters. Go forward two extra characters  		i += 2;  	} else {  		// This character is not quoted printable hex encoded.  		// Could it be the _ character' which represents space  		// and are we using the encoded word variant of QuotedPrintable  		if (currentChar == '_' && encodedWordVariant) {  			// The RFC specifies that the "_" always represents hexadecimal 20 even if the  			// SPACE character occupies a different code position in the character set in use.  			byteArrayBuilder.WriteByte (0x20);  		} else {  			// This is not encoded at all. This is a literal which should just be included into the output.  			byteArrayBuilder.WriteByte ((byte)currentChar);  		}  	}  }  
Magic Number,OpenPop.Mime.Decode,QuotedPrintable,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Mime\Decode\QuotedPrintable.cs,Rfc2047QuotedPrintableDecode,The following statement contains a magic number: if (currentChar == '=') {  	// Check that there is at least two characters behind the equal sign  	if (toDecode.Length - i < 3) {  		// We are at the end of the toDecode string' but something is missing. Handle it the way RFC 2045 states  		WriteAllBytesToStream (byteArrayBuilder' DecodeEqualSignNotLongEnough (toDecode.Substring (i)));  		// Since it was the last part' we should stop parsing anymore  		break;  	}  	// Decode the Quoted-Printable part  	string quotedPrintablePart = toDecode.Substring (i' 3);  	WriteAllBytesToStream (byteArrayBuilder' DecodeEqualSign (quotedPrintablePart));  	// We now consumed two extra characters. Go forward two extra characters  	i += 2;  } else {  	// This character is not quoted printable hex encoded.  	// Could it be the _ character' which represents space  	// and are we using the encoded word variant of QuotedPrintable  	if (currentChar == '_' && encodedWordVariant) {  		// The RFC specifies that the "_" always represents hexadecimal 20 even if the  		// SPACE character occupies a different code position in the character set in use.  		byteArrayBuilder.WriteByte (0x20);  	} else {  		// This is not encoded at all. This is a literal which should just be included into the output.  		byteArrayBuilder.WriteByte ((byte)currentChar);  	}  }  
Magic Number,OpenPop.Mime.Decode,QuotedPrintable,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Mime\Decode\QuotedPrintable.cs,Rfc2047QuotedPrintableDecode,The following statement contains a magic number: if (currentChar == '=') {  	// Check that there is at least two characters behind the equal sign  	if (toDecode.Length - i < 3) {  		// We are at the end of the toDecode string' but something is missing. Handle it the way RFC 2045 states  		WriteAllBytesToStream (byteArrayBuilder' DecodeEqualSignNotLongEnough (toDecode.Substring (i)));  		// Since it was the last part' we should stop parsing anymore  		break;  	}  	// Decode the Quoted-Printable part  	string quotedPrintablePart = toDecode.Substring (i' 3);  	WriteAllBytesToStream (byteArrayBuilder' DecodeEqualSign (quotedPrintablePart));  	// We now consumed two extra characters. Go forward two extra characters  	i += 2;  } else {  	// This character is not quoted printable hex encoded.  	// Could it be the _ character' which represents space  	// and are we using the encoded word variant of QuotedPrintable  	if (currentChar == '_' && encodedWordVariant) {  		// The RFC specifies that the "_" always represents hexadecimal 20 even if the  		// SPACE character occupies a different code position in the character set in use.  		byteArrayBuilder.WriteByte (0x20);  	} else {  		// This is not encoded at all. This is a literal which should just be included into the output.  		byteArrayBuilder.WriteByte ((byte)currentChar);  	}  }  
Magic Number,OpenPop.Mime.Decode,QuotedPrintable,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Mime\Decode\QuotedPrintable.cs,Rfc2047QuotedPrintableDecode,The following statement contains a magic number: if (currentChar == '=') {  	// Check that there is at least two characters behind the equal sign  	if (toDecode.Length - i < 3) {  		// We are at the end of the toDecode string' but something is missing. Handle it the way RFC 2045 states  		WriteAllBytesToStream (byteArrayBuilder' DecodeEqualSignNotLongEnough (toDecode.Substring (i)));  		// Since it was the last part' we should stop parsing anymore  		break;  	}  	// Decode the Quoted-Printable part  	string quotedPrintablePart = toDecode.Substring (i' 3);  	WriteAllBytesToStream (byteArrayBuilder' DecodeEqualSign (quotedPrintablePart));  	// We now consumed two extra characters. Go forward two extra characters  	i += 2;  } else {  	// This character is not quoted printable hex encoded.  	// Could it be the _ character' which represents space  	// and are we using the encoded word variant of QuotedPrintable  	if (currentChar == '_' && encodedWordVariant) {  		// The RFC specifies that the "_" always represents hexadecimal 20 even if the  		// SPACE character occupies a different code position in the character set in use.  		byteArrayBuilder.WriteByte (0x20);  	} else {  		// This is not encoded at all. This is a literal which should just be included into the output.  		byteArrayBuilder.WriteByte ((byte)currentChar);  	}  }  
Magic Number,OpenPop.Mime.Decode,QuotedPrintable,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Mime\Decode\QuotedPrintable.cs,Rfc2047QuotedPrintableDecode,The following statement contains a magic number: if (toDecode.Length - i < 3) {  	// We are at the end of the toDecode string' but something is missing. Handle it the way RFC 2045 states  	WriteAllBytesToStream (byteArrayBuilder' DecodeEqualSignNotLongEnough (toDecode.Substring (i)));  	// Since it was the last part' we should stop parsing anymore  	break;  }  
Magic Number,OpenPop.Mime.Decode,QuotedPrintable,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Mime\Decode\QuotedPrintable.cs,Rfc2047QuotedPrintableDecode,The following statement contains a magic number: i += 2;  
Magic Number,OpenPop.Mime.Decode,QuotedPrintable,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Mime\Decode\QuotedPrintable.cs,DecodeEqualSignNotLongEnough,The following statement contains a magic number: if (decode.Length >= 3)  	throw new ArgumentException ("decode must have length lower than 3"' "decode");  
Magic Number,OpenPop.Mime.Decode,QuotedPrintable,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Mime\Decode\QuotedPrintable.cs,DecodeEqualSign,The following statement contains a magic number: if (decode.Length != 3)  	throw new ArgumentException ("decode must have length 3"' "decode");  
Magic Number,OpenPop.Mime.Decode,QuotedPrintable,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Mime\Decode\QuotedPrintable.cs,DecodeEqualSign,The following statement contains a magic number: try {  	// The number part of the string is the last two digits. Here we simply remove the equal sign  	string numberString = decode.Substring (1);  	// Now we create a byte array with the converted number encoded in the string as a hex value (base 16)  	// This will also handle illegal encodings like =3d where the hex digits are not uppercase'  	// which is a robustness requirement from RFC 2045.  	byte[] oneByte = new[] {  		Convert.ToByte (numberString' 16)  	};  	// Simply return our one byte byte array  	return oneByte;  } catch (FormatException) {  	// RFC 2045 says about robust implementation:  	// An "=" followed by a character that is neither a  	// hexadecimal digit (including "abcdef") nor the CR  	// character of a CRLF pair is illegal.  This case can be  	// the result of US-ASCII text having been included in a  	// quoted-printable part of a message without itself  	// having been subjected to quoted-printable encoding.  A  	// reasonable approach by a robust implementation might be  	// to include the "=" character and the following  	// character in the decoded data without any  	// transformation and' if possible' indicate to the user  	// that proper decoding was not possible at this point in  	// the data.  	// So we choose to believe this is actually an un-encoded string  	// Therefore it must be in US-ASCII and we will return the bytes it corrosponds to  	return Encoding.ASCII.GetBytes (decode);  }  
Magic Number,OpenPop.Mime,Message,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Mime\Message.cs,Load,The following statement contains a magic number: using (MemoryStream outStream = new MemoryStream ()) {  	#if DOTNET4  					// TODO: Enable using native v4 framework methods when support is formally added. 				messageStream.CopyTo(outStream); #else  	int bytesRead;  	byte[] buffer = new byte[4096];  	while ((bytesRead = messageStream.Read (buffer' 0' 4096)) > 0) {  		outStream.Write (buffer' 0' bytesRead);  	}  	#endif  	byte[] content = outStream.ToArray ();  	return new Message (content);  }  
Magic Number,OpenPop.Mime,Message,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Mime\Message.cs,Load,The following statement contains a magic number: using (MemoryStream outStream = new MemoryStream ()) {  	#if DOTNET4  					// TODO: Enable using native v4 framework methods when support is formally added. 				messageStream.CopyTo(outStream); #else  	int bytesRead;  	byte[] buffer = new byte[4096];  	while ((bytesRead = messageStream.Read (buffer' 0' 4096)) > 0) {  		outStream.Write (buffer' 0' bytesRead);  	}  	#endif  	byte[] content = outStream.ToArray ();  	return new Message (content);  }  
Magic Number,OpenPop.Mime,Message,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Mime\Message.cs,Load,The following statement contains a magic number: while ((bytesRead = messageStream.Read (buffer' 0' 4096)) > 0) {  	outStream.Write (buffer' 0' bytesRead);  }  
Magic Number,OpenPop.Pop3,CramMd5,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Pop3\CramMd5.cs,CramMd5,The following statement contains a magic number: ipad = new byte[64];  
Magic Number,OpenPop.Pop3,CramMd5,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Pop3\CramMd5.cs,CramMd5,The following statement contains a magic number: opad = new byte[64];  
Magic Number,OpenPop.Pop3,CramMd5,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Pop3\CramMd5.cs,GetSharedSecretInBytes,The following statement contains a magic number: if (passwordBytes.Length > 64) {  	passwordBytes = new MD5CryptoServiceProvider ().ComputeHash (passwordBytes);  }  
Magic Number,OpenPop.Pop3,CramMd5,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Pop3\CramMd5.cs,GetSharedSecretInBytes,The following statement contains a magic number: if (passwordBytes.Length != 64) {  	byte[] returner = new byte[64];  	for (int i = 0; i < passwordBytes.Length; i++) {  		returner [i] = passwordBytes [i];  	}  	return returner;  }  
Magic Number,OpenPop.Pop3,CramMd5,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Pop3\CramMd5.cs,GetSharedSecretInBytes,The following statement contains a magic number: if (passwordBytes.Length != 64) {  	byte[] returner = new byte[64];  	for (int i = 0; i < passwordBytes.Length; i++) {  		returner [i] = passwordBytes [i];  	}  	return returner;  }  
Magic Number,OpenPop.Pop3,Pop3Client,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Pop3\Pop3Client.cs,GetMessageUid,The following statement contains a magic number: return LastServerResponse.Split (' ') [2];  
Magic Number,OpenPop.Pop3,Pop3Client,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Pop3\Pop3Client.cs,GetMessageSize,The following statement contains a magic number: return SendCommandIntResponse ("LIST " + messageNumber' 2);  
Missing Default,OpenPop.Pop3,Pop3Client,F:\newReposMay17\EdenRidgway_nDumbster\OpenPop\Pop3\Pop3Client.cs,Authenticate,The following switch statement is missing a default case: switch (authenticationMethod) {  case AuthenticationMethod.UsernameAndPassword:  	AuthenticateUsingUserAndPassword (username' password);  	break;  case AuthenticationMethod.Apop:  	AuthenticateUsingApop (username' password);  	break;  case AuthenticationMethod.Auto:  	if (ApopSupported)  		AuthenticateUsingApop (username' password);  	else  		AuthenticateUsingUserAndPassword (username' password);  	break;  case AuthenticationMethod.CramMd5:  	AuthenticateUsingCramMd5 (username' password);  	break;  }  
